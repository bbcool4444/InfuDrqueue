/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 * code generator gen_msl, build 126420.5925.2036
 *                                                                            *
 * Portions Copyright (c) 1986-2010 mental images GmbH, Berlin, Germany.      *
 ******************************************************************************/


// Option settings:
//	shader_type : surface


shader mia_light_surface {

output:

    Color result;

input:

    Color color = float4(1.0f,1.0f,1.0f,1.0f);
    float intensity = 1.0f;
    float fg_contrib = 0.0f;
    float refl_contrib = 0.0f;
    bool use_lights = false;
    float lights_multiplier = 1.0f;
    float3 lights_eval_point = float3(0.0f,0.0f,0.0f);

member:


    void main()
    {
        result = float4(0.0f,0.0f,0.0f,0.0f);
        Color X0000000 = float4(0.0f,0.0f,0.0f,0.0f);
        float X0000001 = 0.0f;
        float X0000002 = 0.0f;
        Color X0000003 = float4(0.0f,0.0f,0.0f,0.0f);
        float X0000004 = 1.0f;
        if(state::ray_shader == "displace")
            return;
        if(state::ray_type == "shadow") {
            return;
        }
        if(is_ray_history_group("final_gather")) {
            X0000004 *= fg_contrib;
        }
        if(state::ray_type == "reflect") {
            X0000004 *= refl_contrib;
        }
        if(X0000004 <= 0.0f)
            return;
        X0000003 = color;
        result = X0000003;
        X0000001 = intensity * X0000004;
        result.rgb *= X0000001;
        if(!use_lights)
            return;
        X0000002 = lights_multiplier * X0000004;
        if(X0000002 > 0.0f) {
            float3 X0000005 = lights_eval_point;
            bool X0000006 = (X0000005.x != 0.0f || X0000005.y != 0.0f) || X0000005.z != 0.0f;
            float3 X0000007 = state::normal;
            state::normal = float3(0.0f,0.0f,0.0f);
            if(X0000006)
                state::position = transform_point("light","internal",X0000005);
            Light_iterator_options X0000008;
            X0000008.set_cone(state::normal,180.0f);
            Light_iterator X0000009 = Light_iterator(X0000008);
            foreach(X0000009) {
                X0000000 += X0000009.contribution;
            }
            result.rgb += (X0000000.rgb * X0000003.rgb) * X0000002;
            state::normal = X0000007;
        }
    }
};
