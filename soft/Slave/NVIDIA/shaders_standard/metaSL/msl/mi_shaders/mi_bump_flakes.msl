/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 * code generator gen_msl, build 126420.5925.2036
 *                                                                            *
 * Portions Copyright (c) 1986-2010 mental images GmbH, Berlin, Germany.      *
 ******************************************************************************/


// Option settings:
//	shader_type : surface


shader mi_bump_flakes {

output:

    Color result;
    float3 normal_result;

input:

    Color flake_color = float4(0.0f,0.0f,0.0f,0.0f);
    float flake_density = 0.5f;
    float flake_strength = 0.8f;
    float flake_scale = 0.2f;
    bool evalNormal = false;
    texture2D mi_noise_table = "mi_noise.dds"
            {
                description("The texture containing the noise table.");
                disable_filtering();
                texture_coord_u("clamp");
                texture_coord_v("clamp");
            };

member:


    float X0000000(int X0000003)
    {
        int X0000004 = X0000003 % 256;
        int X0000005 = X0000003 / 256;
        float X0000006 = (2.0f * float(X0000004) + 1.0f) / 512.0f;
        float X0000007 = (2.0f * float(X0000005) + 1.0f) / 256.0f;
        Color X0000008 = tex2D(mi_noise_table,float2(X0000006,X0000007));
        return X0000008.r;
    }

    float X0000001(in int X0000009,in bool X0000010,in bool X0000011,in float X0000012,in float X0000013,in float X0000014,out float X0000015,out float X0000016,out float X0000017)
    {
        int X0000018, X0000019, X0000020, X0000021, X0000022, X0000023;
        float X0000024, X0000025, X0000026, X0000027;
        float X0000028[9];
        float X0000029[9];
        float X0000030[3];
        float X0000031[9], X0000032[3];
        float X0000033[9], X0000034[3], X0000035[3], X0000036, X0000037, X0000038;
        X0000015 = (X0000016 = (X0000017 = 0.0f));
        X0000027 = 0.0f;
        if(X0000012 < -39999.0f)
            X0000012 = -39998.0f - X0000012;
        else
            X0000012 += 40000.0f;
        if(X0000013 < -39999.0f)
            X0000013 = -39998.0f - X0000013;
        else
            X0000013 += 40000.0f;
        if(X0000014 < -39999.0f)
            X0000014 = -39998.0f - X0000014;
        else
            X0000014 += 40000.0f;
        X0000021 = int((X0000024 = X0000012 - .5f));
        X0000022 = int((X0000025 = X0000013 - .5f));
        X0000023 = int((X0000026 = X0000014 - .5f));
        X0000030[0] = X0000024 - float(X0000021);
        X0000030[1] = X0000025 - float(X0000022);
        X0000030[2] = X0000026 - float(X0000023);
        for(X0000018 = 0; X0000018 < 3; ++X0000018) {
            X0000024 = 1.0f - X0000030[X0000018];
            X0000028[(X0000018 * 3)] = (X0000024 * X0000024) * .5f;
            X0000029[(X0000018 * 3)] = -X0000024;
            X0000024 = X0000030[X0000018] - .5f;
            X0000028[(1 + X0000018 * 3)] = -X0000024 * X0000024 + .75f;
            X0000029[(1 + X0000018 * 3)] = -2.0f * X0000024;
            X0000028[(2 + X0000018 * 3)] = (X0000030[X0000018] * X0000030[X0000018]) * .5f;
            X0000029[(2 + X0000018 * 3)] = X0000030[X0000018];
        }
        float X0000039 = 1.0f;
        for((X0000036 = (X0000037 = (X0000038 = (X0000024 = 0.0f))),X0000018 = 0); X0000018 < 3; ++X0000018) {
            for((X0000034[X0000018] = (X0000035[X0000018] = (X0000032[X0000018] = 0.0f)),X0000019 = 0); X0000019 < 3; ++X0000019) {
                for((X0000033[(X0000018 + X0000019 * 3)] = (X0000031[(X0000018 + X0000019 * 3)] = 0.0f),X0000020 = 0); X0000020 < 3; ++X0000020) {
                    X0000039 = X0000000((((X0000021 + X0000020) * 1341 + (X0000022 + X0000019) * 719) + (X0000023 + X0000018) * 2031) % 1);
                    X0000031[(X0000018 + X0000019 * 3)] += X0000028[X0000020] * X0000039;
                    X0000033[(X0000018 + X0000019 * 3)] += X0000029[X0000020] * X0000039;
                }
                X0000032[X0000018] += X0000028[(X0000019 + 3)] * X0000031[(X0000018 + X0000019 * 3)];
                X0000034[X0000018] += X0000028[(X0000019 + 3)] * X0000033[(X0000018 + X0000019 * 3)];
                X0000035[X0000018] += X0000029[(X0000019 + 3)] * X0000031[(X0000018 + X0000019 * 3)];
            }
            X0000024 += X0000028[(X0000018 + 6)] * X0000032[X0000018];
            X0000036 += X0000028[(X0000018 + 6)] * X0000034[X0000018];
            X0000037 += X0000028[(X0000018 + 6)] * X0000035[X0000018];
            X0000038 += X0000029[(X0000018 + 6)] * X0000032[X0000018];
        }
        X0000015 = X0000036;
        X0000016 = X0000037;
        X0000017 = X0000038;
        X0000027 = X0000024;
        return X0000027;
    }

    float X0000002(in float3 X0000040,out float3 X0000041)
    {
        return X0000001(3,true,false,X0000040.x,X0000040.y,X0000040.z,X0000041.x,X0000041.y,X0000041.z);
    }

    void main()
    {
        result = flake_color;
        float3 X0000042 = float3(0.0f,0.0f,0.0f);
        float3 X0000043 = float3(0.0f,0.0f,0.0f);
        float X0000044 = 0.0f;
        float X0000045 = flake_density;
        float X0000046 = flake_scale;
        float X0000047 = flake_strength;
        if(X0000045 <= 0.0f)
            X0000045 = 0.5f;
        if(X0000046 <= 0.0f)
            X0000046 = 1.0f;
        float3 X0000048;
        X0000048 = transform_point("internal","object",state::position);
        X0000048.xyz /= X0000046;
        X0000002(X0000048,X0000042);
        X0000048 += X0000042 * 2.0f;
        X0000048 = floor(X0000048);
        X0000044 = X0000002(X0000048,X0000042);
        X0000043 = transform_normal("object","internal",X0000042);
        X0000044 = pow(X0000044,1.0f / X0000045);
        state::normal += X0000043 * X0000047;
        state::normal = normalize(state::normal);
        normal_result = state::normal;
        result.rgb *= X0000044;
    }
};
