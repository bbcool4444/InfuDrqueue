/******************************************************************************
 * Copyright 1986-2010 by mental images GmbH, Fasanenstr. 81, D-10623 Berlin,
 * Germany. All rights reserved.
 *****************************************************************************/
/*** This code was generated by gen_msl ***/

shader mia_material {

input:

	float diffuse_weight = 1.0
		{
			display_name("Diffuse level");
			description("the maximum amount of diffuse reflection");
			hard_range(0.0,1.0);
		};
	Color diffuse = float4(0.5,0.5,0.5,1.0)
		{
			display_name("Color");
			description("The color of the diffuse reflection, or, when using 'Metal Material' the color of the metal itself");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
		};
	float diffuse_roughness = 0.0
		{
			display_name("Roughness");
			description("adjusts the material's roughness. Higher values yield more 'powdery' surfaces like clay");
			hard_range(0.0,1.0);
		};
	float reflectivity = 0.6
		{
			display_name("Reflectivity");
			description("The maximum amount of glossy/mirror reflectivity. The final also amount depends on the settings of the BRDF curve as w scales the reflectivy of the material");
			hard_range(0.0,1.0);
		};
	Color refl_color = float4(1.0,1.0,1.0,1.0)
		{
			display_name("Reflection color");
			description("The color/intensity of the reflection. When metal material is on, the color of the reflection is influenced as well");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
		};
	float refl_gloss = 1.0
		{
			display_name("Reflection glossiness");
			description("The blurriness / sharpness of reflections. A value of 1.0 means that the surface is a perfect mirror");
			hard_range(0.0,1.0);
		};
	const int refl_gloss_samples = 8
		{
			display_name("Reflection gloss samples");
			description("The quality of glossy reflections. The higher the value, the better the quality but rendering time will increase as well.");
			soft_range(0,128);
			literal();
		};
	const bool refl_interpolate = false
		{
			display_name("Fast Reflection (interpolate)");
			description("turns interpolation (= acceleration) for reflections on/off. When on, speed increases at a certain loss of quality. Works best with flat surfaces.");
			literal();
		};
	const bool refl_hl_only = false
		{
			display_name("Reflect highlights and FG only");
			description(" highlights / final gathering only will be reflected");
		};
	const bool refl_is_metal = false
		{
			display_name("Metal material");
			description("causes reflections to be tint in material's color");
		};
	float transparency = 0.0
		{
			display_name("Transparency");
			description("The maximum amount of transparency");
			hard_range(0.0,1.0);
		};
	Color refr_color = float4(1.0,1.0,1.0,1.0)
		{
			display_name("Refraction color");
			description("color / intensity of refractions. The 'easiest' way to create colored glass");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
		};
	float refr_gloss = 1.0
		{
			display_name("Refraction glossiness");
			description("The blurriness / sharpness of the transparency. A value of 1.0 means that the surface is 'clear'. The lower the value the glossier objects appear behind ");
			hard_range(0.0,1.0);
		};
	float refr_ior = 1.4
		{
			display_name("Index of refraction");
			description("Index of refraction. Water has the value 1.33 ");
			soft_range(0.01,4.0);
		};
	const int refr_gloss_samples = 8
		{
			display_name("Refraction gloss samples");
			description("The quality of glossy transparency. Higher values yield better results but increase rendering time as well");
			soft_range(0,128);
			literal();
		};
	const bool refr_interpolate = false
		{
			display_name("Refraction interpolate");
			description("Turns interpolation (=acceleration) for refractions on/off");
			literal();
		};
	const bool refr_translucency = false
		{
			display_name("Refraction translucency");
			description("if on, a surface will be lit even if the light come from the opposite side");
		};
	Color refr_trans_color = float4(0.7,0.6,0.5,1.0)
		{
			display_name("Refraction translucent color");
			description("transluscent color for rays exiting a refractive object");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
		};
	float refr_trans_weight = 0.5
		{
			display_name("Refraction translucent weight");
			description("attenuation of translucency");
			hard_range(0.0,1.0);
		};
	float anisotropy = 1.0
		{
			display_name("Anisotropy");
			description("values different from 1.0 will stretch the highlight to give the impression of a brushed surface");
			soft_range(0.0,2.0);
		};
	float anisotropy_rotation = 0.0
		{
			display_name("Anisotropy rotation");
			description("orientation of anisotropic highlights. The range from 0 to 1 will be mapped to 0 to 360 degrees ");
			soft_range(0.0,1.0);
		};
	const int anisotropy_channel = -1
		{
			display_name("anisotropy channel");
			description("Direction of anisotropy will either be generated automatically or mapped using a given texture channel");
			literal();
		};
	const bool brdf_fresnel = false
		{
			display_name("BRDF fresnel");
			description("When on, uses fresnel term to calculate reflection falloff which is defined by a physical term. If off, the other BRDF terms will be used to calculate the falloff function");
		};
	float brdf_0_degree_refl = 0.2
		{
			display_name("BRDF 0 degree reflection");
			description("Reflectivity at 0 degrees, i.e. when the surface is directly facing the viewer");
			hard_range(0.0,1.0);
		};
	float brdf_90_degree_refl = 1.0
		{
			display_name("BRDF 90 degree reflection");
			description("Reflectivity at 90 degrees i.e. when the surface is seen at grazing angles ");
			hard_range(0.0,1.0);
		};
	const float brdf_curve = 5.0
		{
			display_name("BRDF Curve shape ");
			description("Tweaks the shape of the falloff curve function. ");
			soft_range(0.0,10.0);
		};
	const bool brdf_conserve_energy = true
		{
			display_name("BRDF conserve energy");
			description("when on, material is guarenteed to be energy conserving");
		};
	const int intr_grid_density = 2
		{
			display_name("Interpolation Grid density");
			description("interpolation grid size. Low values give more accurate results ");
			hard_range(0,5);
			literal();
		};
	const int intr_refl_samples = 2
		{
			display_name("Reflection interpolation points to look up");
			description("how many nearby points to look up. Higher values yield blurrier results ");
			hard_range(0,10);
			literal();
		};
	const bool intr_refl_ddist_on = false
		{
			display_name("Reflection interpolation use high detail");
			description("Uses true raytracing for nearby reflections to give more detail.");
			literal();
		};
	float intr_refl_ddist = 0.0
		{
			display_name("Reflection interpolation detail distance");
			description("Reflections within this distance will use 'regular' raytracing ");
			literal();
		};
	int intr_refr_samples = 2
		{
			display_name("Refraction interpolation samples");
			description("how many nearby points to look up. Higher values yield blurrier results");
			literal();
		};
	const bool single_env_sample = false
		{
			display_name("Single sample from environment");
			description("Reduces noise in glosy environment reflections by looking it up only once");
			literal();
		};
	const bool refl_falloff_on = false
		{
			display_name("Reflection falloff");
			description("When on, limits the reach of reflections to a certain distance");
			literal();
		};
	float refl_falloff_dist = 0.0
		{
			display_name("Reflection falloff distance");
			description("maximum reach of reflections");
			soft_range(0,150);
			literal();
		};
	const bool refl_falloff_color_on = false
		{
			display_name("Reflection fade to end color");
			description("When on, reflections fade with the distance to a given color");
			literal();
		};
	Color refl_falloff_color = float4(0.0,0.0,0.0,1.0)
		{
			display_name("Reflection falloff color");
			description("reflection fades towards this color with the distance");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
			literal();
		};
	const int refl_depth = 5
		{
			display_name("Reflection max trace depth");
			description("maximum trace depth for reflections");
			soft_range(0,12);
			literal();
		};
	float refl_cutoff = 0.01
		{
			display_name("Reflection cutoff threshold");
			description("sets the relative level at which reflections begin to be optimized outto speed up rendering");
			soft_range(0.0,0.2);
			literal();
		};
	const bool refr_falloff_on = false
		{
			display_name("Refraction falloff active");
			description("when on, limits the reach of transparency so that it fades with the distancetowards a given color");
			literal();
		};
	float refr_falloff_dist = 0.0
		{
			display_name("Refraction falloff distance");
			description("maximum length for refractions");
			soft_range(0,200.0);
			literal();
		};
	const bool refr_falloff_color_on = false
		{
			display_name("Refraction fade to color");
			description("When active, refractions fade towards an end color.");
			literal();
		};
	Color refr_falloff_color = float4(0.0,0.0,0.0,1.0)
		{
			display_name("Refraction falloff color");
			description("when refraction falloff is on, falloff refraction will fade towards this color");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
			literal();
		};
	const int refr_depth = 5
		{
			display_name("Refraction max trace depth");
			description("maximum trace depth for refractions ");
			soft_range(0,12);
			literal();
		};
	float refr_cutoff = 0.01
		{
			display_name("refraction contribution cutoff");
			description("sets the relative level at which refractions begin to be optimized out to speed up rendering");
			soft_range(0.0,0.2);
			literal();
		};
	float indirect_multiplier = 1.0
		{
			display_name("FG / GI multiplier");
			description("Sets the level of indirect illumination contribution from final gathering / photons");
			soft_range(0.0,10.0);
			literal();
		};
	float fg_quality = 1.0
		{
			display_name("Final Gather quality");
			description("A local multiplier to the number of 'Rays per final gather point'");
			soft_range(0.0,100.0);
			literal();
		};
	float fg_quality_w = 1.0
		{
			display_name("Additional multiplier");
			description("Additional multiplier");
			soft_range(0.0,10.0);
			literal();
		};
	const bool ao_on = false
		{
			display_name("Ambient occlusion active");
			description("activates ambient occlusion (AO) ");
		};
	const int ao_samples = 16
		{
			display_name("Ambient occlusion samples");
			description("The quality of ambient occlusion. Higher values will give better results at the cost of increased render time");
			literal();
		};
	float ao_distance = 10.0
		{
			display_name("Ambient occlusion max distance");
			description("Sets the distance within which the ambient occlusion operates ");
			soft_range(0.0,200.0);
		};
	Color ao_dark = float4(0.2,0.2,0.2,1.0)
		{
			display_name("ambient occlusion dark color");
			description("Sets the 'darkness' for the deepest crevice");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
		};
	Color ao_ambient = float4(0.0,0.0,0.0,1.0)
		{
			display_name("Ambient occlusion ambient color");
			description("Additional ambient light for ambient occlusion ");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
		};
	const bool ao_do_details = true
		{
			display_name("Ambient occlusion details");
			description("When on, AO will affect indirect illumination ");
		};
	const bool thin_walled = false
		{
			display_name("Thin walled mode");
			description("When off, objects need to be closed to have correct refractions. When on, refraction is discarded");
		};
	const bool no_visible_area_hl = true
		{
			display_name("No visible area highlights");
			description("visible area lights produce no specular highlight");
			literal();
		};
	const bool skip_inside_refl = true
		{
			display_name("Skip reflection on inside");
			description("skips weak internal reflections ");
		};
	const bool do_refractive_caustics = false
		{
			display_name("Refract caustics");
			description("When activated, caustics will be refracted. When off, photons can pass through the material without causing caustics");
			literal();
		};
	const bool backface_cull = false
		{
			display_name("Backface culling active");
			description("Makes surfaces invisible to the camera when seen from the other side");
		};
	const bool propagate_alpha = false
		{
			display_name("propagate alpha");
			description("When off transparent objects don't propagate the alpha channel.");
			literal();
		};
	const float hl_vs_refl_balance = 1.0
		{
			display_name("Highlight vs. reflection balance");
			description("Adjusts the weight of the highlight. A value of 0 shows only reflections an no specular highlights at all.");
			hard_range(0.0,1.0);
		};
	float cutout_opacity = 1.0
		{
			display_name("Cutout opacity");
			description("Best to be mapped with a texture. Where the map is white, the object will be visible, black means that the object won't be seen at all");
			hard_range(0.0,1.0);
		};
	Color additional_color = float4(0.0,0.0,0.0,1.0)
		{
			display_name("Additional color");
			description("Use this parameter to add self illumination, for example");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
			literal();
		};
	Shader bump;
	const bool no_diffuse_bump = false;
	const int mode = 0
		{
			literal();
		};
	const int lights = 0
		{
			literal();
		};
	const int lights2 = 0
		{
			literal();
		};
	const int lights3 = 0
		{
			literal();
		};

output:

	Color result;

	void X0000000(out float3 X0000027,out float3 X0000028,in int X0000029,in float3 X0000030)
	{
		float3 X0000031 = float3(0.0,0.0,1.0);
		float X0000032;
		X0000031 = transform_vector("object","internal",X0000031);
		X0000031 = normalize(X0000031);
		X0000032 = dot(X0000030,X0000031);
		if(abs(X0000032) > 0.99999)
			{
				X0000031 = float3(0.0,1.0,0.0);
				X0000031 = transform_vector("object","internal",X0000031);
				X0000031 = normalize(X0000031);
				X0000032 = dot(X0000030,X0000031);
				if(abs(X0000032) > 0.99999)
					{
						X0000031 = float3(1.0,0.0,0.0);
						X0000031 = transform_vector("object","internal",X0000031);
						X0000031 = normalize(X0000031);
						X0000032 = dot(X0000030,X0000031);
					}
			}
		X0000031 -= X0000030 * X0000032;
		X0000031 = normalize(X0000031);
		X0000028 = X0000031;
		X0000027 = cross(X0000028,X0000030);
	}


	void X0000001(out float3 X0000036,out float3 X0000037,inout float3 X0000039)
	{
		int X0000040 = anisotropy_channel;
		bump.call("output","normal_result",X0000039);
		X0000000(X0000036,X0000037,X0000040,X0000039);
		float X0000041;
		X0000041 = dot(X0000039,X0000036);
		X0000036 -= X0000039 * X0000041;
		X0000036 = normalize(X0000036);
		X0000041 = dot(X0000039,X0000037);
		X0000037 -= X0000039 * X0000041;
		X0000037 = normalize(X0000037);
		if(anisotropy_rotation != 0.0)
			{
				float X0000042 = (anisotropy_rotation * 3.14159265358979323846) * 2.0;
				float X0000043 = cos(X0000042);
				float X0000044 = sin(X0000042);
				float3 X0000045 = X0000043 * X0000036 + X0000044 * X0000037;
				X0000037 = -X0000044 * X0000036 + X0000043 * X0000037;
				X0000036 = X0000045;
			}
	}


	float X0000002(in float X0000046,in float X0000047,in float X0000048,in float X0000049)
	{
		float X0000050;
		float X0000051;
		float X0000052;
		float X0000053;
		if(X0000046 == X0000047)
			{
				return 0.0;
			}
		else
			{
				X0000050 = X0000046 * X0000049 + X0000047 * X0000048;
				if(X0000050 == 0.0)
					{
						X0000052 = 1.0;
					}
				else
					{
						X0000052 = (X0000046 * X0000049 - X0000047 * X0000048) / X0000050;
					}
				X0000051 = X0000046 * X0000048 + X0000047 * X0000049;
				if(X0000051 == 0.0)
					{
						X0000053 = 1.0;
					}
				else
					{
						X0000053 = (X0000046 * X0000048 - X0000047 * X0000049) / X0000051;
					}
				return 0.5 * (X0000052 * X0000052 + X0000053 * X0000053);
			}
	}


	float X0000003(in float X0000054,in float X0000055,in float X0000056)
	{
		float X0000057;
		float X0000058;
		X0000057 = X0000055 / X0000056;
		X0000058 = 1.0 - (X0000057 * X0000057) * (1.0 - X0000054 * X0000054);
		if(X0000058 > 0.0)
			{
				return X0000002(X0000055,X0000056,X0000054,-sqrt(X0000058));
			}
		else
			{
				return 1.0;
			}
	}


	void X0000004(out bool X0000059,out bool X0000060,out float X0000061,out Color X0000062,out Color X0000063,out Color X0000064,out float X0000065,out bool X0000066,out bool X0000067,out float X0000068,out Color X0000069,out bool X0000070,out bool X0000071,out float X0000072,out int X0000073,out float X0000074,out float X0000075,out float X0000076,out int X0000077,out float X0000078,out float X0000079,out int X0000080,out float X0000081,out bool X0000082,out float X0000083,out bool X0000084,out Color X0000085,out bool X0000086,out bool X0000087,out float X0000088,in float3 X0000089,in float3 X0000090,in float X0000091,in bool X0000092)
	{
		X0000085 = float4(0.0,0.0,0.0,0.0);
		Color X0000093 = float4(0.212671,0.715160,0.072169,0.0);
		X0000059 = no_diffuse_bump;
		X0000060 = refl_hl_only;
		X0000061 = anisotropy;
		float X0000094 = diffuse_weight;
		float X0000095 = reflectivity;
		float X0000096 = transparency;
		X0000062 = diffuse;
		X0000063 = refl_color;
		X0000064 = refr_color;
		X0000065 = refr_ior;
		X0000066 = thin_walled;
		X0000067 = single_env_sample;
		if(brdf_fresnel)
			{
				if(X0000092 && !X0000066)
					{
						X0000095 *= X0000003(-abs(X0000091),X0000065,1.0);
					}
				else
					{
						X0000095 *= X0000003(-abs(X0000091),1.0,X0000065);
					}
			}
		else
			{
				float X0000097 = brdf_0_degree_refl;
				float X0000098 = brdf_90_degree_refl;
				float X0000099 = brdf_curve;
				float X0000100 = pow(1.0 - abs(dot(X0000089,X0000090)),X0000099);
				X0000095 *= X0000098 * X0000100 + X0000097 * (1.0 - X0000100);
			}
		if((X0000092 && !X0000066) && skip_inside_refl)
			{
				X0000068 = smoothstep(0.5,0.9,X0000095);
			}
		else
			{
				X0000068 = 1.0;
			}
		if(refl_is_metal)
			{
				X0000094 *= 1.0 - ((X0000063.r * X0000093.r + X0000063.g * X0000093.g) + X0000063.b * X0000093.b) * X0000095;
				if(X0000094 < 0.0)
					{
						X0000094 = 0.0;
					}
				X0000063.r *= X0000062.r;
				X0000063.g *= X0000062.g;
				X0000063.b *= X0000062.b;
			}
		X0000062.a = (X0000062.r * X0000093.r + X0000062.g * X0000093.g) + X0000062.b * X0000093.b;
		X0000063.a = (X0000063.r * X0000093.r + X0000063.g * X0000093.g) + X0000063.b * X0000093.b;
		X0000064.a = (X0000064.r * X0000093.r + X0000064.g * X0000093.g) + X0000064.b * X0000093.b;
		X0000063 *= X0000095;
		if(brdf_conserve_energy)
			{
				float X0000101 = X0000064.a * X0000096;
				if(X0000101 > 1.0)
					{
						X0000101 = 1.0;
					}
				X0000094 *= 1.0 - X0000101;
			}
		if(brdf_conserve_energy)
			{
				float X0000102 = X0000063.a;
				if(X0000102 > 1.0)
					{
						X0000102 = 1.0;
					}
				X0000096 *= 1.0 - X0000102;
				X0000094 *= 1.0 - X0000102;
			}
		if((X0000092 || X0000066) && refr_translucency)
			{
				float X0000103 = refr_trans_weight;
				X0000069 = refr_trans_color;
				X0000069.r *= (X0000064.r * X0000096) * X0000103;
				X0000069.g *= (X0000064.g * X0000096) * X0000103;
				X0000069.b *= (X0000064.b * X0000096) * X0000103;
				X0000069.a = (X0000069.r * X0000093.r + X0000069.g * X0000093.g) + X0000069.b * X0000093.b;
				X0000096 *= 1.0 - X0000103;
			}
		else
			{
				X0000069 = float4(0.0,0.0,0.0,0.0);
			}
		X0000064 *= X0000096;
		if(X0000060)
			{
				X0000094 += X0000063.a;
			}
		X0000062 *= X0000094;
		X0000070 = ao_on;
		if(X0000070)
			{
				X0000071 = ao_do_details;
				X0000072 = ao_distance;
				X0000073 = ao_samples;
			}
		else
			{
				X0000071 = false;
				X0000072 = 0.0;
				X0000073 = 1;
			}
		X0000074 = 0.0;
		X0000075 = hl_vs_refl_balance;
		X0000076 = refl_gloss;
		X0000077 = refl_gloss_samples;
		X0000078 = refl_cutoff;
		X0000074 = intr_refl_ddist;
		X0000079 = refr_gloss;
		X0000080 = refr_gloss_samples;
		X0000081 = refr_cutoff;
		X0000082 = refr_falloff_on;
		X0000083 = refr_falloff_dist;
		if(X0000064.a > 0.0)
			{
				if(X0000082)
					{
						X0000084 = refr_falloff_color_on;
						if(X0000084)
							{
								X0000085 = refr_falloff_color;
								if(X0000085.r < 0.0)
									{
										X0000085.r = 0.0;
									}
								if(X0000085.g < 0.0)
									{
										X0000085.g = 0.0;
									}
								if(X0000085.b < 0.0)
									{
										X0000085.b = 0.0;
									}
								X0000085.a = (X0000085.r * X0000093.r + X0000085.g * X0000093.g) + X0000085.b * X0000093.b;
							}
					}
				else
					{
						X0000083 = 0.0;
					}
			}
		else
			{
				X0000082 = false;
				X0000084 = false;
			}
		X0000086 = refl_interpolate;
		X0000087 = refr_interpolate;
		float X0000104 = fg_quality_w;
		X0000088 = fg_quality;
		if(X0000104 > 0.0)
			{
				X0000088 *= X0000104;
				if(X0000088 < 1.0)
					{
						X0000088 = 1.0;
					}
			}
	}


	Color X0000005(in Light_iterator X0000105,in Color X0000106,in float3 X0000107,in float3 X0000108)
	{
		float X0000109 = 0.0;
		if(X0000105.dot_nl < 0.9999)
			{
				X0000109 = acos(X0000105.dot_nl);
			}
		if(X0000109 < -3.14159265358979323846 * 0.49)
			{
				X0000109 = -3.14159265358979323846 * 0.49;
			}
		if(X0000109 > 3.14159265358979323846 * 0.49)
			{
				X0000109 = 3.14159265358979323846 * 0.49;
			}
		float3 X0000110 = X0000107;
		float X0000111 = dot(X0000108,X0000110);
		if(X0000111 < 0.0)
			{
				X0000111 = -X0000111;
				X0000110.x = -(X0000110.x);
				X0000110.y = -(X0000110.y);
				X0000110.z = -(X0000110.z);
			}
		float X0000112 = 0.0;
		if(X0000111 < 0.9999)
			{
				X0000112 = acos(X0000111);
			}
		if(X0000109 < X0000112)
			{
				float X0000113 = X0000112;
				X0000112 = X0000109;
				X0000109 = X0000113;
			}
		float3 X0000114;
		float3 X0000115;
		X0000114.x = X0000110.x - X0000108.x * X0000111;
		X0000114.y = X0000110.y - X0000108.y * X0000111;
		X0000114.z = X0000110.z - X0000108.z * X0000111;
		X0000115.x = (X0000105.direction).x - X0000108.x * X0000105.dot_nl;
		X0000115.y = (X0000105.direction).y - X0000108.y * X0000105.dot_nl;
		X0000115.z = (X0000105.direction).z - X0000108.z * X0000105.dot_nl;
		float X0000116 = length(X0000114) * length(X0000115);
		float X0000117;
		if(abs(X0000116) < 0.0001)
			{
				X0000117 = 1.0;
			}
		else
			{
				X0000117 = dot(X0000114,X0000115) / X0000116;
			}
		if(X0000117 < -1.0)
			{
				X0000117 = -1.0;
			}
		if(X0000117 > 1.0)
			{
				X0000117 = 1.0;
			}
		float X0000118;
		float X0000119;
		if(X0000117 >= 0.0)
			{
				X0000119 = (2.0 * -X0000112) * (1.0 / 3.14159265358979323846);
			}
		else
			{
				X0000119 = (2.0 * X0000112) * (1.0 / 3.14159265358979323846);
			}
		X0000118 = (X0000119 * X0000119) * X0000119;
		float X0000120 = diffuse_roughness * diffuse_roughness;
		float X0000121 = X0000120 / (X0000120 + 0.09);
		float X0000122 = 1.0 - 0.5 * (X0000120 / (X0000120 + 0.33));
		float X0000123 = (0.45 * X0000121) * (sin(X0000109) - X0000118);
		X0000119 = ((4.0 * X0000109) * X0000112) * (1.0 / (3.14159265358979323846 * 3.14159265358979323846));
		float X0000124 = ((0.125 * X0000121) * X0000119) * X0000119;
		float X0000125 = tan(X0000112);
		float X0000126 = tan((X0000109 + X0000112) * 0.5);
		if(X0000125 < -100.0)
			{
				X0000125 = -100.0;
			}
		if(X0000125 > 100.0)
			{
				X0000125 = 100.0;
			}
		if(X0000126 < -100.0)
			{
				X0000126 = -100.0;
			}
		if(X0000126 > 100.0)
			{
				X0000126 = 100.0;
			}
		float X0000127 = (X0000122 + (X0000123 * X0000117) * X0000125) + (X0000124 * (1.0 - abs(X0000117))) * X0000126;
		X0000119 = (2.0 * X0000112) * (1.0 / 3.14159265358979323846);
		float X0000128 = (0.17 * (X0000120 / (X0000120 + 0.13))) * (1.0 - (X0000117 * X0000119) * X0000119);
		float X0000129;
		Color X0000130 = float4(0.0,0.0,0.0,0.0);
		X0000129 = (X0000127 * X0000106.r + (X0000128 * X0000106.r) * X0000106.r) / 3.14159265358979323846;
		if(X0000129 > 1.0)
			{
				X0000130.r = 1.0;
			}
		else
			{
				X0000130.r = X0000129;
			}
		X0000129 = (X0000127 * X0000106.g + (X0000128 * X0000106.g) * X0000106.g) / 3.14159265358979323846;
		if(X0000129 > 1.0)
			{
				X0000130.g = 1.0;
			}
		else
			{
				X0000130.g = X0000129;
			}
		X0000129 = (X0000127 * X0000106.b + (X0000128 * X0000106.b) * X0000106.b) / 3.14159265358979323846;
		if(X0000129 > 1.0)
			{
				X0000130.b = 1.0;
			}
		else
			{
				X0000130.b = X0000129;
			}
		return X0000130;
	}


	float X0000006(in float X0000131)
	{
		return pow(2.0,X0000131 * 8.0);
	}


	float X0000007(in float3 X0000132,in float3 X0000133,in float3 X0000134,in float3 X0000135,in float3 X0000136,in float X0000137,in float X0000138)
	{
		float X0000139 = 0.0001;
		float X0000140 = dot(X0000133,X0000134);
		float X0000141 = -dot(X0000132,X0000134);
		if(X0000141 * X0000140 < X0000139)
			{
				return 0.0;
			}
		else
			{
				float X0000142 = X0000137 * X0000137;
				float X0000143 = X0000138 * X0000138;
				float3 X0000144 = X0000133 - X0000132;
				X0000144 = normalize(X0000144);
				float X0000145 = dot(X0000144,X0000134);
				X0000145 *= X0000145;
				if(X0000145 > 1.0)
					{
						X0000145 = 1.0;
					}
				float X0000146 = dot(X0000144,X0000135);
				X0000146 *= X0000146;
				float X0000147 = dot(X0000144,X0000136);
				X0000147 *= X0000147;
				if(X0000145 < X0000139 * (X0000146 * X0000142 + X0000147 * X0000143))
					{
						return 0.0;
					}
				else
					{
						float X0000148 = -(X0000146 * X0000142 + X0000147 * X0000143) / X0000145;
						return ((exp(X0000148) * X0000137) * X0000138) / ((sqrt(X0000141 * X0000140) * 4.0) * 3.14159265358979323846);
					}
			}
	}


	void X0000008(inout float X0000149,inout float X0000150,in float X0000151,in float X0000152)
	{
		float X0000153 = float(2) * X0000151 - float(1);
		float X0000154 = float(2) * X0000152 - float(1);
		if(X0000153 == 0.0 && X0000154 == 0.0)
			{
				X0000150 = 0.0;
				X0000149 = 0.0;
			}
		else
			{
				if(X0000153 > -X0000154)
					{
						if(X0000153 > X0000154)
							{
								X0000149 = X0000153;
								X0000150 = (3.14159265358979323846 / 4.0) * (1.0 + X0000154 / X0000153);
							}
						else
							{
								X0000149 = X0000154;
								X0000150 = (3.14159265358979323846 / 4.0) * (3.0 - X0000153 / X0000154);
							}
					}
				else
					{
						if(X0000153 < X0000154)
							{
								X0000149 = -X0000153;
								X0000150 = (3.14159265358979323846 / 4.0) * (5.0 + X0000154 / X0000153);
							}
						else
							{
								X0000149 = -X0000154;
								X0000150 = (3.14159265358979323846 / 4.0) * (7.0 - X0000153 / X0000154);
							}
					}
			}
	}


	void X0000009(inout float3 X0000155,in float3 X0000156,in float X0000157,in float X0000158,in float X0000159)
	{
		float3 X0000160;
		float3 X0000161;
		float3 X0000162 = transform_normal("internal","object",X0000156);
		if(abs(X0000162.x) < abs(X0000162.y))
			{
				X0000160.x = 0.0;
				X0000160.y = -(X0000162.z);
				X0000160.z = X0000162.y;
			}
		else
			{
				X0000160.x = X0000162.z;
				X0000160.y = 0.0;
				X0000160.z = -(X0000162.x);
			}
		X0000160 = transform_vector("object","internal",X0000160);
		if(length(X0000160) == 0.0)
			{
				if(abs(X0000156.x) < abs(X0000156.y))
					{
						X0000160.x = 0.0;
						X0000160.y = -(X0000156.z);
						X0000160.z = X0000156.y;
					}
				else
					{
						X0000160.x = X0000156.z;
						X0000160.y = 0.0;
						X0000160.z = -(X0000156.x);
					}
			}
		X0000160 = normalize(X0000160);
		X0000161 = cross(X0000156,X0000160);
		X0000155 = (X0000157 * X0000160 + X0000158 * X0000161) + X0000159 * X0000156;
	}


	void X0000010(inout float3 X0000163,in float3 X0000164,in float2 X0000165)
	{
		float X0000166 = 0.0;
		float X0000167 = 0.0;
		X0000008(X0000166,X0000167,X0000165.x,X0000165.y);
		float X0000168 = X0000166 * cos(X0000167);
		float X0000169 = X0000166 * sin(X0000167);
		float X0000170 = (1.0 - X0000168 * X0000168) - X0000169 * X0000169;
		float X0000171;
		if(X0000170 > 0.0)
			{
				X0000171 = sqrt(X0000170);
			}
		else
			{
				X0000171 = 0.0;
			}
		X0000009(X0000163,X0000164,X0000168,X0000169,X0000171);
	}


	void X0000011(inout float3 X0000172,in float3 X0000173,in float3 X0000174,in float X0000175,in float2 X0000176)
	{
		float X0000177 = 1000000000000000000000000000000000000.0;
		float X0000178 = 0.0;
		float3 X0000179 = reflect(X0000173,X0000174);
		if(X0000175 > float(0))
			{
				X0000178 = 1.0 / X0000175;
			}
		else
			{
				X0000178 = X0000177;
			}
		float X0000180 = (2.0 * 3.14159265358979323846) * X0000176.x;
		float X0000181 = atan(X0000178 * sqrt(-log(1.0 - X0000176.y)));
		float X0000182 = cos(X0000180) * sin(X0000181);
		float X0000183 = sin(X0000180) * sin(X0000181);
		float X0000184 = cos(X0000181);
		X0000009(X0000172,X0000179,X0000182,X0000183,X0000184);
	}


	void X0000012(inout float3 X0000185,in float3 X0000186,in float3 X0000187,in float3 X0000188,in float X0000189,in float X0000190,in float X0000191)
	{
		float X0000192 = dot(X0000187,X0000186);
		float3 X0000193 = X0000187 - X0000192 * X0000186;
		X0000193 = normalize(X0000193);
		float3 X0000194 = cross(X0000186,X0000193);
		X0000185 = (X0000189 * X0000193 + X0000190 * X0000194) + X0000191 * X0000186;
	}


	void X0000013(inout float3 X0000195,in float3 X0000196,in float3 X0000197,in float3 X0000198,in float X0000199,in float3 X0000200,in float3 X0000201,in float X0000202,in float X0000203,in float2 X0000204)
	{
		float3 X0000205 = float3(0.0,0.0,0.0);
		X0000205 = reflect(X0000196,X0000197);
		float X0000206 = atan2(X0000202 * cos((2.0 * 3.14159265358979323846) * X0000204.x),X0000203 * sin((2.0 * 3.14159265358979323846) * X0000204.x));
		float X0000207 = cos(X0000206) * X0000202;
		float X0000208 = sin(X0000206) * X0000203;
		float X0000209 = atan(sqrt(-log(1.0 - X0000204.y) / (X0000207 * X0000207 + X0000208 * X0000208)));
		float X0000210 = cos(X0000206) * sin(X0000209);
		float X0000211 = sin(X0000206) * sin(X0000209);
		float X0000212 = cos(X0000209);
		X0000012(X0000195,X0000205,X0000200,X0000201,X0000210,X0000211,X0000212);
		float X0000213 = dot(X0000195,X0000198);
		if(X0000213 < 0.0)
			{
				float3 X0000214 = X0000198;
				X0000214 *= -2.0 * X0000213;
				X0000195 = X0000195 + X0000214;
			}
	}


	float X0000014(inout int X0000215,in float X0000216)
	{
		if(is_ray_history_group("final_gather"))
			{
				X0000215 = 1;
			}
		if(X0000215 > 1)
			{
				X0000215 = int(float(X0000215) * (sqrt(X0000216) * importance));
			}
		if(X0000215 < 1)
			{
				X0000215 = 1;
			}
		return X0000216 * importance;
	}


	void X0000015(inout float3 X0000217,in float3 X0000218,in float3 X0000219,in float3 X0000220,in float X0000221,in float3 X0000222,in float3 X0000223,in float X0000224,in float X0000225,in float2 X0000226)
	{
		if(X0000224 >= 1.0)
			{
				X0000217 = reflect(X0000218,X0000219);
			}
		else
			{
				if(X0000224 <= 0.0)
					{
						X0000010(X0000217,X0000219,X0000226);
					}
				else
					{
						float X0000227 = X0000006(X0000224);
						float3 X0000228 = -X0000219;
						float X0000229 = -1.0;
						if(abs(X0000225 - 1.0) < 0.01)
							{
								X0000011(X0000217,X0000228,X0000219,X0000227,X0000226);
							}
						else
							{
								X0000013(X0000217,X0000228,X0000219,X0000220,X0000229,X0000222,X0000223,X0000227,X0000227 * X0000225,X0000226);
							}
						X0000217 += X0000219;
						X0000217 = normalize(X0000217);
						float3 X0000230 = X0000217;
						X0000229 = dot(X0000218,X0000230);
						float3 X0000231 = X0000218 - (X0000230 * X0000229) * 2.0;
						float X0000232 = dot(X0000220,X0000231);
						X0000217 = reflect(X0000218,X0000230);
						if(X0000232 < 0.0)
							{
								X0000232 = dot(X0000231,X0000220);
								X0000217 = X0000231 - (X0000220 * X0000232) * 2.0;
							}
					}
			}
	}


	void X0000016(inout Color X0000233,in bool X0000234,in float X0000235,in bool X0000236,in Color X0000237,in float3 X0000238,in float3 X0000239,in float3 X0000240,in float3 X0000241,in float X0000242,in int X0000243,in float X0000244,in float X0000245,in float3 X0000246,in float3 X0000247,in float X0000248,in float X0000249)
	{
		Color X0000250 = float4(0.0,0.0,0.0,0.0);
		float X0000251 = 0.0;
		float2 X0000252;
		int X0000253 = X0000243;
		float X0000254 = X0000244;
		float X0000255 = X0000245;
		{
			X0000253 = 1;
			X0000254 = 1.0;
			X0000255 = 1.0;
		}
		float X0000256 = X0000014(X0000253,X0000249);
		Sample_iterator X0000257 = Sample_iterator(X0000253);
		foreach(X0000257)
			{
				float X0000258 = X0000257.sample();
				if(X0000256 >= X0000248 * X0000258)
					{
						X0000251 += 1.0;
						X0000252 = X0000257.sample2();
						float3 X0000259 = float3(0.0,0.0,0.0);
						X0000015(X0000259,X0000239,X0000240,X0000241,X0000242,X0000246,X0000247,X0000254,X0000255,X0000252);
						Color X0000260 = Color(float(0));
						Ray X0000261 = Ray(float3(float(0)),float3(float(0)));
						Ray X0000262 = Ray(float3(float(0)),float3(float(0)));
						Ray X0000263 = Ray(float3(float(0)),float3(float(0)));
						X0000261 = Ray(X0000238,X0000259);
						Trace_options X0000264;
						X0000264.set_ray_type("reflect");
						if(X0000254 < 1.0)
							{
								X0000264.set_ray_dispersal_group("glossy");
							}
						else
							{
								X0000264.set_ray_dispersal_group("specular");
							}
						float X0000265 = 0.0;
						if(X0000234)
							{
								X0000265 = X0000235;
							}
						if(X0000265 > 0.0)
							{
								X0000264.set_far(X0000265);
							}
						X0000264.set_importance(X0000249 / float(X0000253));
						float X0000266 = 0.0;
						if(trace(X0000261,X0000262,X0000263,X0000264,"result",X0000260,"State::ray_length",X0000266))
							{
								Color X0000267 = float4(0.0,0.0,0.0,0.0);
								if(X0000234)
									{
										if(X0000236)
											{
												X0000267 = X0000237;
											}
										else
											{
												Trace_options X0000268;
												X0000268.set_ray_type("environment");
												Ray X0000269 = Ray(float3(float(0)),float3(float(0)));
												Ray X0000270 = Ray(float3(float(0)),float3(float(0)));
												trace(X0000261,X0000269,X0000270,X0000268,"result",X0000267);
											}
										if(X0000266 > 0.0)
											{
												if(X0000265 > 0.0 && X0000266 < X0000265)
													{
														float X0000271 = pow(1.0 - X0000266 / X0000265,2.0);
														float X0000272 = 1.0 - X0000271;
														X0000250 += X0000260 * X0000271 + X0000267 * X0000272;
													}
												else
													{
														X0000250 += X0000260;
													}
											}
										else
											{
												X0000250 += X0000267;
											}
									}
								else
									{
										X0000250 += X0000260;
									}
							}
						else
							{
								Trace_options X0000273;
								X0000273.set_ray_type("environment");
								Color X0000274 = Color(float(0));
								Ray X0000275 = Ray(float3(float(0)),float3(float(0)));
								Ray X0000276 = Ray(float3(float(0)),float3(float(0)));
								trace(X0000261,X0000275,X0000276,X0000273,"result",X0000274);
								X0000250 += X0000274;
							}
					}
			}
		if(X0000251 > 0.0)
			{
				X0000233 = X0000250 / X0000251;
			}
	}


	void X0000017(inout Color X0000277,in bool X0000278,in float X0000279,in bool X0000280,in Color X0000281,in float3 X0000282,in float3 X0000283,in float3 X0000284,in float3 X0000285,in float X0000286,in float X0000287,in bool X0000288,in int X0000289,in float X0000290,in float X0000291,in float3 X0000292,in float3 X0000293,in float X0000294,in float X0000295)
	{
		if(X0000278)
			{
				warning("TODO: shd_refl_falloff_on");
			}
		if(X0000287 > 0.0)
			{
				if(!X0000288)
					{
						X0000016(X0000277,X0000278,X0000279,X0000280,X0000281,X0000282,X0000283,X0000284,X0000285,X0000286,X0000289,X0000290,X0000291,X0000292,X0000293,X0000294,X0000295);
					}
			}
	}


	void X0000018(inout Color X0000296,in bool X0000297,in float X0000298,in bool X0000299,in Color X0000300,in float3 X0000301,in float3 X0000302,in float3 X0000303,in float3 X0000304,in float X0000305,in bool X0000306,in Color X0000307,in float X0000308,in bool X0000309,in int X0000310,in float X0000311,in float X0000312,in float3 X0000313,in float3 X0000314,in float X0000315)
	{
		if(X0000306)
			{
			}
		else
			{
				X0000017(X0000296,X0000297,X0000298,X0000299,X0000300,X0000301,X0000302,X0000303,X0000304,X0000305,X0000308,X0000309,X0000310,X0000311,X0000312,X0000313,X0000314,X0000315,X0000307.a);
			}
		X0000296.r *= X0000307.r;
		X0000296.g *= X0000307.g;
		X0000296.b *= X0000307.b;
	}


	bool X0000019(inout float3 X0000316,in float X0000317,in float X0000318,in float3 X0000319,in float3 X0000320,in float3 X0000321,in float X0000322)
	{
		if(X0000318 <= 0.0)
			{
				return false;
			}
		else
			{
				float X0000323 = X0000317 / X0000318;
				float X0000324 = 1.0 - (X0000323 * X0000323) * (1.0 - X0000322 * X0000322);
				if(X0000324 < 0.0)
					{
						return false;
					}
				else
					{
						if(X0000324 == 0.0)
							{
								X0000316 = X0000319;
								return true;
							}
						else
							{
								X0000324 = -X0000323 * X0000322 - sqrt(X0000324);
								X0000316 = X0000324 * X0000320 + X0000323 * X0000319;
								if(dot(X0000316,X0000321) > 0.0)
									{
										X0000316 = X0000319;
										return true;
									}
								else
									{
										X0000316 = normalize(X0000316);
										return true;
									}
							}
					}
			}
	}


	void X0000020(inout float3 X0000325,in float3 X0000326,in float2 X0000327)
	{
		X0000010(X0000325,X0000326,X0000327);
		X0000325 = -X0000325;
	}


	bool X0000021(inout float3 X0000328,in float X0000329,in float X0000330,in float3 X0000331,in float3 X0000332,in float3 X0000333,in float X0000334,in float X0000335,in float2 X0000336)
	{
		float3 X0000337 = float3(0.0,0.0,0.0);
		float X0000338 = 1000000000000000000000000000000000000.0;
		float X0000339;
		if(!X0000019(X0000337,X0000329,X0000330,X0000331,X0000332,X0000333,X0000334))
			{
				return false;
			}
		if(X0000335 > 0.0)
			{
				X0000339 = 1.0 / X0000335;
			}
		else
			{
				X0000339 = X0000338;
			}
		float X0000340 = (2.0 * 3.14159265358979323846) * X0000336.x;
		float X0000341 = atan(X0000339 * sqrt(-log(1.0 - X0000336.y)));
		float X0000342 = cos(X0000340) * sin(X0000341);
		float X0000343 = sin(X0000340) * sin(X0000341);
		float X0000344 = cos(X0000341);
		X0000009(X0000328,X0000337,X0000342,X0000343,X0000344);
		return dot(X0000328,X0000333) < 0.0;
	}


	bool X0000022(inout float3 X0000345,in float X0000346,in float X0000347,in float3 X0000348,in float3 X0000349,in float3 X0000350,in float X0000351,in float3 X0000352,in float3 X0000353,in float X0000354,in float X0000355,in float2 X0000356)
	{
		float3 X0000357 = float3(0.0,0.0,0.0);
		if(!X0000019(X0000357,X0000346,X0000347,X0000348,X0000349,X0000350,X0000351))
			{
				return false;
			}
		float X0000358 = atan2(X0000354 * cos((2.0 * 3.14159265358979323846) * X0000356.x),X0000355 * sin((2.0 * 3.14159265358979323846) * X0000356.x));
		float X0000359 = cos(X0000358) * X0000354;
		float X0000360 = sin(X0000358) * X0000355;
		float X0000361 = atan(sqrt(-log(1.0 - X0000356.x) / (X0000359 * X0000359 + X0000360 * X0000360)));
		float X0000362 = cos(X0000358) * sin(X0000361);
		float X0000363 = sin(X0000358) * sin(X0000361);
		float X0000364 = cos(X0000361);
		X0000012(X0000345,X0000357,X0000352,X0000353,X0000362,X0000363,X0000364);
		return dot(X0000345,X0000350) < 0.0;
	}


	bool X0000023(inout float3 X0000365,in float X0000366,in float X0000367,in float3 X0000368,in float3 X0000369,in float3 X0000370,in float X0000371)
	{
		return X0000019(X0000365,X0000366,X0000367,X0000368,X0000369,X0000370,X0000371);
	}


	bool X0000024(inout float3 X0000372,in bool X0000373,in float3 X0000374,in float3 X0000375,in float3 X0000376,in float X0000377,in bool X0000378,in float X0000379,in float3 X0000380,in float3 X0000381,in float X0000382,in float X0000383,in float2 X0000384)
	{
		float X0000385 = 1.0;
		float X0000386 = 1.0;
		if(!X0000378)
			{
				if(X0000373)
					{
						X0000385 = X0000379;
					}
				else
					{
						X0000386 = X0000379;
					}
			}
		if(X0000382 >= 1.0)
			{
				return X0000023(X0000372,X0000385,X0000386,X0000374,X0000375,X0000376,X0000377);
			}
		if(X0000382 <= 0.0)
			{
				X0000020(X0000372,X0000375,X0000384);
				return true;
			}
		float X0000387 = X0000006(X0000382);
		if(abs(X0000383 - 1.0) < 0.01)
			{
				return X0000021(X0000372,X0000385,X0000386,X0000374,X0000375,X0000376,X0000377,X0000387,X0000384);
			}
		return X0000022(X0000372,X0000385,X0000386,X0000374,X0000375,X0000376,X0000377,X0000380,X0000381,X0000387,X0000387 * X0000383,X0000384);
	}


	void X0000025(inout Color X0000388,in bool X0000389,in float3 X0000390,in float3 X0000391,in float3 X0000392,in float3 X0000393,in float X0000394,in int X0000395,in float X0000396,in float X0000397,in bool X0000398,in float X0000399,in float3 X0000400,in float3 X0000401,in float X0000402,in float X0000403)
	{
		Color X0000404 = float4(0.0,0.0,0.0,0.0);
		float X0000405 = 0.0;
		float2 X0000406;
		int X0000407 = X0000395;
		float X0000408 = X0000396;
		float X0000409 = X0000397;
		if(X0000407 <= 0 || X0000408 >= 1.0)
			{
				X0000407 = 1;
				X0000408 = 1.0;
				X0000409 = 1.0;
			}
		float X0000410 = X0000014(X0000407,X0000403);
		Sample_iterator X0000411 = Sample_iterator(X0000407);
		foreach(X0000411)
			{
				float X0000412 = X0000411.sample();
				if(X0000410 >= X0000402 * X0000412)
					{
						X0000405 += 1.0;
						X0000406 = X0000411.sample2();
						float3 X0000413 = float3(0.0,0.0,0.0);
						bool X0000414 = X0000024(X0000413,X0000389,X0000391,X0000392,X0000393,X0000394,X0000398,X0000399,X0000400,X0000401,X0000408,X0000409,X0000406);
						if(!X0000414)
							{
								X0000015(X0000413,X0000391,X0000392,X0000393,X0000394,X0000400,X0000401,X0000408,X0000409,X0000406);
								Color X0000415 = Color(float(0));
								Ray X0000416 = Ray(float3(float(0)),float3(float(0)));
								Ray X0000417 = Ray(float3(float(0)),float3(float(0)));
								Ray X0000418 = Ray(float3(float(0)),float3(float(0)));
								X0000416 = Ray(X0000390,X0000413);
								Trace_options X0000419;
								X0000419.set_ray_type("reflect");
								if(X0000408 < 1.0)
									{
										X0000419.set_ray_dispersal_group("glossy");
									}
								else
									{
										X0000419.set_ray_dispersal_group("specular");
									}
								X0000419.set_importance(X0000403 / float(X0000407));
								if(trace(X0000416,X0000417,X0000418,X0000419,"result",X0000415))
									{
										X0000404.r += X0000415.r;
										X0000404.g += X0000415.g;
										X0000404.b += X0000415.b;
										X0000404.a += 1.0;
									}
							}
						else
							{
								Color X0000420 = Color(float(0));
								Ray X0000421 = Ray(float3(float(0)),float3(float(0)));
								Ray X0000422 = Ray(float3(float(0)),float3(float(0)));
								Ray X0000423 = Ray(float3(float(0)),float3(float(0)));
								X0000421 = Ray(X0000390,X0000413);
								Trace_options X0000424;
								X0000424.set_ray_type("refract");
								X0000424.set_ray_dispersal_group("glossy");
								X0000424.set_importance(X0000403 / float(X0000407));
								if(trace(X0000421,X0000422,X0000423,X0000424,"result",X0000420))
									{
										X0000404 += X0000420;
									}
								else
									{
										Trace_options X0000425;
										X0000425.set_ray_type("environment");
										Color X0000426 = Color(float(0));
										Ray X0000427 = Ray(float3(float(0)),float3(float(0)));
										Ray X0000428 = Ray(float3(float(0)),float3(float(0)));
										trace(X0000421,X0000427,X0000428,X0000425,"result",X0000426);
										X0000404 += X0000426;
									}
							}
					}
			}
		if(X0000405 > 0.0)
			{
				X0000388 = X0000404 / X0000405;
			}
	}


	void X0000026(inout Color X0000429,in bool X0000430,in float3 X0000431,in float3 X0000432,in float3 X0000433,in float3 X0000434,in float X0000435,in bool X0000436,in Color X0000437,in int X0000438,in float X0000439,in float X0000440,in bool X0000441,in float X0000442,in float3 X0000443,in float3 X0000444,in float X0000445)
	{
		X0000429 = float4(float(0));
	}


	void main()
	{
		result = float4(0.0,0.0,0.0,0.0);
		Color X0000446 = float4(0.0,0.0,0.0,0.0);
		Color X0000447 = float4(0.0,0.0,0.0,0.0);
		Color X0000448 = float4(0.0,0.0,0.0,0.0);
		Color X0000449 = float4(0.0,0.0,0.0,0.0);
		Color X0000450 = float4(0.0,0.0,0.0,0.0);
		Color X0000451 = float4(0.0,0.0,0.0,0.0);
		Color X0000452 = float4(0.0,0.0,0.0,0.0);
		float X0000453 = cutout_opacity;
		if(backface_cull && backside)
			{
				X0000453 = 0.0;
			}
		if(X0000453 < 0.01)
			{
				Ray X0000454 = Ray(float3(float(0)),float3(float(0)));
				Ray X0000455 = Ray(float3(float(0)),float3(float(0)));
				Ray X0000456 = Ray(float3(float(0)),float3(float(0)));
				Trace_options X0000457;
				X0000454 = Ray(position,direction);
				X0000457.set_ray_type("transparent");
				if(trace(X0000454,X0000455,X0000456,X0000457,"result",X0000452))
					{
						result += X0000452;
					}
				else
					{
						Trace_options X0000458;
						X0000458.set_ray_type("environment");
						Color X0000459 = Color(float(0));
						Ray X0000460 = Ray(float3(float(0)),float3(float(0)));
						Ray X0000461 = Ray(float3(float(0)),float3(float(0)));
						trace(X0000454,X0000460,X0000461,X0000458,"result",X0000459);
						result += X0000459;
					}
				result.a *= X0000453;
			}
		else
			{
				float3 X0000465 = float3(0.0,0.0,0.0);
				float3 X0000466 = float3(0.0,0.0,0.0);
				X0000001(X0000465,X0000466,normal);
				bool X0000467 = false;
				bool X0000468 = false;
				float X0000469 = 0.0;
				Color X0000470 = float4(0.0,0.0,0.0,0.0);
				Color X0000471 = float4(0.0,0.0,0.0,0.0);
				Color X0000472 = float4(0.0,0.0,0.0,0.0);
				float X0000473 = 0.0;
				bool X0000474 = false;
				bool X0000475 = false;
				float X0000476 = 0.0;
				Color X0000477 = float4(0.0,0.0,0.0,0.0);
				bool X0000478 = false;
				bool X0000479 = false;
				float X0000480 = 0.0;
				int X0000481 = 0;
				float X0000482 = 0.0;
				float X0000483 = 0.0;
				float X0000484 = 0.0;
				int X0000485 = 0;
				float X0000486 = 0.0;
				float X0000487 = 0.0;
				int X0000488 = 0;
				float X0000489 = 0.0;
				bool X0000490 = false;
				float X0000491 = 0.0;
				bool X0000492 = false;
				Color X0000493 = float4(0.0,0.0,0.0,0.0);
				bool X0000494 = false;
				bool X0000495 = false;
				float X0000496 = 0.0;
				X0000004(X0000467,X0000468,X0000469,X0000470,X0000471,X0000472,X0000473,X0000474,X0000475,X0000476,X0000477,X0000478,X0000479,X0000480,X0000481,X0000482,X0000483,X0000484,X0000485,X0000486,X0000487,X0000488,X0000489,X0000490,X0000491,X0000492,X0000493,X0000494,X0000495,X0000496,direction,normal,dot_nd,backside);
				Color X0000497 = float4(1.0,1.0,1.0,1.0);
				if((X0000470.a > 0.0 || X0000471.a > 0.0) || X0000477.a > 0.0)
					{
						Light_iterator X0000498;
						foreach(X0000498)
							{
								float X0000499 = X0000498.dot_nl;
								if(X0000499 >= 0.0)
									{
										float X0000500 = X0000499;
										X0000500 *= smoothstep(0.0,0.25,X0000499);
										float X0000501 = saturate(X0000500);
										if(X0000467)
											{
												X0000501 = X0000498.dot_nl;
											}
										if(X0000501 > 0.0)
											{
												if(diffuse_roughness <= 0.0)
													{
														X0000501 /= 3.14159265358979323846;
														X0000447 += (X0000501 * X0000470) * X0000498.contribution;
													}
												else
													{
														Color X0000502 = X0000005(X0000498,X0000470,direction,normal);
														X0000447 += (X0000501 * X0000502) * X0000498.contribution;
													}
											}
										float X0000503 = 0.0;
										float X0000504 = X0000006(X0000484);
										float X0000505 = anisotropy * X0000504;
										if(X0000504 >= 80.0)
											X0000504 = 80.0 + sqrt(X0000504 - 80.0);
										if(X0000505 >= 80.0)
											X0000505 = 80.0 + sqrt(X0000505 - 80.0);
										X0000503 = (X0000007(direction,X0000498.direction,normal,X0000465,X0000466,X0000504,X0000505) * 0.5 + X0000007(direction,X0000498.direction,normal,X0000465,X0000466,X0000504 / 2.0,X0000505 / 2.0) * 1.0) + X0000007(direction,X0000498.direction,normal,X0000465,X0000466,X0000504 / 4.0,X0000505 / 4.0) * 1.5;
										X0000503 *= (X0000500 * X0000483) / 3.14159265358979323846;
										X0000503 *= sqrt(importance);
										X0000448 += (X0000498.contribution * X0000471) * X0000503;
									}
							}
						Irradiance_options X0000506 = Irradiance_options();
						float X0000507 = dot(X0000470.rgb,float3(1. / float(3)));
						X0000506.set_importance(X0000507);
						X0000447 += (X0000470 * irradiance(X0000506)) / 3.14159265358979323846;
						normal = -normal;
						Light_iterator X0000508;
						foreach(X0000508)
							{
								if(X0000477.a > 0.0)
									{
										float X0000509 = X0000508.dot_nl;
										if(X0000509 > 0.0)
											{
												Color X0000510 = Color(X0000508.contribution);
												X0000449.r += (X0000510.r * X0000509) * X0000477.r;
												X0000449.g += (X0000510.g * X0000509) * X0000477.g;
												X0000449.b += (X0000510.b * X0000509) * X0000477.b;
											}
									}
							}
						normal = -normal;
					}
				if(X0000471.a > 0.0)
					{
						X0000018(X0000450,refl_falloff_on,refl_falloff_dist,refl_falloff_color_on,refl_falloff_color,position,direction,normal,geometry_normal,dot_nd,X0000468,X0000471,X0000476,X0000494,X0000485,X0000484,X0000469,X0000465,X0000466,X0000486);
					}
				if(X0000472.a > 0.0)
					{
						X0000026(X0000451,backside,position,direction,normal,geometry_normal,dot_nd,X0000495,X0000472,X0000488,X0000487,X0000469,X0000474,X0000473,X0000465,X0000466,X0000489);
					}
				result = ((((X0000446 + X0000447) + X0000448) + X0000449) + X0000450) + X0000451;
				if(true)
					{
						result.a = (1.0 - X0000472.a) + X0000451.a * X0000472.a;
					}
				else
					{
						result.a = 1.0;
					}
				if(additional_color.r > 0.0)
					result.r += additional_color.r;
				if(additional_color.g > 0.0)
					result.g += additional_color.g;
				if(additional_color.b > 0.0)
					result.b += additional_color.b;
				result.r *= X0000497.r;
				result.g *= X0000497.g;
				result.b *= X0000497.b;
				result.a = result.a * X0000497.a + (1.0 - X0000497.a);
				result.r *= X0000453;
				result.g *= X0000453;
				result.b *= X0000453;
				result.a *= X0000453;
			}
	}

};

/*** end of file ***/
