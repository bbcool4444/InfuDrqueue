/******************************************************************************
 * Copyright 1986-2009 by mental images GmbH, Fasanenstr. 81, D-10623 Berlin,
 * Germany. All rights reserved.
 *****************************************************************************/

// $Revision$
#define mi_MAX_EVAL_COLOR 0
#define mi_MAX_EVAL_MONO 1
#define mi_MAX_EVAL_NORMAL 2

#define TANGENTUV_SPACE		0
#define TANGENTLOCAL_SPACE	4
#define SCREEN_SPACE		2
#define WORLDXYZ_SPACE		3
#define LOCALXYZ_SPACE		1




shader max_GNormal {
 input:
    float mult_spin = 1.0{
    };
    float bump_spin = 1.0{
    };
    const bool flipred = 0.0{
    };
    const bool flipgreen = 0.0{
    };
    const bool swap_rg = 0.0{
    };
    const bool map1on = true{
    };
    Shader normalMapShader = Shader(){
    };
    const bool map2on = false{
    };
    Shader bumpMapShader = Shader(){
    };
    const int method = 0{
    };
    Color grey = Color(0.7, 0.7, 0.7, 1.0){
    };
    int normalMap_MapChannel = 0{
    };
    int gbufID = 0{
    };
    
    // Additional inputs
    const bool evalNormal = true{
    }; // Bump mode
    bool orthogonalizeTangentBitangentPerPixel = false{
    }; // Orthogonalize tangent and bitangent on each pixel, otherwise use the interpolated values
 output:
  Color result;

  void Reorder(inout Color s, in bool flip_r, in bool flip_g, in bool swap_rg)
  {
      if(flip_r)
      {
          s.r = 1.0 - s.r;
      }
      if(flip_g)
      {
          s.g = 1.0 - s.g;
      }

      if(swap_rg)
      {
          s.rg = s.gr;
      }
      
  }

   void main() {
    result = Color(0.0, 0.0, 0.0, 0.0);

    Color shader_result = Color(0.0, 0.0, 0.0, 0.0);

    
      if(false == evalNormal)
      {
        {
            if(true == map1on && 
                mult_spin != 0.0)
            {
               if(normalMapShader.call("input", "evalNormal", false,
                                       "output", "result", result))
               {
                    Reorder(result, 
                            flipred, 
                            flipgreen, 
                            swap_rg);
               }
            }
        }
 /*       break;
    case mi_MAX_EVAL_MONO:
        {
            if(true == map1on && 
                mult_spin != 0.0)
            {
               if(normalMapShader.call("input", "evalNormal", false,
                                       "output", "result", result))
               {
                    Reorder(result, 
                            flipred, 
                            flipgreen, 
                            swap_rg);
                    result.rgb  = (result.r + result.g + result.b)/3.0;
               }
            }
        }
        break;
    default:
    case mi_MAX_EVAL_NORMAL:*/
      }
      else
        {
            
            float3 perturb = float3(0.0, 0.0, 0.0);
            float3 frontNormal = float3(0.0, 0.0, 0.0);
            float3 p = float3(0.0, 0.0, 0.0);
            Color s = Color(0.0, 0.0, 0.0, 0.0);

            if(false == map1on ||
                mult_spin == 0.0)
            {

                if(true == map2on)
                {
                    if(true == bumpMapShader.call("input", "evalNormal", true,
                                                   "output", "result", shader_result))
                    {

                        if(bump_spin != 1.0)
                        {
                            shader_result.rgb *= bump_spin;
                        }
                        result.rgb = shader_result.rgb;
                    }
                }

            }
            else
            {
                float3 shader_normal_result = float3(0);
                if(!normalMapShader.call("input", "evalNormal", false,
                                         "output", "result", shader_result))
                {
                    shader_result = Color(0, 0, 0, 1);
                }

                /* Step 4) Reorder and normalize the color into a vector */
                Reorder(shader_result, 
                        flipred, 
                        flipgreen, 
                        swap_rg);
                p = 2.0 * (shader_result.rgb - 0.5);

                /* Step 5) Calculate the front surface normal. */
                frontNormal = normal;

                if(backside)
                    frontNormal = -frontNormal;

                /* Flip green value because by default green means -y in the normal map generated by 3ds Max. */
                p.y = -p.y;

                /* Step 6) Branch depending on the normal map method */
                switch(method) 
                {
                case TANGENTUV_SPACE:
                {
                         /* Get the tangent basis vectors for the current point */
                        float3 tangent = normalize(texture_du[0]);
                        float3 bitangent = normalize(texture_dv[0]);

                        if (orthogonalizeTangentBitangentPerPixel)
                        {
                                float3 bt = normalize(cross(frontNormal, tangent));
                                tangent = normalize(cross(bt, frontNormal));
                                /* Bitangent need to be flipped if the map face is flipped. We don't have map face handedness in shader so make */
                                /* the calculated bitangent point in the same direction as the interpolated bitangent which has considered the flip. */
                                bitangent = sign(dot(bt, bitangent)) * bt;
                        }

                        p = normalize(p.x * tangent + p.y * bitangent + p.z * frontNormal);
                }
                break;
                case SCREEN_SPACE:
                {
                    p = transform_vector("camera", "internal", p);
                }
                break;
                case WORLDXYZ_SPACE:
                {
                    p = transform_vector("world", "internal", p);
                }
                break;
                case LOCALXYZ_SPACE:
                {
                    p = transform_vector("object", "internal", p);
                }
                break;
                default:
                    p = frontNormal;
                break;
                }//end switch method
            
                /* Step 7) Calculate the perturbation */
                perturb = p - frontNormal;
                /* Step 8) Standard exit case, mult_spin is 1.0 and no additional
                 bump is supplied */

                if(mult_spin == 1.0 && 
                    map2on == false)
                {
                    result.rgb = perturb;
                
                }
                else
                {

                    /* Step 9) Complex exit case, the bump mult_spin is not 1.0, or an
                     additional bump is supplied */

                    if(mult_spin != 1.0f )
                    {
                        perturb *= bump_spin;
                    }

                    if(map2on == true)
                    {
                        float3 additionalPerturb = float3(0, 0, 0);


                        Color tempColor = Color(0, 0, 0, 0);
                        if(bumpMapShader.call("input", "evalNormal", true,
                                              "output", "result", tempColor))
                        {
                            additionalPerturb = tempColor.rgb;
                        }
                      
                        if( bump_spin!=1.0 ) 
                        {
                            additionalPerturb *= bump_spin;
                        }
                        perturb += additionalPerturb;
                    }
                   
                    result.rgb = perturb;
                }//end else
            }
            
        }//case mi_MAX_EVAL_NORMAL
   // }//switch mode

  } // main
};
