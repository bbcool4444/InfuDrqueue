/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 * code generator gen_msl, build 126420.5925.3501
 *                                                                            *
 * Portions Copyright (c) 1986-2010 mental images GmbH, Berlin, Germany.      *
 ******************************************************************************/

// Option settings:


void adskRotate(inout float4x3 X0000000,in float X0000001)
{
    float X0000002 = sin(X0000001);
    float X0000003 = cos(X0000001);
    float X0000004;
    float3 X0000005;
    int X0000006 = 0;
    for(X0000006 = 3; X0000006 >= 0; X0000006--) {
        X0000005 = X0000000[X0000006];
        X0000004 = X0000005[0] * X0000003 - X0000005[1] * X0000002;
        X0000005[1] = X0000005[0] * X0000002 + X0000005[1] * X0000003;
        X0000005[0] = X0000004;
        (X0000000[X0000006])[0] = X0000005[0];
        (X0000000[X0000006])[1] = X0000005[1];
    }
}

float2 adskVectorTransform(in float2 X0000007,in float4x3 X0000008,in bool X0000009)
{
    float2 X0000010 = float2(0.0f,0.0f);
    if(!X0000009) {
        X0000010.x = X0000007.x * (X0000008[0])[0] + X0000007.y * (X0000008[1])[0];
        X0000010.y = X0000007.x * (X0000008[0])[1] + X0000007.y * (X0000008[1])[1];
    } else {
        X0000010.x = abs(X0000007.x * (X0000008[0])[0]) + abs(X0000007.y * (X0000008[1])[0]);
        X0000010.y = abs(X0000007.x * (X0000008[0])[1]) + abs(X0000007.y * (X0000008[1])[1]);
    }
    return X0000010;
}

void adskTransformUV(in bool X0000011,in float X0000012,in float X0000013,in float X0000014,in float X0000015,in bool X0000016,in float4x3 X0000017,inout float2 X0000018,inout float2 X0000019)
{
    float X0000020 = 0.5f;
    if((X0000011 && X0000014 != 0.0f) && X0000015 != 0.0f) {
        X0000020 = 0.0f;
        X0000014 = 1.0f / X0000014;
        X0000015 = 1.0f / X0000015;
    }
    X0000018.x -= X0000012 + X0000020;
    X0000018.y -= X0000013 + X0000020;
    if(X0000016) {
        X0000018 = adskVectorTransform(X0000018,X0000017,false);
        X0000019 = adskVectorTransform(X0000019,X0000017,true);
    }
    if(X0000014 != 1.0f) {
        X0000018.x *= X0000014;
        X0000019.x *= X0000014;
        if(X0000019.x < 0.0f)
            X0000019.x = -X0000019.x;
    }
    if(X0000015 != 1.0f) {
        X0000018.y *= X0000015;
        X0000019.y *= X0000015;
        if(X0000019.y < 0.0f)
            X0000019.y = -X0000019.y;
    }
    X0000018.x += X0000020;
    X0000018.y += X0000020;
}

shader adsk_Utility_MSL_UVGenerator_Simple {

output:

    Color result;

input:

    int uv_space = 0
            {
                literal();
            };
    float u_scale = 1.0f;
    float v_scale = 1.0f;
    float u_offset = 0.0f;
    float v_offset = 0.0f;
    float angle = 0.0f;

member:


    void main()
    {
        result = float4(0.0f,0.0f,0.0f,0.0f);
        float2 X0000021 = (state::texture_coordinate[0]).xy;
        float2 X0000022 = float2(0.0f,0.0f);
        X0000022.x = X0000021.x * u_scale - u_offset;
        X0000022.y = X0000021.y * v_scale - v_offset;
        float X0000023 = sin(angle);
        float X0000024 = cos(angle);
        result.r = X0000022.x * X0000024 - X0000022.y * X0000023;
        result.g = X0000022.x * X0000023 - X0000022.y * X0000024;
        float2 X0000025 = float2(0.0f,0.0f);
        X0000025 = (abs(ddx((state::texture_coordinate[0])).xyz) + abs(ddy((state::texture_coordinate[0])).xyz)).xy;
        if(X0000025.x == 0.0f && X0000025.y == 0.0f)
            X0000025 = float2(0.002f,0.002f);
        X0000025.x *= u_scale;
        X0000025.y *= v_scale;
        if(X0000025.x < 0.0f)
            X0000025.x = -X0000025.x;
        if(X0000025.y < 0.0f)
            X0000025.y = -X0000025.y;
        result.b = abs(X0000025.x * X0000024 - X0000025.y * X0000023);
        result.a = abs(X0000025.x * X0000023 - X0000025.y * X0000024);
    }
};


shader adsk_Utility_MSL_UVGenerator {

output:

    Color result;

input:

    float u_scale = 1.0f;
    float v_scale = 1.0f;
    float u_offset = 0.0f;
    float v_offset = 0.0f;
    bool u_wrap = true;
    bool v_wrap = true;
    float angle = 0.0f;
    float blur = 1.0f;
    float blur_offset = 0.0f;
    int map_channel = 0
            {
                literal();
            };
    bool realworldmapsize = true;

member:


    void main()
    {
        result = float4(0.0f,0.0f,0.0f,0.0f);
        bool X0000026 = false;
        float X0000027 = angle;
        float X0000028 = cos(X0000027);
        float X0000029 = sin(X0000027);
        float4x3 X0000030 = float4x3(1.0f,0.0f,0.0f,0.0f,1.0f,0.0f,0.0f,0.0f,1.0f,0.0f,0.0f,0.0f);
        if(X0000027 != 0.0f) {
            adskRotate(X0000030,X0000027);
            X0000026 = true;
        } else
            X0000026 = false;
        float2 X0000031 = float2((state::texture_coordinate[0]).x,(state::texture_coordinate[0]).y);
        float2 X0000032 = float2(0.0f,0.0f);
        X0000032 = (abs(ddx((state::texture_coordinate[0])).xyz) + abs(ddy((state::texture_coordinate[0])).xyz)).xy;
        if(X0000032.x == 0.0f && X0000032.y == 0.0f)
            X0000032 = float2(0.002f,0.002f);
        adskTransformUV(realworldmapsize,u_offset,v_offset,u_scale,v_scale,X0000026,X0000030,X0000031,X0000032);
        X0000032.x = blur_offset + blur * X0000032.x;
        X0000032.y = blur_offset + blur * X0000032.y;
        if(!u_wrap && (X0000031.x < 0.0f || X0000031.x > 1.0f) || !v_wrap && (X0000031.y < 0.0f || X0000031.y > 1.0f)) {
            result = float4(0.0f,0.0f,0.0f,0.0f);
            return;
        }
        result.rg = X0000031;
        result.ba = X0000032;
    }
};
