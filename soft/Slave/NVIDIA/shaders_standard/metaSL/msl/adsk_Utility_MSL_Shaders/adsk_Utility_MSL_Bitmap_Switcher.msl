/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 * code generator gen_msl, build 126420.5925.3501
 *                                                                            *
 * Portions Copyright (c) 1986-2010 mental images GmbH, Berlin, Germany.      *
 ******************************************************************************/

// Option settings:


shader adsk_Utility_MSL_Bitmap_Switcher {

output:

    Color result;
    float3 result_bump;

input:

    texture2D map_1 = "brickwall.dds";
    texture2D map_2 = "brickwall.dds";
    texture2D map_3 = "brickwall.dds";
    texture2D map_4 = "brickwall.dds";
    texture2D map_5 = "brickwall.dds";
    int map_switcher = 0;
    Color uv_coords;
    float bump_amount = 0.0f;

member:


    float X0000000(in Color X0000002)
    {
        float X0000003 = ((X0000002.r + X0000002.g) + X0000002.b) * 0.333333333f;
        return X0000003;
    }

    Color X0000001(in int X0000004,in float2 X0000005)
    {
        switch(X0000004) {
        case 0:
            return tex2d(map_1,X0000005);
        case 1:
            return tex2d(map_2,X0000005);
        case 2:
            return tex2d(map_3,X0000005);
        case 3:
            return tex2d(map_4,X0000005);
        case 4:
            return tex2d(map_5,X0000005);
        }
        return tex2d(map_1,X0000005);
    }

    void main()
    {
        result = float4(0.0f,0.0f,0.0f,0.0f);
        result_bump = float3(0.0f,0.0f,0.0f);
        float X0000006 = uv_coords.r;
        float X0000007 = uv_coords.g;
        float2 X0000008 = float2(uv_coords.b,uv_coords.a);
        float X0000009 = X0000008.x + X0000008.y;
        bool X0000010 = true;
        if(X0000010 && X0000009 < 0.05f) {
            Color X0000011 = float4(0.0f,0.0f,0.0f,0.0f);
            float X0000012 = 0.0f;
            float3 X0000013 = float3(0.0f,0.0f,0.0f);
            float X0000014 = 0.05f;
            X0000014 = X0000009 < 0.001f ? 0.01f : X0000008.x + X0000008.y;
            X0000011 = X0000001(map_switcher,float2(X0000006,X0000007));
            X0000012 = X0000000(X0000011);
            X0000012 = X0000012 * X0000014 - X0000014 * 0.5f;
            X0000013 = state::tangent_space[0] * state::direction;
            X0000006 -= X0000013.x * X0000012;
            X0000007 -= X0000013.y * X0000012;
        }
        result = X0000001(map_switcher,float2(X0000006,X0000007));
        result_bump = state::normal;
        if(bump_amount != 0.0f) {
            float X0000015 = X0000000(result);
            if(X0000008.x == 0.0f && X0000008.y == 0.0f)
                X0000008 = (abs(ddx((state::texture_coordinate[0])).xyz) + abs(ddy((state::texture_coordinate[0])).xyz)).xy;
            float3 X0000016 = state::texture_tangent_u[0];
            float3 X0000017 = state::texture_tangent_v[0];
            float3 X0000018 = float3(0.0f,0.0f,0.0f);
            float3 X0000019 = float3(0.0f,0.0f,0.0f);
            X0000018.x = X0000006;
            X0000018.y = X0000007;
            X0000018.z = 0.0f;
            Color X0000020;
            if(X0000008.x > 0.0f) {
                X0000020 = X0000001(map_switcher,float2(X0000006 + X0000008.x,X0000007));
                float X0000021 = X0000000(X0000020);
                X0000018.x = -(X0000021 - X0000015) / X0000008.x;
            } else
                X0000018.x = 0.0f;
            if(X0000008.y > 0.0f) {
                X0000020 = X0000001(map_switcher,float2(X0000006,X0000007 + X0000008.y));
                float X0000022 = X0000000(X0000020);
                X0000018.y = -(X0000022 - X0000015) / X0000008.y;
            } else
                X0000018.y = 0.0f;
            X0000018 *= 0.012f;
            float3 X0000023 = float3(0.0f,0.0f,0.0f);
            X0000023.x = X0000018.x * X0000016.x + X0000018.y * X0000017.x;
            X0000023.y = X0000018.x * X0000016.y + X0000018.y * X0000017.y;
            X0000023.z = X0000018.x * X0000016.z + X0000018.y * X0000017.z;
            X0000023 *= bump_amount;
            X0000023 += state::normal;
            X0000023 = normalize(X0000023);
            result_bump = X0000023;
        }
    }
};
