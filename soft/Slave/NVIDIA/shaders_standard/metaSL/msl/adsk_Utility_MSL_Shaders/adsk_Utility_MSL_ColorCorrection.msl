/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 * code generator gen_msl, build 126420.5925.3501
 *                                                                            *
 * Portions Copyright (c) 1986-2010 mental images GmbH, Berlin, Germany.      *
 ******************************************************************************/

// Option settings:


Color adsk_MSL_FNC_rgbTOhsva(in Color X0000000)
{
    float X0000001 = X0000000.r, X0000002 = X0000000.g, X0000003 = X0000000.b, X0000004 = X0000000.a;
    float X0000005, X0000006, X0000007;
    int X0000008 = 0;
    Color X0000009 = float4(0.0f);
    X0000006 = X0000001;
    if(X0000002 < X0000006)
        X0000006 = X0000002;
    if(X0000003 < X0000006)
        X0000006 = X0000003;
    X0000005 = X0000001;
    if(X0000002 > X0000005)
        X0000005 = X0000002;
    if(X0000003 > X0000005)
        X0000005 = X0000003;
    X0000009.b = X0000005;
    if(X0000005 == X0000006) {
        X0000009.r = (X0000009.g = 0.0f);
    } else {
        X0000007 = X0000001 == X0000006 ? X0000002 - X0000003 : (X0000002 == X0000006 ? X0000003 - X0000001 : X0000001 - X0000002);
        X0000008 = X0000001 == X0000006 ? 3 : (X0000002 == X0000006 ? 5 : 1);
        X0000009.r = (float(X0000008) - X0000007 / (X0000005 - X0000006)) / 6.0f;
        X0000009.g = (X0000005 - X0000006) / X0000005;
    }
    X0000009.a = X0000004;
    return X0000009;
}

Color adsk_MSL_FNC_hsvTOrgba(in Color X0000010)
{
    Color X0000011 = float4(0.0f);
    float X0000012 = X0000010.r, X0000013 = X0000010.g, X0000014 = X0000010.b, X0000015 = X0000010.a;
    if(X0000012 == 1.0f || X0000012 == 0.0f)
        X0000012 = .9999f;
    X0000012 *= 6.0f;
    int X0000016;
    float X0000017, X0000018, X0000019, X0000020;
    X0000016 = int(floor(X0000012));
    X0000017 = X0000012 - float(X0000016);
    X0000018 = X0000014 * (1.0f - X0000013);
    X0000019 = X0000014 * (1.0f - X0000013 * X0000017);
    X0000020 = X0000014 * (1.0f - X0000013 * (1.0f - X0000017));
    switch(X0000016) {
    case 0:
        {
            X0000011.r = X0000014;
            X0000011.g = X0000020;
            X0000011.b = X0000018;
            break;
        }
    case 1:
        {
            X0000011.r = X0000019;
            X0000011.g = X0000014;
            X0000011.b = X0000018;
            break;
        }
    case 2:
        {
            X0000011.r = X0000018;
            X0000011.g = X0000014;
            X0000011.b = X0000020;
            break;
        }
    case 3:
        {
            X0000011.r = X0000018;
            X0000011.g = X0000019;
            X0000011.b = X0000014;
            break;
        }
    case 4:
        {
            X0000011.r = X0000020;
            X0000011.g = X0000018;
            X0000011.b = X0000014;
            break;
        }
    case 5:
        {
            X0000011.r = X0000014;
            X0000011.g = X0000018;
            X0000011.b = X0000019;
            break;
        }
    }
    X0000011.a = X0000015;
    return X0000011;
}

shader adsk_Utility_MSL_HSV_Correct {

output:

    Color result;

input:

    Color iColor = float4(0.0f,0.0f,0.0f,1.0f);
    float hue = 1.0f
            {
                hard_range(0.0f,2.0f);
            };
    float sat = 1.0f
            {
                hard_range(0.0f,2.0f);
            };
    float val = 1.0f
            {
                hard_range(0.0f,2.0f);
            };

member:


    void main()
    {
        result = float4(0.0f);
        Color X0000021 = float4(0.0f);
        X0000021 = adsk_MSL_FNC_rgbTOhsva(iColor);
        X0000021.r *= hue;
        X0000021.g *= sat;
        X0000021.b *= val;
        result = adsk_MSL_FNC_hsvTOrgba(X0000021);
    }
};


shader adsk_Utility_MSL_BaseOutput {

output:

    Color result;

input:

    Color ColorInput = float4(1.0f,1.0f,0.0f,1.0f);
    float RGBAmount = 1.0f;
    float RGBOffset = 0.0f;
    float OutputAmount = 1.0f;
    bool Invert = false;
    bool Clamp = false;
    bool AlphaFromRGB = false;

member:


    void main()
    {
        result = float4(0.0f,0.0f,0.0f,0.0f);
        result = ColorInput;
        if(RGBAmount != 1.0f)
            result.rgb *= RGBAmount;
        if(RGBOffset != 0.0f)
            result.rgb += RGBOffset * result.a;
        if(OutputAmount != 1.0f)
            result.rgba *= OutputAmount;
        if(Invert)
            result.rgb = 1.0f - result.rgb;
        if(Clamp)
            result = saturate(result);
        if(AlphaFromRGB)
            result.a = ((result.r + result.g) + result.b) / 3.0f;
    }
};


shader adsk_Utility_MSL_SmoothThreshold_Filter {

output:

    float result;

input:

    float input = 0.0f;
    float low = 0.0f;
    float high = 1.0f;
    float filter = 0.0f;

member:


    void main()
    {
        result = 0.0f;
        float X0000022 = low - filter;
        float X0000023 = low + filter;
        float X0000024 = high - filter;
        float X0000025 = high + filter;
        if(input < X0000022)
            result = 0.0f;
        if(input > X0000025)
            result = 1.0f;
        if(input < X0000023) {
            float X0000026 = (input - X0000022) / (X0000023 - X0000022);
            X0000026 = (X0000026 * X0000026) * (3.0f - 2.0f * X0000026);
            result = (X0000026 * (input - low)) / (high - low);
        }
        if(input < X0000024) {
            result = (input - low) / (high - low);
        } else {
            float X0000027 = (input - X0000024) / (X0000025 - X0000024);
            X0000027 = (X0000027 * X0000027) * (3.0f - 2.0f * X0000027);
            result = ((1.0f - X0000027) * (input - low)) / (high - low) + X0000027;
        }
    }
};


shader adsk_Utility_MSL_SmoothThreshold {

output:

    float result;

input:

    float input = 0.0f;
    float low = 0.0f;
    float high = 1.0f;

member:


    void main()
    {
        result = 0.0f;
        if(input < low) {
            result = 0.0f;
            return;
        }
        if(input > high) {
            result = 1.0f;
            return;
        }
        if(low == high) {
            result = input;
            return;
        }
        result = (input - low) / (high - low);
    }
};
