/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 * code generator gen_msl, build 126420.5925.3501
 *                                                                            *
 * Portions Copyright (c) 1986-2010 mental images GmbH, Berlin, Germany.      *
 ******************************************************************************/

// Option settings:


Color GetPaintBaseFactor(in Color base_color,in float diffuse_weight,in float diffuse_bias,in Color edge_color,in float edge_color_bias,in Color lit_color,in float lit_color_bias,in float iLightDotNL,in float3 iEyeDir,in float3 iNormal)
{
    Color diffuse_base = base_color;
    float factor = 0.0f;
    if(edge_color_bias > 0.0f) {
        factor = abs(dot(iNormal,iEyeDir));
        factor = pow(factor,edge_color_bias);
        diffuse_base = base_color * factor + edge_color * (1.0f - factor);
    }
    float s = 0.0f;
    float local_dot_nl = iLightDotNL;
    if(local_dot_nl < 0.0f)
        local_dot_nl = 0.0f;
    s = pow(local_dot_nl,diffuse_bias);
    Color diffuse_falloff = float4(0.0f);
    if(lit_color_bias > 0.0f) {
        factor = pow(local_dot_nl,lit_color_bias);
        factor *= abs(dot(iNormal,iEyeDir));
        diffuse_falloff = diffuse_base * (1.0f - factor) + lit_color * factor;
    } else {
        diffuse_falloff = diffuse_base;
    }
    return diffuse_falloff * s;
}

Color GetOrenNayarFactor(in float iLightDotNL,in float3 iLightDir,in Color iDiffuseColor,in float iRoughness,in float3 iDir,in float3 iNormal)
{
    float vDot = dot(iNormal,iDir);
    float lDot = iLightDotNL;
    float3 dir = iDir;
    if(vDot < 0.0f) {
        vDot = -vDot;
        dir = -dir;
    }
    float onCoeff = 0.0f;
    float onCoeffX = 0.0f;
    {
        float acLDot = 0.0f;
        float acVDot = 0.0f;
        if(lDot < 0.9999f)
            acLDot = acos(lDot);
        if(acLDot < -3.14159265358979323846f * 0.49f)
            acLDot = -3.14159265358979323846f * 0.49f;
        if(acLDot > 1.53938f)
            acLDot = 1.53938f;
        if(vDot < 0.9999f)
            acVDot = acos(vDot);
        if(acLDot < acVDot) {
            float switchme = acVDot;
            acVDot = acLDot;
            acLDot = switchme;
        }
        float3 vTerm = dir - iNormal * vDot;
        float3 lTerm = iLightDir - iNormal * lDot;
        float gTerm = length(vTerm) * length(lTerm);
        float gamma = 1.0f;
        if(abs(gTerm) < 0.0001f)
            gamma = 1.0f;
        else
            gamma = dot(vTerm,lTerm) / gTerm;
        float rough_square = iRoughness * iRoughness;
        float C2term = rough_square / (rough_square + 0.09f);
        float Cx = (2.0f * (gamma >= 0.0f ? -acVDot : acVDot)) / 3.14159265358979323846f;
        float C1 = 1.0f - 0.5f * (rough_square / (rough_square + 0.33f));
        float C2 = (0.45f * C2term) * (sin(acLDot) - pow(Cx,3.0f));
        float C3 = (0.125f * C2term) * pow((((4.0f * acLDot) * acVDot) / 9.869605f),2.0f);
        float A = (C2 * gamma) * tan(acVDot);
        float B = (C3 * (1.0f - abs(gamma))) * tan(((acLDot + acVDot) / 2.0f));
        onCoeff = (C1 + A) + B;
        Cx = (2.0f * acVDot) / 3.14159265358979323846f;
        onCoeffX = (0.17f * (rough_square / (rough_square + 0.13f))) * (1.0f - (gamma * Cx) * Cx);
    }
    Color oColor = onCoeff * iDiffuseColor;
    oColor += (onCoeffX * iDiffuseColor) * iDiffuseColor;
    return min(float4(1.0f,1.0f,1.0f,1.0f),oColor);
}

void GetONayarSimplexFactor(in float3 n,in float3 l,float3 v,in float iRoughness,in float vDot,in float lDot,out float onCoeff,out float onCoeffX)
{
    float acVDot = acos(vDot);
    float acLDot = acos(lDot);
    float3 vTerm = v - n * vDot;
    float3 lTerm = l - n * lDot;
    float gTerm = length(vTerm) * length(lTerm);
    float gamma = 1.0f;
    if(abs(gTerm) < 0.0001f)
        gamma = 1.0f;
    else
        gamma = dot(vTerm,lTerm) / gTerm;
    float rough_sq = iRoughness * iRoughness;
    float Ct = rough_sq / (rough_sq + 0.09f);
    float A = 1.0f - 0.5f * (rough_sq / (rough_sq + 0.57f));
    float B = 0.45f * Ct;
    float alpha = max(acVDot,acLDot);
    float beta = min(acVDot,acLDot);
    float C = sin(alpha) * tan(beta);
    onCoeff = A + (B * max(0.0f,gamma)) * C;
    float Cx = (2.0f * acVDot) / 3.14159265358979323846f;
    onCoeffX = (0.17f * Ct) * (1.0f - (gamma * Cx) * Cx);
    return;
}

float adsk_aux_hermite_step(in float x0,in float x1,in float v)
{
    float f;
    if(v <= x0)
        return 0.0f;
    if(v >= x1)
        return 1.0f;
    f = (v - x0) / (x1 - x0);
    return (f * f) * (3.0f - 2.0f * f);
}

float GetGlossyCoeff(in float glossiness)
{
    return pow(2.0f,glossiness * 8.0f);
}

float GetPhongSpecularFactor(in float3 iLightDir,in float3 iEyeDir,in float3 iNormal,in float iGlossy,in float iAuxFactor,in bool iAuxGlazed,in bool bypass_glossy_coeff)
{
    float res = 0.0f;
    float glossiness = iGlossy;
    if(!bypass_glossy_coeff)
        glossiness = GetGlossyCoeff(iGlossy);
    float3 half_ = iLightDir - iEyeDir;
    float phi = dot(half_,iNormal);
    phi *= phi / dot(half_,half_);
    if(phi > 0.0f)
        res = exp((log(phi) * 0.5f) * glossiness);
    if(iAuxGlazed)
        res = adsk_aux_hermite_step(0.5f,0.8f,res);
    if(iAuxFactor > 0.0f)
        res *= iAuxFactor * iGlossy;
    return res;
}

float GetSpecularFactor(in float3 dir,in float3 light_dir,in float3 norm,in float3 aniso_u,in float3 aniso_v,in float glossy_factor,in float aniso_factor)
{
    float minin = 0.0001f;
    float dotNL = dot(light_dir,norm);
    float dotEye = -dot(dir,norm);
    if(dotEye * dotNL < minin)
        return 0.0f;
    else {
        float glossy_pow = glossy_factor * glossy_factor;
        float aniso_pow = aniso_factor * aniso_factor;
        float3 half_vector = light_dir - dir;
        half_vector = normalize(half_vector);
        float dotHN = dot(half_vector,norm);
        dotHN *= dotHN;
        if(dotHN > 1.0f)
            dotHN = 1.0f;
        float dotAU = dot(half_vector,aniso_u);
        dotAU *= dotAU;
        float dotAV = dot(half_vector,aniso_v);
        dotAV *= dotAV;
        if(dotHN < minin * (dotAU * glossy_pow + dotAV * aniso_pow))
            return 0.0f;
        else {
            float aniso_fx = -(dotAU * glossy_pow + dotAV * aniso_pow) / dotHN;
            return ((exp(aniso_fx) * glossy_factor) * aniso_factor) / ((sqrt((dotEye * dotNL)) * 4.0f) * 3.14159265358979323846f);
        }
    }
}

void GetIsotropyFactor(out float3 oAnisoU,out float3 oAnisoV,in float3 iNormal)
{
    float3 hVector = float3(0.0f,0.0f,1.0f);
    hVector = float3x3(get_transform("object","internal")) * hVector;
    hVector = normalize(hVector);
    float hDot = dot(iNormal,hVector);
    if(abs(hDot) > 0.999f) {
        hVector = float3(0.0f,1.0f,0.0f);
        hVector = float3x3(get_transform("object","internal")) * hVector;
        hVector = normalize(hVector);
        hDot = dot(iNormal,hVector);
        if(abs(hDot) > 0.999f) {
            hVector = float3(1.0f,0.0f,0.0f);
            hVector = float3x3(get_transform("object","internal")) * hVector;
            hVector = normalize(hVector);
            hDot = dot(iNormal,hVector);
        }
    }
    hVector -= iNormal * hDot;
    hVector = normalize(hVector);
    oAnisoV = hVector;
    oAnisoU = cross(oAnisoV,iNormal);
}

void GetAnisotropyFactor(out float3 oAnisoU,out float3 oAnisoV,in float iAnisotropy,in float iAnisoRot,in int iAnisoChannel,in float3 iNormal)
{
    GetIsotropyFactor(oAnisoU,oAnisoV,iNormal);
    if(iAnisotropy != 1.0f) {
        float aniso_cross_vec_dot = dot(iNormal,oAnisoU);
        oAnisoU -= iNormal * aniso_cross_vec_dot;
        oAnisoU = normalize(oAnisoU);
        aniso_cross_vec_dot = dot(iNormal,oAnisoV);
        oAnisoV -= iNormal * aniso_cross_vec_dot;
        oAnisoV = normalize(oAnisoV);
        if(iAnisoRot != 0.0f) {
            float aniso_rot = (iAnisoRot * 3.14159265358979323846f) * 2.0f;
            float aniso_rot_cos = cos(aniso_rot);
            float aniso_rot_sin = sin(aniso_rot);
            float3 aniso_interp = aniso_rot_cos * oAnisoU + aniso_rot_sin * oAnisoV;
            oAnisoV = -aniso_rot_sin * oAnisoU + aniso_rot_cos * oAnisoV;
            oAnisoU = aniso_interp;
        }
    }
}

float FresnelFactor(in float ior_in,in float ior_out,in float t1,in float t2)
{
    float d_p;
    float d_o;
    float r_p;
    float r_o;
    if(ior_in == ior_out)
        return 0.0f;
    else {
        d_p = ior_in * t2 + ior_out * t1;
        if(d_p == 0.0f)
            r_p = 1.0f;
        else
            r_p = (ior_in * t2 - ior_out * t1) / d_p;
        d_o = ior_in * t1 + ior_out * t2;
        if(d_o == 0.0f)
            r_o = 1.0f;
        else
            r_o = (ior_in * t1 - ior_out * t2) / d_o;
        return 0.5f * (r_p * r_p + r_o * r_o);
    }
}

float GetFresnelFactor(in float dot_nd,in float ior_in,in float ior_out)
{
    float ior;
    float theta;
    ior = ior_in / ior_out;
    theta = 1.0f - (ior * ior) * (1.0f - dot_nd * dot_nd);
    if(theta > 0.0f)
        return FresnelFactor(ior_in,ior_out,dot_nd,-sqrt(theta));
    else
        return 1.0f;
}

Color GetRefractionFactor(in float3 p,in float3 d,in float3 n,in float iorx)
{
    Color rColor = float4(0.0f);
    float3 refr_dir = d;
    refr_dir = refract(d,n,1.0f / iorx);
    if((refr_dir.x == 0.0f && refr_dir.y == 0.0f) && refr_dir.z == 0.0f)
        refr_dir = reflect(d,n);
    Ray rayx = Ray(p,refr_dir);
    Ray ray_dx, ray_dy;
    Trace_options trace_options;
    trace_options.set_ray_type("environment");
    trace(rayx,ray_dx,ray_dy,trace_options,"result",rColor);
    return rColor;
}

Color GetReflectionFactor(in float3 p,in float3 d,in float3 n)
{
    Color rColor = float4(0.0f);
    float3 refl_dir = reflect(d,n);
    Ray rayx = Ray(p,refl_dir);
    Ray ray_dx, ray_dy;
    Trace_options trace_options;
    trace_options.set_ray_type("environment");
    trace(rayx,ray_dx,ray_dy,trace_options,"result",rColor);
    return rColor;
}

float SimpleFalloff(float3 direction,float3 normal,float amount)
{
    float f = saturate(dot(-direction,normal));
    f = 1.0f - pow(f,1.0f / amount);
    return f;
}

Color GetOpacityFactor(in float3 p,in float3 d)
{
    Color rColor = float4(0.0f);
    Ray rayx = Ray(p,d);
    Ray ray_dx, ray_dy;
    Trace_options trace_options;
    trace_options.set_ray_type("environment");
    trace(rayx,ray_dx,ray_dy,trace_options,"result",rColor);
    return rColor;
}

void TransformBumpVector(in int b_mode,in float3 b_vector,inout float3 b_transform)
{
    if((b_vector.x == 0.0f && b_vector.y == 0.0f) && b_vector.z == 0.0f)
        return;
    switch(b_mode) {
    case 1:
    case 5:
        {
            break;
        }
    case 2:
    case 6:
        {
            b_vector = transform_vector("world","internal",b_vector);
            break;
        }
    case 3:
    case 7:
        {
            b_vector = transform_vector("object","internal",b_vector);
            break;
        }
    case 4:
    case 8:
        {
            b_vector = transform_vector("camera","internal",b_vector);
            break;
        }
    }
    if(b_mode <= 4)
        b_transform += b_vector;
    else
        b_transform = b_vector;
    b_transform = normalize(b_transform);
}

shader adsk_Utility_BRDF_Accumulator {

output:

    Color result;
    Color oDiffuse;
    Color oSpecular;

input:

    Shader iDiffuse;
    Shader iSpecular;
    Shader iBump;
    float iSpecFx = 1.0f;
    float3 iNormal = float3(0.0f,0.0f,0.0f)
            {
                default_to_state("normal",0);
            };
    bool paint_model = false;

member:


    void main()
    {
        result = float4(0.0f);
        oDiffuse = float4(0.0f);
        oSpecular = float4(0.0f);
        Color X0000000 = float4(0.0f);
        Color X0000001 = float4(0.0f);
        float3 X0000002 = iNormal;
        float3 X0000003 = iNormal;
        if(iBump.call("output","bump_global",X0000002,"output","bump_local",X0000003)) {
            state::normal = X0000003;
        } else {
            state::normal = iNormal;
        }
        Color X0000004 = float4(0.0f);
        float X0000005 = 0.0f;
        float X0000006 = 0.0f;
        float X0000007 = 0.0f;
        float X0000008 = 0.0f;
        Light_iterator X0000009;
        foreach(X0000009) {
            X0000006 = X0000009.dot_nl;
            if(X0000009.dot_nl >= 0.0f) {
                X0000007 = X0000006;
                X0000007 *= smoothstep(0.0f,0.25f,X0000006);
                X0000008 = saturate(X0000007);
                if(X0000008 > 0.0f && iDiffuse.call("input","iLightDotNL",X0000009.dot_nl,"input","iLightDir",X0000009.direction,"input","iEyeDir",state::direction,"input","iNormal",X0000002,"output","result",X0000004)) {
                    if(paint_model)
                        oDiffuse += ((1.0f * X0000004) * X0000009.contribution) / 3.14159265358979323846f;
                    else
                        oDiffuse += ((X0000008 * X0000004) * X0000009.contribution) / 3.14159265358979323846f;
                }
                if(iSpecular.call("input","iLightDir",X0000009.direction,"input","iEyeDir",state::direction,"input","iNormal",state::normal,"output","result",X0000005)) {
                    X0000005 *= X0000007;
                    oSpecular += ((X0000009.contribution / 3.14159265358979323846f) * X0000005) * iSpecFx;
                }
            }
        }
        result = oDiffuse + oSpecular;
    }
};
