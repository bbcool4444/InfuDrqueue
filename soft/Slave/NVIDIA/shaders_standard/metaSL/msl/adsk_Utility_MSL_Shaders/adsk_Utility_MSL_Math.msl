/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 * code generator gen_msl, build 126420.5925.3501
 *                                                                            *
 * Portions Copyright (c) 1986-2010 mental images GmbH, Berlin, Germany.      *
 ******************************************************************************/

// Option settings:


float adsk_Utility_MSL_Function_ChangeRange(in float X0000000,in float X0000001,in float X0000002,in float X0000003,in float X0000004)
{
    if(X0000000 == 0.0f)
        return 0.0f;
    float X0000005 = X0000002 - X0000001;
    float X0000006 = X0000004 - X0000003;
    if(X0000005 == 0.0f) {
        return X0000000;
    }
    float X0000007 = X0000006 / X0000005;
    float X0000008 = X0000000 - X0000001;
    float X0000009 = X0000007 * X0000008;
    return X0000009 + X0000003;
}

float adsk_Utility_MSL_Function_Threshold(in float X0000010,in float X0000011,in float X0000012)
{
    if(X0000010 == 0.0f || X0000010 < X0000011)
        return 0.0f;
    if(X0000010 >= X0000012)
        return 1.0f;
    float X0000013 = (X0000010 - X0000011) / (X0000012 - X0000011);
    return (X0000013 * X0000013) * (3.0f - 2.0f * X0000013);
}

shader adsk_Utility_MSL_Change_Range {

output:

    float result;

input:

    float the_value;
    float i_min;
    float i_max;
    float o_min;
    float o_max;

member:


    void main()
    {
        result = 0.0f;
        result = adsk_Utility_MSL_Function_ChangeRange(the_value,i_min,i_max,o_min,o_max);
    }
};


shader adsk_Utility_MSL_Curve_Mix {

output:

    float result;

input:

    float the_value;
    float o_min;
    float o_max;

member:


    void main()
    {
        result = 0.0f;
        result = adsk_Utility_MSL_Function_Threshold(the_value,o_min,o_max);
    }
};


shader adsk_Utility_MSL_MultiplyDivide {

output:

    float3 result;

input:

    int operation;
    float3 input1;
    float3 input2;

member:


    void main()
    {
        result = float3(0.0f,0.0f,0.0f);
        switch(operation) {
        case 0:
            result = input1;
            break;
        case 1:
            result = input1 * input2;
            break;
        case 2:
            if((input2.x == 0.0f || input2.y == 0.0f) || input2.z == 0.0f)
                return;
            result = input1 / input2;
            break;
        case 3:
            result = pow(input1,input2);
            break;
        }
    }
};


shader adsk_Utility_MSL_Condition {

output:

    Color result;

input:

    int operation;
    float firstTerm;
    float secondTerm;
    Color color1 = float4(1.0f,1.0f,1.0f,1.0f);
    Color color2 = float4(0.0f,0.0f,0.0f,0.0f);

member:


    void main()
    {
        result = float4(0.0f,0.0f,0.0f,0.0f);
        switch(operation) {
        case 0:
            if(firstTerm == secondTerm)
                result = color1;
            else
                result = color2;
            break;
        case 1:
            if(firstTerm != secondTerm)
                result = color1;
            else
                result = color2;
            break;
        case 2:
            if(firstTerm > secondTerm)
                result = color1;
            else
                result = color2;
            break;
        case 3:
            if(firstTerm >= secondTerm)
                result = color1;
            else
                result = color2;
            break;
        case 4:
            if(firstTerm < secondTerm)
                result = color1;
            else
                result = color2;
            break;
        case 5:
            if(firstTerm <= secondTerm)
                result = color1;
            else
                result = color2;
            break;
        }
    }
};


shader adsk_Utility_MSL_Gamma {

output:

    float3 result;

input:

    float3 value = float3(0.0f,0.0f,0.0f);
    float3 gamma = float3(1.0f,1.0f,1.0f);

member:


    void main()
    {
        result = float3(0.0f,0.0f,0.0f);
        result = pow(value,gamma);
    }
};


shader adsk_Utility_MSL_Contrast {

output:

    float3 result;

input:

    float3 value = float3(0.0f,0.0f,0.0f);
    float3 contrast = float3(1.0f,1.0f,1.0f);
    float3 bias = float3(0.5f,0.5f,0.5f);

member:


    float X0000014(in float X0000015,in float X0000016,in float X0000017)
    {
        if(X0000015 > X0000017)
            X0000015 = X0000017;
        else if(X0000015 < X0000016)
            X0000015 = X0000016;
        return X0000015;
    }

    void main()
    {
        result = float3(0.0f,0.0f,0.0f);
        float X0000018;
        float X0000019 = log(2.0f);
        if(value.x <= 0.0f)
            result.x = 0.0f;
        else {
            X0000018 = X0000019 / log(X0000014(bias.x,0.00001f,0.99999f));
            X0000018 = 2.0f * pow(value.x,-X0000018);
            result.x = X0000018 <= 1.0f ? 0.5f * pow(X0000018,contrast.x) : 1.0f - 0.5f * pow((2.0f - X0000018),contrast.x);
        }
        if(value.y <= 0.0f)
            result.y = 0.0f;
        else {
            X0000018 = X0000019 / log(X0000014(bias.y,0.00001f,0.99999f));
            X0000018 = 2.0f * pow(value.y,-X0000018);
            result.y = X0000018 <= 1.0f ? 0.5f * pow(X0000018,contrast.y) : 1.0f - 0.5f * pow((2.0f - X0000018),contrast.y);
        }
        if(value.z <= 0.0f)
            result.z = 0.0f;
        else {
            X0000018 = X0000019 / log(X0000014(bias.z,0.00001f,0.99999f));
            X0000018 = 2.0f * pow(value.z,-X0000018);
            result.z = X0000018 <= 1.0f ? 0.5f * pow(X0000018,contrast.z) : 1.0f - 0.5f * pow((2.0f - X0000018),contrast.z);
        }
    }
};


shader adsk_Utility_MSL_DegToRad {

output:

    float result;

input:

    float iDeg;

member:


    void main()
    {
        result = 0.0f;
        result = (iDeg * 0.005556f) * 3.14159265358979323846f;
    }
};


shader adsk_Utility_MSL_RadToDeg {

output:

    float result;

input:

    float iRad;

member:


    void main()
    {
        result = 0.0f;
        result = (iRad * 180.0f) * 0.31831f;
    }
};
