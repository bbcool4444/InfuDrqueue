/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 * code generator gen_msl, build 126420.5925.3501
 *                                                                            *
 * Portions Copyright (c) 1986-2010 mental images GmbH, Berlin, Germany.      *
 ******************************************************************************/

// Option settings:


Color GetPaintBaseFactor(in Color base_color,in float diffuse_weight,in float diffuse_bias,in Color edge_color,in float edge_color_bias,in Color lit_color,in float lit_color_bias,in float iLightDotNL,in float3 iEyeDir,in float3 iNormal)
{
    Color diffuse_base = base_color;
    float factor = 0.0f;
    if(edge_color_bias > 0.0f) {
        factor = abs(dot(iNormal,iEyeDir));
        factor = pow(factor,edge_color_bias);
        diffuse_base = base_color * factor + edge_color * (1.0f - factor);
    }
    float s = 0.0f;
    float local_dot_nl = iLightDotNL;
    if(local_dot_nl < 0.0f)
        local_dot_nl = 0.0f;
    s = pow(local_dot_nl,diffuse_bias);
    Color diffuse_falloff = float4(0.0f);
    if(lit_color_bias > 0.0f) {
        factor = pow(local_dot_nl,lit_color_bias);
        factor *= abs(dot(iNormal,iEyeDir));
        diffuse_falloff = diffuse_base * (1.0f - factor) + lit_color * factor;
    } else {
        diffuse_falloff = diffuse_base;
    }
    return diffuse_falloff * s;
}

Color GetOrenNayarFactor(in float iLightDotNL,in float3 iLightDir,in Color iDiffuseColor,in float iRoughness,in float3 iDir,in float3 iNormal)
{
    float vDot = dot(iNormal,iDir);
    float lDot = iLightDotNL;
    float3 dir = iDir;
    if(vDot < 0.0f) {
        vDot = -vDot;
        dir = -dir;
    }
    float onCoeff = 0.0f;
    float onCoeffX = 0.0f;
    {
        float acLDot = 0.0f;
        float acVDot = 0.0f;
        if(lDot < 0.9999f)
            acLDot = acos(lDot);
        if(acLDot < -3.14159265358979323846f * 0.49f)
            acLDot = -3.14159265358979323846f * 0.49f;
        if(acLDot > 1.53938f)
            acLDot = 1.53938f;
        if(vDot < 0.9999f)
            acVDot = acos(vDot);
        if(acLDot < acVDot) {
            float switchme = acVDot;
            acVDot = acLDot;
            acLDot = switchme;
        }
        float3 vTerm = dir - iNormal * vDot;
        float3 lTerm = iLightDir - iNormal * lDot;
        float gTerm = length(vTerm) * length(lTerm);
        float gamma = 1.0f;
        if(abs(gTerm) < 0.0001f)
            gamma = 1.0f;
        else
            gamma = dot(vTerm,lTerm) / gTerm;
        float rough_square = iRoughness * iRoughness;
        float C2term = rough_square / (rough_square + 0.09f);
        float Cx = (2.0f * (gamma >= 0.0f ? -acVDot : acVDot)) / 3.14159265358979323846f;
        float C1 = 1.0f - 0.5f * (rough_square / (rough_square + 0.33f));
        float C2 = (0.45f * C2term) * (sin(acLDot) - pow(Cx,3.0f));
        float C3 = (0.125f * C2term) * pow((((4.0f * acLDot) * acVDot) / 9.869605f),2.0f);
        float A = (C2 * gamma) * tan(acVDot);
        float B = (C3 * (1.0f - abs(gamma))) * tan(((acLDot + acVDot) / 2.0f));
        onCoeff = (C1 + A) + B;
        Cx = (2.0f * acVDot) / 3.14159265358979323846f;
        onCoeffX = (0.17f * (rough_square / (rough_square + 0.13f))) * (1.0f - (gamma * Cx) * Cx);
    }
    Color oColor = onCoeff * iDiffuseColor;
    oColor += (onCoeffX * iDiffuseColor) * iDiffuseColor;
    return min(float4(1.0f,1.0f,1.0f,1.0f),oColor);
}

void GetONayarSimplexFactor(in float3 n,in float3 l,float3 v,in float iRoughness,in float vDot,in float lDot,out float onCoeff,out float onCoeffX)
{
    float acVDot = acos(vDot);
    float acLDot = acos(lDot);
    float3 vTerm = v - n * vDot;
    float3 lTerm = l - n * lDot;
    float gTerm = length(vTerm) * length(lTerm);
    float gamma = 1.0f;
    if(abs(gTerm) < 0.0001f)
        gamma = 1.0f;
    else
        gamma = dot(vTerm,lTerm) / gTerm;
    float rough_sq = iRoughness * iRoughness;
    float Ct = rough_sq / (rough_sq + 0.09f);
    float A = 1.0f - 0.5f * (rough_sq / (rough_sq + 0.57f));
    float B = 0.45f * Ct;
    float alpha = max(acVDot,acLDot);
    float beta = min(acVDot,acLDot);
    float C = sin(alpha) * tan(beta);
    onCoeff = A + (B * max(0.0f,gamma)) * C;
    float Cx = (2.0f * acVDot) / 3.14159265358979323846f;
    onCoeffX = (0.17f * Ct) * (1.0f - (gamma * Cx) * Cx);
    return;
}

float adsk_aux_hermite_step(in float x0,in float x1,in float v)
{
    float f;
    if(v <= x0)
        return 0.0f;
    if(v >= x1)
        return 1.0f;
    f = (v - x0) / (x1 - x0);
    return (f * f) * (3.0f - 2.0f * f);
}

float GetGlossyCoeff(in float glossiness)
{
    return pow(2.0f,glossiness * 8.0f);
}

float GetPhongSpecularFactor(in float3 iLightDir,in float3 iEyeDir,in float3 iNormal,in float iGlossy,in float iAuxFactor,in bool iAuxGlazed,in bool bypass_glossy_coeff)
{
    float res = 0.0f;
    float glossiness = iGlossy;
    if(!bypass_glossy_coeff)
        glossiness = GetGlossyCoeff(iGlossy);
    float3 half_ = iLightDir - iEyeDir;
    float phi = dot(half_,iNormal);
    phi *= phi / dot(half_,half_);
    if(phi > 0.0f)
        res = exp((log(phi) * 0.5f) * glossiness);
    if(iAuxGlazed)
        res = adsk_aux_hermite_step(0.5f,0.8f,res);
    if(iAuxFactor > 0.0f)
        res *= iAuxFactor * iGlossy;
    return res;
}

float GetSpecularFactor(in float3 dir,in float3 light_dir,in float3 norm,in float3 aniso_u,in float3 aniso_v,in float glossy_factor,in float aniso_factor)
{
    float minin = 0.0001f;
    float dotNL = dot(light_dir,norm);
    float dotEye = -dot(dir,norm);
    if(dotEye * dotNL < minin)
        return 0.0f;
    else {
        float glossy_pow = glossy_factor * glossy_factor;
        float aniso_pow = aniso_factor * aniso_factor;
        float3 half_vector = light_dir - dir;
        half_vector = normalize(half_vector);
        float dotHN = dot(half_vector,norm);
        dotHN *= dotHN;
        if(dotHN > 1.0f)
            dotHN = 1.0f;
        float dotAU = dot(half_vector,aniso_u);
        dotAU *= dotAU;
        float dotAV = dot(half_vector,aniso_v);
        dotAV *= dotAV;
        if(dotHN < minin * (dotAU * glossy_pow + dotAV * aniso_pow))
            return 0.0f;
        else {
            float aniso_fx = -(dotAU * glossy_pow + dotAV * aniso_pow) / dotHN;
            return ((exp(aniso_fx) * glossy_factor) * aniso_factor) / ((sqrt((dotEye * dotNL)) * 4.0f) * 3.14159265358979323846f);
        }
    }
}

void GetIsotropyFactor(out float3 oAnisoU,out float3 oAnisoV,in float3 iNormal)
{
    float3 hVector = float3(0.0f,0.0f,1.0f);
    hVector = float3x3(get_transform("object","internal")) * hVector;
    hVector = normalize(hVector);
    float hDot = dot(iNormal,hVector);
    if(abs(hDot) > 0.999f) {
        hVector = float3(0.0f,1.0f,0.0f);
        hVector = float3x3(get_transform("object","internal")) * hVector;
        hVector = normalize(hVector);
        hDot = dot(iNormal,hVector);
        if(abs(hDot) > 0.999f) {
            hVector = float3(1.0f,0.0f,0.0f);
            hVector = float3x3(get_transform("object","internal")) * hVector;
            hVector = normalize(hVector);
            hDot = dot(iNormal,hVector);
        }
    }
    hVector -= iNormal * hDot;
    hVector = normalize(hVector);
    oAnisoV = hVector;
    oAnisoU = cross(oAnisoV,iNormal);
}

void GetAnisotropyFactor(out float3 oAnisoU,out float3 oAnisoV,in float iAnisotropy,in float iAnisoRot,in int iAnisoChannel,in float3 iNormal)
{
    GetIsotropyFactor(oAnisoU,oAnisoV,iNormal);
    if(iAnisotropy != 1.0f) {
        float aniso_cross_vec_dot = dot(iNormal,oAnisoU);
        oAnisoU -= iNormal * aniso_cross_vec_dot;
        oAnisoU = normalize(oAnisoU);
        aniso_cross_vec_dot = dot(iNormal,oAnisoV);
        oAnisoV -= iNormal * aniso_cross_vec_dot;
        oAnisoV = normalize(oAnisoV);
        if(iAnisoRot != 0.0f) {
            float aniso_rot = (iAnisoRot * 3.14159265358979323846f) * 2.0f;
            float aniso_rot_cos = cos(aniso_rot);
            float aniso_rot_sin = sin(aniso_rot);
            float3 aniso_interp = aniso_rot_cos * oAnisoU + aniso_rot_sin * oAnisoV;
            oAnisoV = -aniso_rot_sin * oAnisoU + aniso_rot_cos * oAnisoV;
            oAnisoU = aniso_interp;
        }
    }
}

float FresnelFactor(in float ior_in,in float ior_out,in float t1,in float t2)
{
    float d_p;
    float d_o;
    float r_p;
    float r_o;
    if(ior_in == ior_out)
        return 0.0f;
    else {
        d_p = ior_in * t2 + ior_out * t1;
        if(d_p == 0.0f)
            r_p = 1.0f;
        else
            r_p = (ior_in * t2 - ior_out * t1) / d_p;
        d_o = ior_in * t1 + ior_out * t2;
        if(d_o == 0.0f)
            r_o = 1.0f;
        else
            r_o = (ior_in * t1 - ior_out * t2) / d_o;
        return 0.5f * (r_p * r_p + r_o * r_o);
    }
}

float GetFresnelFactor(in float dot_nd,in float ior_in,in float ior_out)
{
    float ior;
    float theta;
    ior = ior_in / ior_out;
    theta = 1.0f - (ior * ior) * (1.0f - dot_nd * dot_nd);
    if(theta > 0.0f)
        return FresnelFactor(ior_in,ior_out,dot_nd,-sqrt(theta));
    else
        return 1.0f;
}

Color GetRefractionFactor(in float3 p,in float3 d,in float3 n,in float iorx)
{
    Color rColor = float4(0.0f);
    float3 refr_dir = d;
    refr_dir = refract(d,n,1.0f / iorx);
    if((refr_dir.x == 0.0f && refr_dir.y == 0.0f) && refr_dir.z == 0.0f)
        refr_dir = reflect(d,n);
    Ray rayx = Ray(p,refr_dir);
    Ray ray_dx, ray_dy;
    Trace_options trace_options;
    trace_options.set_ray_type("environment");
    trace(rayx,ray_dx,ray_dy,trace_options,"result",rColor);
    return rColor;
}

Color GetReflectionFactor(in float3 p,in float3 d,in float3 n)
{
    Color rColor = float4(0.0f);
    float3 refl_dir = reflect(d,n);
    Ray rayx = Ray(p,refl_dir);
    Ray ray_dx, ray_dy;
    Trace_options trace_options;
    trace_options.set_ray_type("environment");
    trace(rayx,ray_dx,ray_dy,trace_options,"result",rColor);
    return rColor;
}

float SimpleFalloff(float3 direction,float3 normal,float amount)
{
    float f = saturate(dot(-direction,normal));
    f = 1.0f - pow(f,1.0f / amount);
    return f;
}

Color GetOpacityFactor(in float3 p,in float3 d)
{
    Color rColor = float4(0.0f);
    Ray rayx = Ray(p,d);
    Ray ray_dx, ray_dy;
    Trace_options trace_options;
    trace_options.set_ray_type("environment");
    trace(rayx,ray_dx,ray_dy,trace_options,"result",rColor);
    return rColor;
}

void TransformBumpVector(in int b_mode,in float3 b_vector,inout float3 b_transform)
{
    if((b_vector.x == 0.0f && b_vector.y == 0.0f) && b_vector.z == 0.0f)
        return;
    switch(b_mode) {
    case 1:
    case 5:
        {
            break;
        }
    case 2:
    case 6:
        {
            b_vector = transform_vector("world","internal",b_vector);
            break;
        }
    case 3:
    case 7:
        {
            b_vector = transform_vector("object","internal",b_vector);
            break;
        }
    case 4:
    case 8:
        {
            b_vector = transform_vector("camera","internal",b_vector);
            break;
        }
    }
    if(b_mode <= 4)
        b_transform += b_vector;
    else
        b_transform = b_vector;
    b_transform = normalize(b_transform);
}

shader adsk_Utility_BRDF_Manager {

output:

    Color result;
    Color diffuse_result;
    Color spec_result;
    Color refl_result;
    Color refr_result;

input:

    float diffuse_weight = 1.0f
            {
                display_name("Diffuse level");
                hard_range(0.0f,1.0f);
            };
    Color diffuse = float4(0.5f,0.5f,0.5f,1.0f)
            {
                display_name("Color");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    float diffuse_roughness = 0.0f
            {
                display_name("Roughness");
                hard_range(0.0f,1.0f);
            };
    float reflectivity = 0.6f
            {
                display_name("Reflectivity");
                hard_range(0.0f,1.0f);
            };
    Color refl_color = float4(1.0f,1.0f,1.0f,1.0f)
            {
                display_name("Reflection color");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    float refl_gloss = 1.0f
            {
                display_name("Reflection glossiness");
                hard_range(0.0f,1.0f);
            };
    float refl_balance = 1.0f
            {
                display_name("Highlights balance");
                hard_range(0.0f,1.0f);
            };
    bool refl_hl_only = false
            {
                display_name("Highlights only");
            };
    bool brdf_conserve_energy = true
            {
                display_name("BRDF Energy Conservation");
            };
    float brdf_0_degree_refl = 0.2f
            {
                display_name("BRDF 0 reflection");
                hard_range(0.0f,1.0f);
            };
    float brdf_90_degree_refl = 1.0f
            {
                display_name("BRDF 90 reflection");
                hard_range(0.0f,1.0f);
            };
    float brdf_curve = 5.0f
            {
                display_name("BRDF Curve shape ");
                soft_range(0.0f,10.0f);
            };
    bool brdf_fresnel = false
            {
                display_name("Fresnel");
            };
    float brdf_ior = 1.4f
            {
                display_name("IOR");
            };
    float anisotropy = 1.0f
            {
                display_name("Anisotropy");
                soft_range(0.0f,2.0f);
            };
    float transparency = 0.0f
            {
                display_name("Transparency");
                hard_range(0.0f,1.0f);
            };
    float cutout_opacity = 1.0f
            {
                display_name("Cutout opacity");
                hard_range(0.0f,1.0f);
            };
    Color additional_color = float4(.0f,.0f,.0f,.0f)
            {
                display_name("Additional color");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    Shader iPaintBaseTerm;
    Shader iOrenNayarTerm;
    Shader iSpecularTerm;
    Shader iAnisotropicTerm;
    Shader iFlakeTerm;
    Shader iFresnelTerm;
    Shader iTranspTerm;
    Shader iBumpTerm;

member:


    void X0000000(in float3 X0000001,in float3 X0000002,in float3 X0000003,inout Color X0000004)
    {
        X0000004 = float4(0.0f);
        float3 X0000005 = reflect(X0000002,X0000003);
        Ray X0000006 = Ray(X0000001,X0000005);
        Ray X0000007, X0000008;
        Trace_options X0000009;
        X0000009.set_ray_type("environment");
        trace(X0000006,X0000007,X0000008,X0000009,"result",X0000004);
        X0000004.a += 1.0f;
    }

    void main()
    {
        result = float4(0.0f);
        diffuse_result = float4(0.0f);
        spec_result = float4(0.0f);
        refl_result = float4(0.0f);
        refr_result = float4(0.0f);
        Color X0000010 = float4(0.0f);
        Color X0000011 = float4(0.0f);
        Color X0000012 = float4(0.0f);
        Color X0000013 = float4(0.0f);
        Color X0000014 = diffuse;
        float X0000015 = diffuse_weight;
        float X0000016 = reflectivity;
        Color X0000017 = refl_color;
        bool X0000018 = refl_hl_only;
        float X0000019 = refl_gloss;
        float X0000020 = refl_balance;
        float X0000021 = 1.0f;
        float X0000022 = 1.0f;
        Color X0000023 = float4(0.212671f,0.715160f,0.072169f,0.0f);
        Color X0000024 = float4(0.0f);
        X0000024.a = 0.0f;
        if(cutout_opacity < 0.01f) {
            refr_result = GetOpacityFactor(state::position,state::direction);
            result = refr_result;
            return;
        }
        float3 X0000025 = state::normal;
        float3 X0000026 = state::normal;
        if(iBumpTerm.call("output","bump_global",X0000025,"output","bump_local",X0000026)) {
            state::normal = X0000025;
        }
        float X0000027 = anisotropy;
        float3 X0000028 = float3(0.0f,0.0f,0.0f);
        float3 X0000029 = float3(0.0f,0.0f,0.0f);
        if(anisotropy != 1.0f && iAnisotropicTerm.call("input","iAnisotropy",X0000027,"output","oAnisoU",X0000028,"output","oAnisoV",X0000029)) {
        }
        if(brdf_fresnel && iFresnelTerm.call("input","dot_nd",state::dot_nd,"input","ior_in",1.0f,"input","ior_out",brdf_ior,"output","result",X0000022)) {
            X0000016 *= X0000022;
        } else {
            float X0000030 = pow(1.0f - abs(dot(state::direction,state::normal)),brdf_curve);
            X0000022 = brdf_90_degree_refl * X0000030 + brdf_0_degree_refl * (1.0f - X0000030);
            X0000016 *= X0000022;
        }
        X0000014.a = (X0000014.r * X0000023.r + X0000014.g * X0000023.g) + X0000014.b * X0000023.b;
        X0000017.a = (X0000017.r * X0000023.r + X0000017.g * X0000023.g) + X0000017.b * X0000023.b;
        X0000017 *= X0000016;
        Color X0000031 = float4(0.0f);
        if(transparency > 0.0f) {
            if(iTranspTerm.call("input","iTransparency",transparency,"input","iEnConsFactor",X0000017.a,"input","iRefr_ior",brdf_ior,"input","iNormal",state::normal,"output","translucency",X0000031,"output","refraction",X0000024)) {
                X0000010.rgb += X0000031.rgb;
            }
        }
        if(brdf_conserve_energy) {
            X0000015 *= 1.0f - X0000024.a * transparency;
            X0000015 *= 1.0f - X0000017.a;
        }
        if(X0000018)
            X0000015 += X0000017.a;
        X0000014 *= X0000015;
        Color X0000032 = float4(0.0f);
        Color X0000033 = float4(0.0f);
        Color X0000034 = float4(0.0f);
        float X0000035 = 0.0f;
        float X0000036 = 0.0f;
        float X0000037 = 0.0f;
        float X0000038 = 0.5f;
        float X0000039 = 0.0f;
        Color X0000040 = float4(0.0f);
        Light_iterator X0000041;
        foreach(X0000041) {
            X0000035 = X0000041.dot_nl;
            if(X0000035 >= 0.0f) {
                X0000036 = X0000035;
                X0000036 *= smoothstep(0.0f,0.25f,X0000035);
                X0000037 = saturate(X0000036);
                X0000037 = saturate(X0000036);
                if(X0000037 > 0.0f) {
                    X0000032 = X0000014;
                    if(iPaintBaseTerm.call("input","iLightDotNL",X0000041.dot_nl,"input","iEyeDir",state::direction,"input","iNormal",state::normal,"input","base_color",X0000032,"output","result",X0000033)) {
                        X0000032 = X0000033 * X0000015;
                    }
                    if(diffuse_roughness > 0.0f) {
                        if(iOrenNayarTerm.call("input","iLightDotNL",X0000041.dot_nl,"input","iLightDir",X0000041.direction,"input","iEyeDir",state::direction,"input","iNormal",state::normal,"input","iDiffuseColor",X0000032,"input","iRoughness",diffuse_roughness,"output","result",X0000034)) {
                            X0000032 = X0000034;
                        }
                    }
                    X0000010 += ((X0000037 * X0000032) * X0000041.contribution) / 3.14159265358979323846f;
                }
                {
                    if(iSpecularTerm.call("input","iLightDir",X0000041.direction,"input","iEyeDir",state::direction,"input","iNormal",state::normal,"input","iGlossy",X0000019,"output","result",X0000038)) {
                        X0000038 *= X0000036 * X0000020;
                        X0000011 += (X0000041.contribution * X0000017) * X0000038;
                    }
                }
                if(iFlakeTerm.call("input","iLightDir",X0000041.direction,"input","iEyeDir",state::direction,"output","result",X0000039)) {
                    X0000040 += ((X0000041.contribution / 3.14159265358979323846f) * X0000017) * X0000039;
                }
            }
        }
        if(X0000017.a > 0.0f && !X0000018) {
            X0000000(state::position,state::direction,state::normal,X0000012);
            X0000012.rgb *= X0000017.rgb;
        }
        X0000013 = X0000024;
        diffuse_result = X0000010;
        spec_result = X0000011;
        refl_result = X0000012;
        refr_result = X0000013;
        result = ((X0000010 + X0000011) + X0000012) + X0000013;
        result.a = X0000013.a * X0000024.a + (1.0f - X0000024.a);
        result.rgb += X0000040.rgb;
        result.rgb += additional_color.rgb;
        result *= cutout_opacity;
    }
};
