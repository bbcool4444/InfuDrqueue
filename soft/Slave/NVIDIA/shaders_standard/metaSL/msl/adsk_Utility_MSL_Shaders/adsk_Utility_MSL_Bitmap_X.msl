/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 * code generator gen_msl, build 126420.5925.3501
 *                                                                            *
 * Portions Copyright (c) 1986-2010 mental images GmbH, Berlin, Germany.      *
 ******************************************************************************/

// Option settings:


void adskRotate(inout float4x3 r,in float ang)
{
    float s = sin(ang);
    float c = cos(ang);
    float tmp;
    float3 t;
    int i = 0;
    for(i = 3; i >= 0; i--) {
        t = r[i];
        tmp = t[0] * c - t[1] * s;
        t[1] = t[0] * s + t[1] * c;
        t[0] = tmp;
        (r[i])[0] = t[0];
        (r[i])[1] = t[1];
    }
}

float2 adskVectorTransform(in float2 v,in float4x3 m,in bool abs_val)
{
    float2 r = float2(0.0f,0.0f);
    if(!abs_val) {
        r.x = v.x * (m[0])[0] + v.y * (m[1])[0];
        r.y = v.x * (m[0])[1] + v.y * (m[1])[1];
    } else {
        r.x = abs(v.x * (m[0])[0]) + abs(v.y * (m[1])[0]);
        r.y = abs(v.x * (m[0])[1]) + abs(v.y * (m[1])[1]);
    }
    return r;
}

void adskTransformUV(in bool usePhysUVs,in float uoffs,in float voffs,in float uscl,in float vscl,in bool inst_rotated,in float4x3 inst_transform,inout float2 t,inout float2 d)
{
    float centerOffset = 0.5f;
    if((usePhysUVs && uscl != 0.0f) && vscl != 0.0f) {
        centerOffset = 0.0f;
        uscl = 1.0f / uscl;
        vscl = 1.0f / vscl;
    }
    t.x -= uoffs + centerOffset;
    t.y -= voffs + centerOffset;
    if(inst_rotated) {
        t = adskVectorTransform(t,inst_transform,false);
        d = adskVectorTransform(d,inst_transform,true);
    }
    if(uscl != 1.0f) {
        t.x *= uscl;
        d.x *= uscl;
        if(d.x < 0.0f)
            d.x = -d.x;
    }
    if(vscl != 1.0f) {
        t.y *= vscl;
        d.y *= vscl;
        if(d.y < 0.0f)
            d.y = -d.y;
    }
    t.x += centerOffset;
    t.y += centerOffset;
}

shader adsk_Utility_MSL_UVGenerator_Simple {

output:

    Color result;

input:

    int uv_space = 0
            {
                literal();
            };
    float u_scale = 1.0f;
    float v_scale = 1.0f;
    float u_offset = 0.0f;
    float v_offset = 0.0f;
    float angle = 0.0f;

member:


    void main()
    {
        result = float4(0.0f,0.0f,0.0f,0.0f);
        float2 texture_uv = (state::texture_coordinate[0]).xy;
        float2 uv_sized = float2(0.0f,0.0f);
        uv_sized.x = texture_uv.x * u_scale - u_offset;
        uv_sized.y = texture_uv.y * v_scale - v_offset;
        float sa = sin(angle);
        float ca = cos(angle);
        result.r = uv_sized.x * ca - uv_sized.y * sa;
        result.g = uv_sized.x * sa - uv_sized.y * ca;
        float2 dUV = float2(0.0f,0.0f);
        dUV = (abs(ddx((state::texture_coordinate[0])).xyz) + abs(ddy((state::texture_coordinate[0])).xyz)).xy;
        if(dUV.x == 0.0f && dUV.y == 0.0f)
            dUV = float2(0.002f,0.002f);
        dUV.x *= u_scale;
        dUV.y *= v_scale;
        if(dUV.x < 0.0f)
            dUV.x = -dUV.x;
        if(dUV.y < 0.0f)
            dUV.y = -dUV.y;
        result.b = abs(dUV.x * ca - dUV.y * sa);
        result.a = abs(dUV.x * sa - dUV.y * ca);
    }
};


shader adsk_Utility_MSL_UVGenerator {

output:

    Color result;

input:

    float u_scale = 1.0f;
    float v_scale = 1.0f;
    float u_offset = 0.0f;
    float v_offset = 0.0f;
    bool u_wrap = true;
    bool v_wrap = true;
    float angle = 0.0f;
    float blur = 1.0f;
    float blur_offset = 0.0f;
    int map_channel = 0
            {
                literal();
            };
    bool realworldmapsize = true;

member:


    void main()
    {
        result = float4(0.0f,0.0f,0.0f,0.0f);
        bool inst_rotated = false;
        float inst_wAngle = angle;
        float inst_ang_cos = cos(inst_wAngle);
        float inst_ang_sin = sin(inst_wAngle);
        float4x3 inst_transform = float4x3(1.0f,0.0f,0.0f,0.0f,1.0f,0.0f,0.0f,0.0f,1.0f,0.0f,0.0f,0.0f);
        if(inst_wAngle != 0.0f) {
            adskRotate(inst_transform,inst_wAngle);
            inst_rotated = true;
        } else
            inst_rotated = false;
        float2 UV = float2((state::texture_coordinate[0]).x,(state::texture_coordinate[0]).y);
        float2 dUV = float2(0.0f,0.0f);
        dUV = (abs(ddx((state::texture_coordinate[0])).xyz) + abs(ddy((state::texture_coordinate[0])).xyz)).xy;
        if(dUV.x == 0.0f && dUV.y == 0.0f)
            dUV = float2(0.002f,0.002f);
        adskTransformUV(realworldmapsize,u_offset,v_offset,u_scale,v_scale,inst_rotated,inst_transform,UV,dUV);
        dUV.x = blur_offset + blur * dUV.x;
        dUV.y = blur_offset + blur * dUV.y;
        if(!u_wrap && (UV.x < 0.0f || UV.x > 1.0f) || !v_wrap && (UV.y < 0.0f || UV.y > 1.0f)) {
            result = float4(0.0f,0.0f,0.0f,0.0f);
            return;
        }
        result.rg = UV;
        result.ba = dUV;
    }
};


shader adsk_Utility_MSL_Bitmap_X {

output:

    Color result;
    float3 result_bump;

input:

    texture2D bitmap = "brickwall.dds";
    Color uv_coords;
    float bump_amount = 0.0f;
    float u_scale = 1.0f;
    float v_scale = 1.0f;
    float u_offset = 0.0f;
    float v_offset = 0.0f;
    bool u_wrap = true;
    bool v_wrap = true;
    float angle = 0.0f;
    float blur = 1.0f;
    float blur_offset = 0.0f;
    int map_channel = 0
            {
                literal();
            };
    bool realworldmapsize = true;
    float rgb_amount = 1.0f;
    bool rgb_invert = false;

member:


    float X0000000(in Color X0000001)
    {
        float X0000002 = ((X0000001.r + X0000001.g) + X0000001.b) * 0.333333333f;
        return X0000002;
    }

    void main()
    {
        result = float4(0.0f,0.0f,0.0f,0.0f);
        result_bump = float3(0.0f,0.0f,0.0f);
        float X0000003, X0000004;
        float2 X0000005;
        if(uv_coords.r != 0.0f && uv_coords.g != 0.0f) {
            float X0000006 = uv_coords.r;
            float X0000007 = uv_coords.g;
            float2 X0000008 = float2(uv_coords.b,uv_coords.a);
            float X0000009 = X0000008.x + X0000008.y;
        } else {
            X0000003 = (state::texture_coordinate[0]).x;
            X0000004 = (state::texture_coordinate[0]).y;
            X0000005 = float2(0.0f,0.0f);
            X0000005 = (abs(ddx((state::texture_coordinate[0])).xyz) + abs(ddy((state::texture_coordinate[0])).xyz)).xy;
            X0000005 = floor(X0000005);
            if(X0000005.x == 0.0f && X0000005.y == 0.0f)
                X0000005 = float2(0.002f,0.002f);
        }
        {
            bool X0000010 = false;
            float X0000011 = angle;
            float X0000012 = cos(X0000011);
            float X0000013 = sin(X0000011);
            float4x3 X0000014 = float4x3(1.0f,0.0f,0.0f,0.0f,1.0f,0.0f,0.0f,0.0f,1.0f,0.0f,0.0f,0.0f);
            if(X0000011 != 0.0f) {
                adskRotate(X0000014,X0000011);
                X0000010 = true;
            } else
                X0000010 = false;
            float2 X0000015 = float2(X0000003,X0000004);
            adskTransformUV(realworldmapsize,u_offset,v_offset,u_scale,v_scale,X0000010,X0000014,X0000015,X0000005);
            X0000005.x = blur_offset + blur * X0000005.x;
            X0000005.y = blur_offset + blur * X0000005.y;
            if(!u_wrap && (X0000015.x < 0.0f || X0000015.x > 1.0f) || !v_wrap && (X0000015.y < 0.0f || X0000015.y > 1.0f)) {
                result = float4(0.0f,0.0f,0.0f,0.0f);
                return;
            }
            X0000003 = X0000015.x;
            X0000004 = X0000015.y;
        }
        bool X0000016 = true;
        float X0000017 = X0000005.x + X0000005.y;
        if(X0000016 && X0000017 < 0.05f) {
            Color X0000018 = float4(0.0f,0.0f,0.0f,0.0f);
            float X0000019 = 0.0f;
            float3 X0000020 = float3(0.0f,0.0f,0.0f);
            float X0000021 = 0.05f;
            X0000021 = X0000017 < 0.001f ? 0.01f : (X0000005.x + X0000005.y) / 2.0f;
            X0000018 = tex2d(bitmap,float2(X0000003,X0000004));
            X0000019 = X0000000(X0000018);
            X0000019 = X0000019 * X0000021 - X0000021 * 0.5f;
            X0000020 = state::tangent_space[0] * state::direction;
            X0000003 -= X0000020.x * X0000019;
            X0000004 -= X0000020.y * X0000019;
        }
        result = tex2d(bitmap,float2(X0000003,X0000004));
        result_bump = state::normal;
        if(bump_amount != 0.0f) {
            float X0000022 = X0000000(result);
            if(X0000005.x == 0.0f && X0000005.y == 0.0f)
                X0000005 = (abs(ddx((state::texture_coordinate[0])).xyz) + abs(ddy((state::texture_coordinate[0])).xyz)).xy;
            float3 X0000023 = state::texture_tangent_u[0];
            float3 X0000024 = state::texture_tangent_v[0];
            float3 X0000025 = float3(0.0f,0.0f,0.0f);
            float3 X0000026 = float3(0.0f,0.0f,0.0f);
            X0000025.x = X0000003;
            X0000025.y = X0000004;
            X0000025.z = 0.0f;
            Color X0000027;
            if(X0000005.x > 0.0f) {
                X0000027 = tex2d(bitmap,float2(X0000003 + X0000005.x,X0000004));
                float X0000028 = X0000000(X0000027);
                X0000025.x = -(X0000028 - X0000022) / X0000005.x;
            } else
                X0000025.x = 0.0f;
            if(X0000005.y > 0.0f) {
                X0000027 = tex2d(bitmap,float2(X0000003,X0000004 + X0000005.y));
                float X0000029 = X0000000(X0000027);
                X0000025.y = -(X0000029 - X0000022) / X0000005.y;
            } else
                X0000025.y = 0.0f;
            X0000025 *= 0.012f;
            float3 X0000030 = float3(0.0f,0.0f,0.0f);
            X0000030.x = X0000025.x * X0000023.x + X0000025.y * X0000024.x;
            X0000030.y = X0000025.x * X0000023.y + X0000025.y * X0000024.y;
            X0000030.z = X0000025.x * X0000023.z + X0000025.y * X0000024.z;
            X0000030 *= bump_amount;
            X0000030 += state::normal;
            X0000030 = normalize(X0000030);
            result_bump = X0000030;
        }
        if(rgb_amount != 1.0f)
            result.rgb *= rgb_amount;
        if(rgb_invert)
            result.rgb = 1.0f - result.rgb;
    }
};
