/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 * code generator gen_msl, build 126420.5925.3501
 *                                                                            *
 * Portions Copyright (c) 1986-2010 mental images GmbH, Berlin, Germany.      *
 ******************************************************************************/

// Option settings:


Color GetPaintBaseFactor(in Color base_color,in float diffuse_weight,in float diffuse_bias,in Color edge_color,in float edge_color_bias,in Color lit_color,in float lit_color_bias,in float iLightDotNL,in float3 iEyeDir,in float3 iNormal)
{
    Color diffuse_base = base_color;
    float factor = 0.0f;
    if(edge_color_bias > 0.0f) {
        factor = abs(dot(iNormal,iEyeDir));
        factor = pow(factor,edge_color_bias);
        diffuse_base = base_color * factor + edge_color * (1.0f - factor);
    }
    float s = 0.0f;
    float local_dot_nl = iLightDotNL;
    if(local_dot_nl < 0.0f)
        local_dot_nl = 0.0f;
    s = pow(local_dot_nl,diffuse_bias);
    Color diffuse_falloff = float4(0.0f);
    if(lit_color_bias > 0.0f) {
        factor = pow(local_dot_nl,lit_color_bias);
        factor *= abs(dot(iNormal,iEyeDir));
        diffuse_falloff = diffuse_base * (1.0f - factor) + lit_color * factor;
    } else {
        diffuse_falloff = diffuse_base;
    }
    return diffuse_falloff * s;
}

Color GetOrenNayarFactor(in float iLightDotNL,in float3 iLightDir,in Color iDiffuseColor,in float iRoughness,in float3 iDir,in float3 iNormal)
{
    float vDot = dot(iNormal,iDir);
    float lDot = iLightDotNL;
    float3 dir = iDir;
    if(vDot < 0.0f) {
        vDot = -vDot;
        dir = -dir;
    }
    float onCoeff = 0.0f;
    float onCoeffX = 0.0f;
    {
        float acLDot = 0.0f;
        float acVDot = 0.0f;
        if(lDot < 0.9999f)
            acLDot = acos(lDot);
        if(acLDot < -3.14159265358979323846f * 0.49f)
            acLDot = -3.14159265358979323846f * 0.49f;
        if(acLDot > 1.53938f)
            acLDot = 1.53938f;
        if(vDot < 0.9999f)
            acVDot = acos(vDot);
        if(acLDot < acVDot) {
            float switchme = acVDot;
            acVDot = acLDot;
            acLDot = switchme;
        }
        float3 vTerm = dir - iNormal * vDot;
        float3 lTerm = iLightDir - iNormal * lDot;
        float gTerm = length(vTerm) * length(lTerm);
        float gamma = 1.0f;
        if(abs(gTerm) < 0.0001f)
            gamma = 1.0f;
        else
            gamma = dot(vTerm,lTerm) / gTerm;
        float rough_square = iRoughness * iRoughness;
        float C2term = rough_square / (rough_square + 0.09f);
        float Cx = (2.0f * (gamma >= 0.0f ? -acVDot : acVDot)) / 3.14159265358979323846f;
        float C1 = 1.0f - 0.5f * (rough_square / (rough_square + 0.33f));
        float C2 = (0.45f * C2term) * (sin(acLDot) - pow(Cx,3.0f));
        float C3 = (0.125f * C2term) * pow((((4.0f * acLDot) * acVDot) / 9.869605f),2.0f);
        float A = (C2 * gamma) * tan(acVDot);
        float B = (C3 * (1.0f - abs(gamma))) * tan(((acLDot + acVDot) / 2.0f));
        onCoeff = (C1 + A) + B;
        Cx = (2.0f * acVDot) / 3.14159265358979323846f;
        onCoeffX = (0.17f * (rough_square / (rough_square + 0.13f))) * (1.0f - (gamma * Cx) * Cx);
    }
    Color oColor = onCoeff * iDiffuseColor;
    oColor += (onCoeffX * iDiffuseColor) * iDiffuseColor;
    return min(float4(1.0f,1.0f,1.0f,1.0f),oColor);
}

void GetONayarSimplexFactor(in float3 n,in float3 l,float3 v,in float iRoughness,in float vDot,in float lDot,out float onCoeff,out float onCoeffX)
{
    float acVDot = acos(vDot);
    float acLDot = acos(lDot);
    float3 vTerm = v - n * vDot;
    float3 lTerm = l - n * lDot;
    float gTerm = length(vTerm) * length(lTerm);
    float gamma = 1.0f;
    if(abs(gTerm) < 0.0001f)
        gamma = 1.0f;
    else
        gamma = dot(vTerm,lTerm) / gTerm;
    float rough_sq = iRoughness * iRoughness;
    float Ct = rough_sq / (rough_sq + 0.09f);
    float A = 1.0f - 0.5f * (rough_sq / (rough_sq + 0.57f));
    float B = 0.45f * Ct;
    float alpha = max(acVDot,acLDot);
    float beta = min(acVDot,acLDot);
    float C = sin(alpha) * tan(beta);
    onCoeff = A + (B * max(0.0f,gamma)) * C;
    float Cx = (2.0f * acVDot) / 3.14159265358979323846f;
    onCoeffX = (0.17f * Ct) * (1.0f - (gamma * Cx) * Cx);
    return;
}

float adsk_aux_hermite_step(in float x0,in float x1,in float v)
{
    float f;
    if(v <= x0)
        return 0.0f;
    if(v >= x1)
        return 1.0f;
    f = (v - x0) / (x1 - x0);
    return (f * f) * (3.0f - 2.0f * f);
}

float GetGlossyCoeff(in float glossiness)
{
    return pow(2.0f,glossiness * 8.0f);
}

float GetPhongSpecularFactor(in float3 iLightDir,in float3 iEyeDir,in float3 iNormal,in float iGlossy,in float iAuxFactor,in bool iAuxGlazed,in bool bypass_glossy_coeff)
{
    float res = 0.0f;
    float glossiness = iGlossy;
    if(!bypass_glossy_coeff)
        glossiness = GetGlossyCoeff(iGlossy);
    float3 half_ = iLightDir - iEyeDir;
    float phi = dot(half_,iNormal);
    phi *= phi / dot(half_,half_);
    if(phi > 0.0f)
        res = exp((log(phi) * 0.5f) * glossiness);
    if(iAuxGlazed)
        res = adsk_aux_hermite_step(0.5f,0.8f,res);
    if(iAuxFactor > 0.0f)
        res *= iAuxFactor * iGlossy;
    return res;
}

float GetSpecularFactor(in float3 dir,in float3 light_dir,in float3 norm,in float3 aniso_u,in float3 aniso_v,in float glossy_factor,in float aniso_factor)
{
    float minin = 0.0001f;
    float dotNL = dot(light_dir,norm);
    float dotEye = -dot(dir,norm);
    if(dotEye * dotNL < minin)
        return 0.0f;
    else {
        float glossy_pow = glossy_factor * glossy_factor;
        float aniso_pow = aniso_factor * aniso_factor;
        float3 half_vector = light_dir - dir;
        half_vector = normalize(half_vector);
        float dotHN = dot(half_vector,norm);
        dotHN *= dotHN;
        if(dotHN > 1.0f)
            dotHN = 1.0f;
        float dotAU = dot(half_vector,aniso_u);
        dotAU *= dotAU;
        float dotAV = dot(half_vector,aniso_v);
        dotAV *= dotAV;
        if(dotHN < minin * (dotAU * glossy_pow + dotAV * aniso_pow))
            return 0.0f;
        else {
            float aniso_fx = -(dotAU * glossy_pow + dotAV * aniso_pow) / dotHN;
            return ((exp(aniso_fx) * glossy_factor) * aniso_factor) / ((sqrt((dotEye * dotNL)) * 4.0f) * 3.14159265358979323846f);
        }
    }
}

void GetIsotropyFactor(out float3 oAnisoU,out float3 oAnisoV,in float3 iNormal)
{
    float3 hVector = float3(0.0f,0.0f,1.0f);
    hVector = float3x3(get_transform("object","internal")) * hVector;
    hVector = normalize(hVector);
    float hDot = dot(iNormal,hVector);
    if(abs(hDot) > 0.999f) {
        hVector = float3(0.0f,1.0f,0.0f);
        hVector = float3x3(get_transform("object","internal")) * hVector;
        hVector = normalize(hVector);
        hDot = dot(iNormal,hVector);
        if(abs(hDot) > 0.999f) {
            hVector = float3(1.0f,0.0f,0.0f);
            hVector = float3x3(get_transform("object","internal")) * hVector;
            hVector = normalize(hVector);
            hDot = dot(iNormal,hVector);
        }
    }
    hVector -= iNormal * hDot;
    hVector = normalize(hVector);
    oAnisoV = hVector;
    oAnisoU = cross(oAnisoV,iNormal);
}

void GetAnisotropyFactor(out float3 oAnisoU,out float3 oAnisoV,in float iAnisotropy,in float iAnisoRot,in int iAnisoChannel,in float3 iNormal)
{
    GetIsotropyFactor(oAnisoU,oAnisoV,iNormal);
    if(iAnisotropy != 1.0f) {
        float aniso_cross_vec_dot = dot(iNormal,oAnisoU);
        oAnisoU -= iNormal * aniso_cross_vec_dot;
        oAnisoU = normalize(oAnisoU);
        aniso_cross_vec_dot = dot(iNormal,oAnisoV);
        oAnisoV -= iNormal * aniso_cross_vec_dot;
        oAnisoV = normalize(oAnisoV);
        if(iAnisoRot != 0.0f) {
            float aniso_rot = (iAnisoRot * 3.14159265358979323846f) * 2.0f;
            float aniso_rot_cos = cos(aniso_rot);
            float aniso_rot_sin = sin(aniso_rot);
            float3 aniso_interp = aniso_rot_cos * oAnisoU + aniso_rot_sin * oAnisoV;
            oAnisoV = -aniso_rot_sin * oAnisoU + aniso_rot_cos * oAnisoV;
            oAnisoU = aniso_interp;
        }
    }
}

float FresnelFactor(in float ior_in,in float ior_out,in float t1,in float t2)
{
    float d_p;
    float d_o;
    float r_p;
    float r_o;
    if(ior_in == ior_out)
        return 0.0f;
    else {
        d_p = ior_in * t2 + ior_out * t1;
        if(d_p == 0.0f)
            r_p = 1.0f;
        else
            r_p = (ior_in * t2 - ior_out * t1) / d_p;
        d_o = ior_in * t1 + ior_out * t2;
        if(d_o == 0.0f)
            r_o = 1.0f;
        else
            r_o = (ior_in * t1 - ior_out * t2) / d_o;
        return 0.5f * (r_p * r_p + r_o * r_o);
    }
}

float GetFresnelFactor(in float dot_nd,in float ior_in,in float ior_out)
{
    float ior;
    float theta;
    ior = ior_in / ior_out;
    theta = 1.0f - (ior * ior) * (1.0f - dot_nd * dot_nd);
    if(theta > 0.0f)
        return FresnelFactor(ior_in,ior_out,dot_nd,-sqrt(theta));
    else
        return 1.0f;
}

Color GetRefractionFactor(in float3 p,in float3 d,in float3 n,in float iorx)
{
    Color rColor = float4(0.0f);
    float3 refr_dir = d;
    refr_dir = refract(d,n,1.0f / iorx);
    if((refr_dir.x == 0.0f && refr_dir.y == 0.0f) && refr_dir.z == 0.0f)
        refr_dir = reflect(d,n);
    Ray rayx = Ray(p,refr_dir);
    Ray ray_dx, ray_dy;
    Trace_options trace_options;
    trace_options.set_ray_type("environment");
    trace(rayx,ray_dx,ray_dy,trace_options,"result",rColor);
    return rColor;
}

Color GetReflectionFactor(in float3 p,in float3 d,in float3 n)
{
    Color rColor = float4(0.0f);
    float3 refl_dir = reflect(d,n);
    Ray rayx = Ray(p,refl_dir);
    Ray ray_dx, ray_dy;
    Trace_options trace_options;
    trace_options.set_ray_type("environment");
    trace(rayx,ray_dx,ray_dy,trace_options,"result",rColor);
    return rColor;
}

float SimpleFalloff(float3 direction,float3 normal,float amount)
{
    float f = saturate(dot(-direction,normal));
    f = 1.0f - pow(f,1.0f / amount);
    return f;
}

Color GetOpacityFactor(in float3 p,in float3 d)
{
    Color rColor = float4(0.0f);
    Ray rayx = Ray(p,d);
    Ray ray_dx, ray_dy;
    Trace_options trace_options;
    trace_options.set_ray_type("environment");
    trace(rayx,ray_dx,ray_dy,trace_options,"result",rColor);
    return rColor;
}

void TransformBumpVector(in int b_mode,in float3 b_vector,inout float3 b_transform)
{
    if((b_vector.x == 0.0f && b_vector.y == 0.0f) && b_vector.z == 0.0f)
        return;
    switch(b_mode) {
    case 1:
    case 5:
        {
            break;
        }
    case 2:
    case 6:
        {
            b_vector = transform_vector("world","internal",b_vector);
            break;
        }
    case 3:
    case 7:
        {
            b_vector = transform_vector("object","internal",b_vector);
            break;
        }
    case 4:
    case 8:
        {
            b_vector = transform_vector("camera","internal",b_vector);
            break;
        }
    }
    if(b_mode <= 4)
        b_transform += b_vector;
    else
        b_transform = b_vector;
    b_transform = normalize(b_transform);
}

shader adsk_Component_MSL_BRDFfactor {

output:

    float result;

input:

    float brdf_0_degree_refl = 0.2f
            {
                display_name("BRDF 0 Reflection");
                hard_range(0.0f,1.0f);
            };
    float brdf_90_degree_refl = 1.0f
            {
                display_name("BRDF 90 Reflection");
                hard_range(0.0f,1.0f);
            };
    float brdf_curve = 5.0f
            {
                display_name("BRDF Curve Shape ");
                soft_range(0.0f,10.0f);
            };
    float3 iNormal = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("normal",0);
            };

member:


    void main()
    {
        result = 0.0f;
        float X0000000 = pow(1.0f - abs(dot(state::direction,iNormal)),brdf_curve);
        result = brdf_90_degree_refl * X0000000 + brdf_0_degree_refl * (1.0f - X0000000);
    }
};


shader adsk_Component_MSL_EnergyConservation {

output:

    Color oDiffuse;
    Color oReflect;
    Color oRefract;

input:

    float diffuse_weight = 1.0f
            {
                display_name("Diffuse Level");
                hard_range(0.0f,1.0f);
            };
    Color diffuse = float4(0.5f,0.5f,0.5f,1.0f)
            {
                display_name("Diffuse Color");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    float reflectivity = 0.6f
            {
                display_name("Reflectivity");
                hard_range(0.0f,1.0f);
            };
    Color refl_color = float4(1.0f,1.0f,1.0f,1.0f)
            {
                display_name("Reflection Color");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    float refl_balance = 1.0f
            {
                display_name("Reflection Balance");
                hard_range(0.0f,1.0f);
            };
    bool refl_hl_only = false
            {
                display_name("Highlights Only");
            };
    float transparency = 0.0f
            {
                display_name("Transparency");
                hard_range(0.0f,1.0f);
            };
    Color refr_color = float4(1.0f,1.0f,1.0f,1.0f)
            {
                display_name("Transparency Color");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };

member:


    void main()
    {
        oDiffuse = float4(0.0f);
        oReflect = float4(0.0f);
        oRefract = float4(0.0f);
        Color X0000001 = float4(0.212671f,0.715160f,0.072169f,0.0f);
        Color X0000002 = diffuse;
        float X0000003 = diffuse_weight;
        float X0000004 = reflectivity;
        Color X0000005 = refl_color;
        bool X0000006 = refl_hl_only;
        float X0000007 = refl_balance;
        float X0000008 = transparency;
        Color X0000009 = refr_color;
        X0000002.a = (X0000002.r * X0000001.r + X0000002.g * X0000001.g) + X0000002.b * X0000001.b;
        X0000005.a = (X0000005.r * X0000001.r + X0000005.g * X0000001.g) + X0000005.b * X0000001.b;
        X0000009.a = (X0000009.r * X0000001.r + X0000009.g * X0000001.g) + X0000009.b * X0000001.b;
        X0000005 *= X0000004;
        X0000003 *= 1.0f - X0000009.a * X0000008;
        X0000008 *= 1.0f - X0000005.a;
        X0000003 *= 1.0f - X0000005.a;
        if(X0000006)
            X0000003 += X0000005.a;
        X0000002 *= X0000003;
        X0000009 *= X0000008;
        oDiffuse = X0000002;
        oReflect = X0000005;
        oRefract = X0000009;
    }
};


shader adsk_Component_MSL_Irradiance {

output:

    Color oIrradiance;

input:

    Color iDiffuse = float4(0.5f,0.5f,0.5f,1.0f)
            {
                display_name("Diffuse Color");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };

member:


    void main()
    {
        oIrradiance = float4(0.0f);
        Irradiance_options X0000010 = Irradiance_options();
        float X0000011 = dot(iDiffuse.rgb,float3(0.333333f));
        X0000010.set_importance(X0000011);
        oIrradiance = (iDiffuse * irradiance(X0000010)) / 3.14159265358979323846f;
    }
};


shader adsk_Component_MSL_LightParser {

output:

    float oLightDotNL;
    float3 oLightDirection;
    float oLightContribution;

member:


    void main()
    {
        oLightDotNL = 0.0f;
        oLightDirection = float3(0.0f);
        oLightContribution = 0.0f;
        Light_iterator X0000012;
        foreach(X0000012) {
        }
    }
};


shader adsk_Component_MSL_PaintBase {

output:

    Color result;

input:

    Color base_color = float4(0.8f,0.0f,0.0f,1.0f)
            {
                display_name("Base Color");
                hard_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    float diffuse_weight = 1.0f
            {
                display_name("Base Weight");
                hard_range(0.0f,1.0f);
            };
    float diffuse_bias = 1.5f
            {
                display_name("Base Bias");
                hard_range(0.0f,4.0f);
            };
    Color edge_color = float4(0.0f,0.0f,0.0f,1.0f)
            {
                display_name("Edge Color");
                hard_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    float edge_color_bias = 1.0f
            {
                display_name("Edge Bias");
                hard_range(0.0f,10.0f);
            };
    Color lit_color = float4(0.6f,0.0f,0.2f,1.0f)
            {
                display_name("Lit Color");
                hard_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    float lit_color_bias = 8.0f
            {
                display_name("Lit Bias");
                hard_range(0.0f,20.0f);
            };
    float iLightDotNL = 0.0f
            {
                hidden();
            };
    float3 iEyeDir = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("direction",0);
            };
    float3 iNormal = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("normal",0);
            };

member:


    void main()
    {
        result = float4(0.0f);
        result = GetPaintBaseFactor(base_color,diffuse_weight,diffuse_bias,edge_color,edge_color_bias,lit_color,lit_color_bias,iLightDotNL,iEyeDir,iNormal);
    }
};


shader adsk_Component_MSL_OrenNayar {

output:

    Color result;

input:

    Color iDiffuseColor = float4(0.7f)
            {
                display_name("Diffuse Color");
                hard_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    float iRoughness = .5f
            {
                display_name("Roughness");
                hard_range(0.0f,1.0f);
            };
    float iLightDotNL = 0.0f
            {
                hidden();
            };
    float3 iLightDir = float3(0.0f)
            {
                hidden();
            };
    float3 iEyeDir = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("direction",0);
            };
    float3 iNormal = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("normal",0);
            };

member:


    void main()
    {
        result = float4(0.0f);
        result = GetOrenNayarFactor(iLightDotNL,iLightDir,iDiffuseColor,iRoughness,iEyeDir,iNormal);
    }
};


shader adsk_Component_MSL_OrenNayarSimplex {

output:

    Color result;

input:

    Color iDiffuseColor = float4(0.7f)
            {
                display_name("Diffuse Color");
                hard_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    float iRoughness = .5f
            {
                display_name("Roughness");
                hard_range(0.0f,1.0f);
            };
    float iLightDotNL = 0.0f
            {
                hidden();
            };
    float3 iLightDir = float3(0.0f)
            {
                hidden();
            };
    float3 iEyeDir = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("direction",0);
            };
    float3 iNormal = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("normal",0);
            };

member:


    void main()
    {
        result = float4(0.0f);
        float X0000013 = dot(iNormal,iEyeDir);
        float3 X0000014 = iEyeDir;
        if(X0000013 < 0.0f) {
            X0000013 = -X0000013;
            X0000014 = -X0000014;
        }
        float X0000015 = 0.0f;
        float X0000016 = 0.0f;
        GetONayarSimplexFactor(iNormal,iLightDir,X0000014,iRoughness,X0000013,iLightDotNL,X0000015,X0000016);
        Color X0000017 = X0000015 * iDiffuseColor;
        X0000017 += (X0000016 * iDiffuseColor) * iDiffuseColor;
        result = min(float4(1.0f,1.0f,1.0f,1.0f),X0000017);
    }
};


shader adsk_Component_MSL_PhongSpecular {

output:

    float result;

input:

    float iGlossy = 1.0f
            {
                display_name("Glossiness");
                soft_range(0.0f,1.0f);
            };
    float iAuxFactor = 8.0f
            {
                display_name("Glossy Factor");
                soft_range(0.0f,20.0f);
            };
    bool iAuxGlazed = false
            {
                display_name("Glazing");
            };
    Shader iAnotherSpec;
    bool bypass_glossy_factor = false
            {
                display_name("Glazing");
            };
    float3 iLightDir = float3(0.0f)
            {
                hidden();
            };
    float3 iEyeDir = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("direction",0);
            };
    float3 iNormal = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("normal",0);
            };

member:


    void main()
    {
        result = 0.0f;
        result = GetPhongSpecularFactor(iLightDir,iEyeDir,iNormal,iGlossy,iAuxFactor,iAuxGlazed,bypass_glossy_factor);
        float X0000018 = 0.0f;
        if(iAnotherSpec.call("input","iLightDir",iLightDir,"input","iEyeDir",iEyeDir,"input","iNormal",iNormal,"output","result",X0000018)) {
            result += X0000018;
        }
    }
};


shader adsk_Component_MSL_GlossySpecular {

output:

    float result;

input:

    float iGlossy = 1.0f
            {
                display_name("Glossiness");
                hard_range(0.0f,1.0f);
            };
    float iAnisotropy = 1.0f
            {
                display_name("Anisotropy");
                hard_range(0.0f,1.0f);
            };
    float3 iAnisoU = float3(0.0f)
            {
                display_name("AnisoU");
            };
    float3 iAnisoV = float3(0.0f)
            {
                display_name("AnisoV");
            };
    float iAuxFactor = 1.0f
            {
                display_name("Glossy Factor");
                hard_range(0.0f,1.0f);
            };
    Shader iAnotherSpec;
    float3 iLightDir = float3(0.0f,0.0f,0.0f)
            {
                hidden();
            };
    float3 iEyeDir = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("direction",0);
            };
    float3 iNormal = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("normal",0);
            };

member:


    void main()
    {
        result = 0.0f;
        float3 X0000019 = float3(0.0f);
        float3 X0000020 = float3(0.0f);
        if(!all(iAnisoU) && !all(iAnisoV)) {
            GetIsotropyFactor(X0000019,X0000020,state::normal);
        } else {
            X0000019 = iAnisoU;
            X0000020 = iAnisoV;
        }
        float X0000021 = GetGlossyCoeff(iGlossy);
        float X0000022 = iAnisotropy * X0000021;
        if(X0000021 >= 80.0f)
            X0000021 = 80.0f + sqrt((X0000021 - 80.0f));
        if(X0000022 >= 80.0f)
            X0000022 = 80.0f + sqrt((X0000022 - 80.0f));
        result = (GetSpecularFactor(iEyeDir,iLightDir,iNormal,X0000019,X0000020,X0000021,X0000022) * 0.5f + GetSpecularFactor(iEyeDir,iLightDir,iNormal,X0000019,X0000020,X0000021 / 2.0f,X0000022 / 2.0f)) + GetSpecularFactor(iEyeDir,iLightDir,iNormal,X0000019,X0000020,(X0000021 / 4.0f),(X0000022 / 4.0f)) * 1.5f;
        result *= iAuxFactor;
        float X0000023 = 0.0f;
        if(iAnotherSpec.call("input","iLightDir",iLightDir,"input","iEyeDir",iEyeDir,"input","iNormal",iNormal,"output","result",X0000023)) {
            result += X0000023;
        }
    }
};


shader adsk_Component_MSL_Anisotropy {

output:

    float3 oAnisoU;
    float3 oAnisoV;

input:

    float iAnisotropy = 1.0f;
    float iAnisoRot = 1.0f;
    int iAnisoChannel = -1;
    float3 iNormal = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("normal",0);
            };

member:


    void main()
    {
        oAnisoU = float3(0.0f);
        oAnisoV = float3(0.0f);
        GetAnisotropyFactor(oAnisoU,oAnisoV,iAnisotropy,iAnisoRot,iAnisoChannel,iNormal);
    }
};


shader adsk_Component_MSL_Fresnel {

output:

    float result;

input:

    float dot_nd = 0.0f
            {
                display_name("Dot NDir");
                hard_range(0.0f,1.0f);
            };
    float ior_in = 1.0f
            {
                display_name("IOR In");
                hard_range(0.1f,10.0f);
            };
    float ior_out = 1.55f
            {
                display_name("IOR Out");
                hard_range(0.1f,10.0f);
            };

member:


    void main()
    {
        result = 0.0f;
        result = GetFresnelFactor(dot_nd,ior_in,ior_out);
    }
};


shader adsk_Component_MSL_Transparency {

output:

    float result;

input:

    Color iRefractResult = float4(1.0f,1.0f,1.0f,1.0f)
            {
                display_name("Transparency Result");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    Color iRefractColor = float4(1.0f,1.0f,1.0f,1.0f)
            {
                display_name("Transparency Color");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    bool isOpacity = false
            {
                display_name("Is Opacity");
            };

member:


    void main()
    {
        result = 0.0f;
        result = iRefractResult.a * iRefractColor.a + (1.0f - iRefractColor.a);
        if(isOpacity)
            result = 1.0f - result;
    }
};


shader adsk_Component_MSL_Refraction {

output:

    Color result;
    float transparency;
    Color translucency;
    Color refraction;

input:

    float iTransparency = 0.0f
            {
                display_name("Transparency");
                hard_range(0.0f,1.0f);
            };
    float iEnConsFactor = 0.0f
            {
                display_name("Energy Conservation Factor");
                hard_range(0.0f,1.0f);
            };
    Color iRefr_color = float4(1.0f,1.0f,1.0f,1.0f)
            {
                display_name("Transparency Color");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    float iRefr_ior = 1.4f
            {
                hard_range(0.1f,10.0f);
                display_name("Transparency IOR");
            };
    float iTrans_weight = 0.0f
            {
                display_name("Translucency");
                hard_range(0.0f,1.0f);
            };
    Color iTrans_color = float4(0.7f,0.6f,0.5f,1.0f)
            {
                display_name("Translucency Color");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    bool iIsAlphaTransp = true
            {
                display_name("Alpha Tranparency");
            };
    float3 iPosition = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("position",0);
            };
    float3 iDirection = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("direction",0);
            };
    float3 iNormal = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("normal",0);
            };

member:


    void X0000024(in float3 X0000025,in float3 X0000026,in float3 X0000027,in float X0000028,out Color X0000029)
    {
        X0000029 = float4(1.0f);
        if(X0000028 == 0.0f)
            return;
        float3 X0000030 = X0000026;
        X0000030 = refract(X0000026,X0000027,1.0f / X0000028);
        Ray X0000031 = Ray(X0000025,X0000030);
        Ray X0000032, X0000033;
        Trace_options X0000034;
        X0000034.set_ray_type("environment");
        trace(X0000031,X0000032,X0000033,X0000034,"result",X0000029);
    }

    void main()
    {
        result = float4(0.0f);
        transparency = 0.0f;
        translucency = float4(0.0f);
        refraction = float4(0.0f);
        Color X0000035 = iRefr_color;
        Color X0000036 = float4(0.212671f,0.715160f,0.072169f,0.0f);
        X0000035.a = (iRefr_color.r * X0000036.r + iRefr_color.g * X0000036.g) + iRefr_color.b * X0000036.b;
        float X0000037 = X0000035.a;
        transparency = iTransparency;
        if(iEnConsFactor != 0.0f)
            transparency *= 1.0f - iEnConsFactor;
        if(iTrans_weight != 0.0f) {
            transparency *= 1.0f - iTrans_weight;
            float X0000038 = SimpleFalloff(iDirection,iNormal,1.0f);
            float3 X0000039 = lerp(iTrans_color.rgb,float3(1.0f,1.0f,1.0f),X0000038);
            translucency.rgb = X0000039.xyz * iTrans_weight;
        }
        X0000035 *= transparency;
        if(X0000035.a > 0.0f) {
            X0000024(iPosition,iDirection,iNormal,iIsAlphaTransp ? 0.0f : iRefr_ior,refraction);
            refraction.rgb *= X0000035.rgb;
            refraction.a = X0000037;
        }
        result = refraction;
    }
};


shader adsk_Component_MSL_Reflection {

output:

    Color result;

input:

    Color iRefl_color = float4(1.0f,1.0f,1.0f,1.0f)
            {
                display_name("Reflection Color");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    float iRefl_factor = 0.0f
            {
                display_name("Reflection Factor");
                hard_range(0.0f,1.0f);
            };
    float3 iPosition = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("position",0);
            };
    float3 iDirection = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("direction",0);
            };
    float3 iNormal = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("normal",0);
            };

member:


    void X0000040(in float3 X0000041,in float3 X0000042,in float3 X0000043,inout Color X0000044)
    {
        X0000044 = float4(0.0f);
        float3 X0000045 = reflect(X0000042,X0000043);
        Ray X0000046 = Ray(X0000041,X0000045);
        Ray X0000047, X0000048;
        Trace_options X0000049;
        X0000049.set_ray_type("environment");
        trace(X0000046,X0000047,X0000048,X0000049,"result",X0000044);
        X0000044.a += 1.0f;
    }

    void main()
    {
        result = float4(0.0f);
        X0000040(iPosition,iDirection,iNormal,result);
        result.rgb *= iRefl_color.rgb;
        result.rgb *= iRefl_factor.xxx;
    }
};


shader adsk_Component_MSL_FlakeSupport {

output:

    float result;

input:

    float3 iLightDir;
    float3 iEyeDir = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("direction",0);
            };
    float3 iNormal = float3(0.0f,0.0f,0.0f)
            {
                hidden();
                default_to_state("normal",0);
            };
    Shader iFlakeShader;
    float iFlakeWeight = 1.0f;
    float iFlakeExp = 45.0f;
    float iFlakeDecay = 45.0f;
    float iAuxSpecExp = 60.0f;
    float iAuxFactor = 1.0f;

member:


    void main()
    {
        result = 0.0f;
        if(iFlakeWeight > 0.0f) {
            Color X0000050 = float4(1.0f);
            float3 X0000051 = float3(0.0f);
            float X0000052 = 0.0f;
            float X0000053 = iFlakeWeight;
            {
                if(!iFlakeShader.call("input","flake_color",X0000050,"output","normal_result",X0000051))
                    if(!iFlakeShader.call("input","bump_amount",.1f,"output","result_bump",X0000051))
                        return;
                float3 X0000054 = float3(0.0f,0.0f,0.0f);
                float3 X0000055 = float3(0.0f,0.0f,0.0f);
                X0000054 = transform_point("internal","object",state::position);
                X0000055 = transform_point("internal","object",state::origin);
                X0000055 -= X0000054;
                X0000052 = dot(X0000055,X0000055);
                float3 X0000056 = state::normal;
                if(any(X0000051) == false)
                    X0000051 = X0000056;
                float X0000057 = 0.0f;
                if(iFlakeDecay > 0.0f)
                    X0000057 = sqrt(X0000052) / iFlakeDecay;
                X0000052 = 1.0f - X0000057;
                if(X0000052 < 0.0f)
                    X0000052 = 0.0f;
                X0000053 *= 1.0f - exp(-X0000052);
                X0000052 = X0000052 * iFlakeExp + (1.0f - X0000052) * iAuxSpecExp;
            }
            if(X0000053 > 0.0f) {
                float X0000058 = 0.0f;
                float3 X0000059 = iLightDir;
                X0000059 -= iEyeDir;
                X0000059 = normalize(X0000059);
                X0000058 = dot(X0000051,X0000059);
                if(X0000058 > 0.0f) {
                    if(X0000052 < 0.0f)
                        X0000052 = 0.0f;
                    X0000058 = pow(X0000058,X0000052) * iAuxFactor;
                    result = X0000058 * X0000053;
                }
            }
        }
    }
};


shader adsk_Component_MSL_BumpCombiner {

output:

    Color result;

input:

    Shader iShading;
    int iMode = 0;
    float3 iNormal = float3(0.0f,0.0f,0.0f)
            {
                default_to_state("normal",0);
            };

member:


    void main()
    {
        result = float4(0.0f);
        iShading.call("input","iNormal",iNormal,"output","result",result);
    }
};


shader adsk_Component_MSL_BumpCombiner_X {

output:

    Color result;
    Color oDiffuse;
    Color oSpecular;
    Color oReflection;
    Color oTransparent;

input:

    Shader iDiffuse;
    Shader iSpecular;
    Shader iReflection;
    Shader iTransparent;
    float3 iNormal = float3(0.0f,0.0f,0.0f)
            {
                default_to_state("normal",0);
            };

member:


    void main()
    {
        result = float4(0.0f);
        oDiffuse = float4(0.0f);
        oSpecular = float4(0.0f);
        oReflection = float4(0.0f);
        oTransparent = float4(0.0f);
        iDiffuse.call("input","iNormal",iNormal,"output","result",oDiffuse);
        iSpecular.call("input","iNormal",iNormal,"output","result",oSpecular);
        iReflection.call("input","iNormal",iNormal,"output","result",oReflection);
        iTransparent.call("input","iNormal",iNormal,"output","result",oTransparent);
    }
};


shader adsk_Component_MSL_Bump {

output:

    float3 bump_global;
    float3 bump_local;

input:

    float3 standard_bump = float3(0.0f,0.0f,0.0f)
            {
                display_name("Global bump");
            };
    float3 overall_bump = float3(0.0f,0.0f,0.0f)
            {
                display_name("Local bump");
            };
    bool no_diffuse_bump = false
            {
                display_name("No bump on diffuse");
            };

member:


    void main()
    {
        bump_global = float3(0.0f);
        bump_local = float3(0.0f);
        float3 X0000060 = state::normal;
        TransformBumpVector(1,standard_bump,X0000060);
        bump_global = (bump_local = X0000060);
        TransformBumpVector(1,overall_bump,X0000060);
        if(!no_diffuse_bump) {
            bump_global = (bump_local = X0000060);
        } else {
            bump_local = X0000060;
        }
    }
};
