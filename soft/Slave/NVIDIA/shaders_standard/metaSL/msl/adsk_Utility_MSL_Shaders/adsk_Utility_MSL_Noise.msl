/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 * code generator gen_msl, build 126420.5925.3501
 *                                                                            *
 * Portions Copyright (c) 1986-2010 mental images GmbH, Berlin, Germany.      *
 ******************************************************************************/

// Option settings:


float3 adsk_Utility_MSL_Fnc__fade(float3 X0000000)
{
    return ((X0000000 * X0000000) * X0000000) * (X0000000 * (X0000000 * 6.0f - 15.0f) + 10.0f);
}

float adsk_Utility_MSL_Fnc__perm(texture1D X0000001,float X0000002)
{
    return tex1d(X0000001,X0000002).x;
}

float adsk_Utility_MSL_Fnc__grad(texture1D X0000003,float X0000004,float3 X0000005)
{
    float3 X0000006 = tex1d(X0000003,X0000004).xyz;
    X0000006 = X0000006 * 2.0f - 1.0f;
    X0000006 *= floor(abs(X0000006));
    return dot(X0000006,X0000005);
}

float adsk_Utility_MSL_Fnc___noise(float3 X0000007,texture1D X0000008,texture1D X0000009)
{
    float3 X0000010;
    X0000010 = fmod(floor(X0000007),256.0f);
    X0000007 -= floor(X0000007);
    float3 X0000011 = adsk_Utility_MSL_Fnc__fade(X0000007);
    X0000010 = X0000010 / 255.0f;
    float X0000012 = 0.003922f;
    float X0000013 = adsk_Utility_MSL_Fnc__perm(X0000008,X0000010.x) + X0000010.y;
    float4 X0000014;
    X0000014.x = adsk_Utility_MSL_Fnc__perm(X0000008,X0000013) + X0000010.z;
    X0000014.y = adsk_Utility_MSL_Fnc__perm(X0000008,(X0000013 + X0000012)) + X0000010.z;
    float X0000015 = adsk_Utility_MSL_Fnc__perm(X0000008,(X0000010.x + X0000012)) + X0000010.y;
    X0000014.z = adsk_Utility_MSL_Fnc__perm(X0000008,X0000015) + X0000010.z;
    X0000014.w = adsk_Utility_MSL_Fnc__perm(X0000008,(X0000015 + X0000012)) + X0000010.z;
    return lerp(lerp(lerp(adsk_Utility_MSL_Fnc__grad(X0000009,adsk_Utility_MSL_Fnc__perm(X0000008,X0000014.x),X0000007),adsk_Utility_MSL_Fnc__grad(X0000009,adsk_Utility_MSL_Fnc__perm(X0000008,X0000014.z),X0000007 + float3(-1.0f,0.0f,0.0f)),X0000011.x),lerp(adsk_Utility_MSL_Fnc__grad(X0000009,adsk_Utility_MSL_Fnc__perm(X0000008,X0000014.y),X0000007 + float3(0.0f,-1.0f,0.0f)),adsk_Utility_MSL_Fnc__grad(X0000009,adsk_Utility_MSL_Fnc__perm(X0000008,X0000014.w),X0000007 + float3(-1.0f,-1.0f,0.0f)),X0000011.x),X0000011.y),lerp(lerp(adsk_Utility_MSL_Fnc__grad(X0000009,adsk_Utility_MSL_Fnc__perm(X0000008,X0000014.x + X0000012),X0000007 + float3(0.0f,0.0f,-1.0f)),adsk_Utility_MSL_Fnc__grad(X0000009,adsk_Utility_MSL_Fnc__perm(X0000008,X0000014.z + X0000012),X0000007 + float3(-1.0f,0.0f,-1.0f)),X0000011.x),lerp(adsk_Utility_MSL_Fnc__grad(X0000009,adsk_Utility_MSL_Fnc__perm(X0000008,X0000014.y + X0000012),X0000007 + float3(0.0f,-1.0f,-1.0f)),adsk_Utility_MSL_Fnc__grad(X0000009,adsk_Utility_MSL_Fnc__perm(X0000008,X0000014.w + X0000012),X0000007 + float3(-1.0f,-1.0f,-1.0f)),X0000011.x),X0000011.y),X0000011.z);
}

float adsk_Utility_MSL_Noise_Octaves(float3 X0000016,texture1D X0000017,texture1D X0000018,int X0000019,float X0000020,float X0000021,float X0000022,float X0000023)
{
    float X0000024 = 0.0f;
    for(int X0000025 = 0; X0000025 < X0000019; X0000025++) {
        X0000024 += adsk_Utility_MSL_Fnc___noise((X0000016 * X0000022),X0000017,X0000018) * X0000023;
        X0000022 *= X0000020;
        X0000023 *= X0000021;
    }
    return X0000024;
}

shader adsk_Utility_MSL_NoiseGenerator {

output:

    Color result;
    Color result_bump;

input:

    texture1D noise_perm_texture = "noise_perm.dds"
            {
                disable_filtering();
            };
    texture1D noise_grad_texture = "noise_grad.dds"
            {
                disable_filtering();
            };
    float3 noise_position = float3(0.0f,0.0f,0.0f)
            {
                display_name("Noise Position");
                default_to_state("position",0);
            };
    float3 noise_scale = float3(5.0f,5.0f,5.0f)
            {
                display_name("Noise Scale");
                soft_range(0.0001f,100.0f);
            };
    float noise_amount = 0.0f
            {
                display_name("Noise Amount");
                soft_range(-10.0f,10.0f);
            };
    float angle = 0.0f
            {
                display_name("Noise Angle");
            };
    int uvgen = 0
            {
                display_name("Coordinates");
            };

member:


    void main()
    {
        result = float4(0.0f,0.0f,0.0f,0.0f);
        result_bump = float4(0.0f,0.0f,0.0f,0.0f);
        float3 X0000026 = float3(0.0f,0.0f,0.0f);
        switch(uvgen) {
        case 0:
            X0000026 = float3((state::texture_coordinate[0]).x,(state::texture_coordinate[0]).y,(state::texture_coordinate[0]).z);
            break;
        case 1:
            X0000026 = transform_point("internal","object",noise_position);
            break;
        case 2:
            X0000026 = noise_position;
            break;
        }
        float X0000027 = X0000026.y;
        X0000026.y = X0000026.z;
        X0000026.z = -X0000027;
        float3 X0000028 = X0000026 * noise_scale;
        float X0000029 = sin(angle);
        float X0000030 = cos(angle);
        X0000028.x = X0000028.x * X0000030 - X0000028.y * X0000029;
        X0000028.y = X0000028.x * X0000029 - X0000028.y * X0000030;
        float X0000031 = adsk_Utility_MSL_Fnc___noise(X0000028,noise_perm_texture,noise_grad_texture);
        X0000031 = X0000031 * 0.5f + 0.5f;
        result = float4(X0000031.xxx,1.0f);
        result_bump = float4(0.0f,0.0f,0.0f,1.0f);
        if(noise_amount != 0.0f) {
            float3 X0000032 = X0000028;
            float2 X0000033 = (abs(ddx(state::position).xyz) + abs(ddy(state::position).xyz)).xy;
            X0000033 *= noise_scale.xy;
            float X0000034 = X0000033.x;
            float X0000035 = X0000033.y;
            X0000032.x = X0000032.x + X0000034;
            X0000031 = adsk_Utility_MSL_Fnc___noise(X0000032,noise_perm_texture,noise_grad_texture);
            X0000031 = X0000031 * 0.5f + 0.5f;
            Color X0000036 = float4(X0000031.xxx,1.0f);
            X0000032 = X0000026;
            X0000032.y = X0000032.y + X0000035;
            X0000031 = adsk_Utility_MSL_Fnc___noise(X0000032,noise_perm_texture,noise_grad_texture);
            X0000031 = X0000031 * 0.5f + 0.5f;
            Color X0000037 = float4(X0000031.xxx,1.0f);
            float3 X0000038 = float3(0.333333f,0.333333f,0.333333f);
            float X0000039 = dot(X0000038,result.xyz);
            float X0000040 = dot(X0000038,X0000036.xyz) - X0000039;
            float X0000041 = dot(X0000038,X0000037.xyz) - X0000039;
            float3 X0000042 = normalize(float3(-X0000040,-X0000041,1.f / (abs(noise_amount) * 10.0f)));
            float3 X0000043 = X0000042 * state::tangent_space[0];
            result_bump.rgb = X0000043.xyz;
        } else {
            result_bump.rgb = state::normal.xyz;
        }
    }
};


shader adsk_Utility_MSL_CloudGenerator {

output:

    Color result;

input:

    texture1D noise_perm_texture = "noise_perm.dds"
            {
                description("The texture containing the permutation table used in generating the noise.");
                disable_filtering();
            };
    texture1D noise_grad_texture = "noise_grad.dds"
            {
                description("The texture containing the gradient table used in generating the noise.");
                disable_filtering();
            };
    float3 noise_position = float3((state::texture_coordinate[0]).x,(state::texture_coordinate[0]).y,(state::texture_coordinate[0]).z)
            {
                display_name("Noise Position");
                description("The location at which the noise function will be evaluated.");
            };
    float noise_scale = 5.0f
            {
                display_name("Noise Scale");
                soft_range(0.0001f,100.0f);
                description("A scale factor applied to the position at which the noise function will be evaluated.");
            };
    float noise_lacunarity = 2.0f
            {
                display_name("Noise Lacunarity");
                soft_range(0.0f,4.0f);
                description("Factor separating noise frequencies summed to generate the noise pattern.");
            };
    float noise_gain = 0.5f
            {
                display_name("Noise Gain");
                soft_range(0.0f,1.0f);
                description("Factor which weights the noise frequencies summed to generate the noise pattern.");
            };
    Color noise_color1 = float4(1.0f,1.0f,1.0f,1.0f)
            {
                display_name("Noise Color 1");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
                description("The color of the clouds.");
            };
    Color noise_color2 = float4(0.184f,0.506f,0.984f,1.0f)
            {
                display_name("Noise Color 2");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
                description("The color of the base.");
            };
    float noise_threshold = 0.5f
            {
                display_name("Noise Threshold");
                soft_range(0.0f,1.0f);
                description("Cutoff for noise texture that defines how full or sparse the cloud pattern will be.");
            };
    float noise_transition_width = 0.1f
            {
                display_name("Noise Transition Width");
                soft_range(0.0f,1.0f);
                description("Distance at which the cloud pattern will fade from cloud color to base color.");
            };

member:


    void main()
    {
        float3 X0000044 = noise_position * noise_scale;
        float X0000045, X0000046;
        X0000045 = adsk_Utility_MSL_Noise_Octaves(X0000044,noise_perm_texture,noise_grad_texture,4,noise_lacunarity,noise_gain,1.0f,0.5f);
        X0000045 = X0000045 * 0.5f + 0.5f;
        X0000046 = smoothstep(noise_threshold - noise_transition_width,noise_threshold,X0000045);
        X0000045 *= X0000046;
        result = lerp(noise_color2,noise_color1,float4(X0000045));
    }
};
