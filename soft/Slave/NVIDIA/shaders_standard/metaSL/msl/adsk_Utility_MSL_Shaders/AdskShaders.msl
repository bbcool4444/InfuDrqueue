/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 * code generator gen_msl, build 126420.5925.3501
 *                                                                            *
 * Portions Copyright (c) 1986-2010 mental images GmbH, Berlin, Germany.      *
 ******************************************************************************/

// Option settings:


shader adsk_Utility_MSL_Decal {

output:

    Color result;

input:

    Shader surface_material;
    Shader decal;
    float2 top_left;
    float2 top_right;
    float2 bottom_right;
    float2 bottom_left;

member:


    bool X0000000(float2 X0000001,float2 X0000002,float2 X0000003,float2 X0000004,float2 X0000005,out float X0000006,out float X0000007)
    {
        float2 X0000008 = X0000003 - X0000002;
        float2 X0000009 = X0000005 - X0000002;
        float2 X0000010 = X0000001 - X0000002;
        X0000006 = dot(X0000008,X0000010) / dot(X0000008,X0000008);
        X0000007 = dot(X0000009,X0000010) / dot(X0000009,X0000009);
        if(((X0000006 >= 0.f && X0000006 <= 1.f) && X0000007 >= 0.f) && X0000007 <= 1.f)
            return true;
        else
            return false;
    }

    void main()
    {
        result = float4(0.0f,0.0f,0.0f,0.0f);
        surface_material.call("output","result",result);
        float2 X0000011 = (state::texture_coordinate[0]).xy;
        float2 X0000012;
        if(X0000000(X0000011,bottom_left,bottom_right,top_right,top_left,X0000012.x,X0000012.y)) {
            Color X0000013 = result;
            decal.call("input","texture_uv",X0000012.xy,"output","result",result);
            float X0000014 = 0.02f;
            float X0000015 = 1.0f / (1.0f - X0000014);
            float X0000016 = (result.a - X0000014) * X0000015;
            float X0000017 = 1.0f - X0000016;
            result = X0000017 * X0000013 + result * X0000016;
        }
    }
};


shader adsk_texture_lookup_1d {

output:

    Color result;

input:

    texture1D texture = "default_1d.dds";
    int texture_space = 0
            {
                literal();
                hard_range(0,3);
            };
    float coords = (state::texture_coordinate[texture_space]).x;

member:


    void main()
    {
        result = tex1D(texture,coords);
    }
};


shader adsk_texture_lookup_2d {

output:

    Color result;

input:

    texture2D texture = "default.dds";
    int texture_space = 0
            {
                literal();
                hard_range(0,3);
            };
    float2 coords = float2((state::texture_coordinate[texture_space]).x,(state::texture_coordinate[texture_space]).y);

member:


    void main()
    {
        result = tex2D(texture,coords);
    }
};


shader adsk_texture_lookup_3d {

output:

    Color result;

input:

    texture3D texture = "default.dds";
    int texture_space = 0
            {
                literal();
                hard_range(0,3);
            };
    float3 coords = float3((state::texture_coordinate[texture_space]).x,(state::texture_coordinate[texture_space]).y,(state::texture_coordinate[texture_space]).z);

member:


    void main()
    {
        result = tex3D(texture,coords);
    }
};


shader to_bw {

output:

    Color result;

input:

    float r_weight;
    float g_weight;
    float b_weight;
    Color in_color = float4(0.0f,0.0f,0.0f,0.0f);

member:


    void main()
    {
        result = float4(0.0f,0.0f,0.0f,0.0f);
        result = in_color;
        float X0000018 = (result.r * r_weight + result.g * g_weight) + result.b * b_weight;
        result = X0000018;
    }
};


shader adsk_uvsetid_translator {

output:

    int result;

input:

    int uvsetid;

member:


    void main()
    {
        result = 0;
    }
};


shader adsk_scale_meters_to_internal_inverse {

output:

    float result;

input:

    float iSceneToMeterScale = 0.0f;
    float meterValue = 0.0f;

member:


    void main()
    {
        result = 0.0f;
        float X0000019 = 0.0254f;
        if(iSceneToMeterScale != 0.0f)
            X0000019 = iSceneToMeterScale;
        float X0000020 = 1.0f / X0000019;
        result = 1.0f / (meterValue * X0000020);
    }
};


shader adsk_scale_meters_to_internal {

output:

    float result;

input:

    float meterValue;

member:


    void main()
    {
        result = 0.0f;
    }
};


shader adsk_scale_internal_to_meters {

output:

    float result;

input:

    float meterValue;

member:


    void main()
    {
        result = 0.0f;
    }
};


shader adsk_blurred_reflection_multiplier {

output:

    int result;

input:

    int blurred_reflection_value;

member:


    void main()
    {
        result = 0;
    }
};


shader adsk_blurred_refraction_multiplier {

output:

    int result;

input:

    int blurred_refraction_value;

member:


    void main()
    {
        result = 0;
    }
};


shader adsk_aspect_ratio_height_per_width {

output:

    float result;

input:

    texture2D image_color;
    float scaling_value;

member:


    void main()
    {
        result = 0.0f;
    }
};


shader adsk_aspect_ratio_width_per_height {

output:

    float result;

input:

    texture2D image_color;
    float scaling_value;

member:


    void main()
    {
        result = 0.0f;
    }
};


shader adsk_area_shadow_samples {

output:

    int result;

member:


    void main()
    {
        result = 0;
    }
};
