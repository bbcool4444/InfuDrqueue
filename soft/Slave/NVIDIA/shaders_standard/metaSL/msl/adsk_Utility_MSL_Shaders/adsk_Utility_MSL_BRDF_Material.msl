/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 * code generator gen_msl, build 126420.5925.3501
 *                                                                            *
 * Portions Copyright (c) 1986-2010 mental images GmbH, Berlin, Germany.      *
 ******************************************************************************/

// Option settings:


Color GetPaintBaseFactor(in Color base_color,in float diffuse_weight,in float diffuse_bias,in Color edge_color,in float edge_color_bias,in Color lit_color,in float lit_color_bias,in float iLightDotNL,in float3 iEyeDir,in float3 iNormal)
{
    Color diffuse_base = base_color;
    float factor = 0.0f;
    if(edge_color_bias > 0.0f) {
        factor = abs(dot(iNormal,iEyeDir));
        factor = pow(factor,edge_color_bias);
        diffuse_base = base_color * factor + edge_color * (1.0f - factor);
    }
    float s = 0.0f;
    float local_dot_nl = iLightDotNL;
    if(local_dot_nl < 0.0f)
        local_dot_nl = 0.0f;
    s = pow(local_dot_nl,diffuse_bias);
    Color diffuse_falloff = float4(0.0f);
    if(lit_color_bias > 0.0f) {
        factor = pow(local_dot_nl,lit_color_bias);
        factor *= abs(dot(iNormal,iEyeDir));
        diffuse_falloff = diffuse_base * (1.0f - factor) + lit_color * factor;
    } else {
        diffuse_falloff = diffuse_base;
    }
    return diffuse_falloff * s;
}

Color GetOrenNayarFactor(in float iLightDotNL,in float3 iLightDir,in Color iDiffuseColor,in float iRoughness,in float3 iDir,in float3 iNormal)
{
    float vDot = dot(iNormal,iDir);
    float lDot = iLightDotNL;
    float3 dir = iDir;
    if(vDot < 0.0f) {
        vDot = -vDot;
        dir = -dir;
    }
    float onCoeff = 0.0f;
    float onCoeffX = 0.0f;
    {
        float acLDot = 0.0f;
        float acVDot = 0.0f;
        if(lDot < 0.9999f)
            acLDot = acos(lDot);
        if(acLDot < -3.14159265358979323846f * 0.49f)
            acLDot = -3.14159265358979323846f * 0.49f;
        if(acLDot > 1.53938f)
            acLDot = 1.53938f;
        if(vDot < 0.9999f)
            acVDot = acos(vDot);
        if(acLDot < acVDot) {
            float switchme = acVDot;
            acVDot = acLDot;
            acLDot = switchme;
        }
        float3 vTerm = dir - iNormal * vDot;
        float3 lTerm = iLightDir - iNormal * lDot;
        float gTerm = length(vTerm) * length(lTerm);
        float gamma = 1.0f;
        if(abs(gTerm) < 0.0001f)
            gamma = 1.0f;
        else
            gamma = dot(vTerm,lTerm) / gTerm;
        float rough_square = iRoughness * iRoughness;
        float C2term = rough_square / (rough_square + 0.09f);
        float Cx = (2.0f * (gamma >= 0.0f ? -acVDot : acVDot)) / 3.14159265358979323846f;
        float C1 = 1.0f - 0.5f * (rough_square / (rough_square + 0.33f));
        float C2 = (0.45f * C2term) * (sin(acLDot) - pow(Cx,3.0f));
        float C3 = (0.125f * C2term) * pow((((4.0f * acLDot) * acVDot) / 9.869605f),2.0f);
        float A = (C2 * gamma) * tan(acVDot);
        float B = (C3 * (1.0f - abs(gamma))) * tan(((acLDot + acVDot) / 2.0f));
        onCoeff = (C1 + A) + B;
        Cx = (2.0f * acVDot) / 3.14159265358979323846f;
        onCoeffX = (0.17f * (rough_square / (rough_square + 0.13f))) * (1.0f - (gamma * Cx) * Cx);
    }
    Color oColor = onCoeff * iDiffuseColor;
    oColor += (onCoeffX * iDiffuseColor) * iDiffuseColor;
    return min(float4(1.0f,1.0f,1.0f,1.0f),oColor);
}

void GetONayarSimplexFactor(in float3 n,in float3 l,float3 v,in float iRoughness,in float vDot,in float lDot,out float onCoeff,out float onCoeffX)
{
    float acVDot = acos(vDot);
    float acLDot = acos(lDot);
    float3 vTerm = v - n * vDot;
    float3 lTerm = l - n * lDot;
    float gTerm = length(vTerm) * length(lTerm);
    float gamma = 1.0f;
    if(abs(gTerm) < 0.0001f)
        gamma = 1.0f;
    else
        gamma = dot(vTerm,lTerm) / gTerm;
    float rough_sq = iRoughness * iRoughness;
    float Ct = rough_sq / (rough_sq + 0.09f);
    float A = 1.0f - 0.5f * (rough_sq / (rough_sq + 0.57f));
    float B = 0.45f * Ct;
    float alpha = max(acVDot,acLDot);
    float beta = min(acVDot,acLDot);
    float C = sin(alpha) * tan(beta);
    onCoeff = A + (B * max(0.0f,gamma)) * C;
    float Cx = (2.0f * acVDot) / 3.14159265358979323846f;
    onCoeffX = (0.17f * Ct) * (1.0f - (gamma * Cx) * Cx);
    return;
}

float adsk_aux_hermite_step(in float x0,in float x1,in float v)
{
    float f;
    if(v <= x0)
        return 0.0f;
    if(v >= x1)
        return 1.0f;
    f = (v - x0) / (x1 - x0);
    return (f * f) * (3.0f - 2.0f * f);
}

float GetGlossyCoeff(in float glossiness)
{
    return pow(2.0f,glossiness * 8.0f);
}

float GetPhongSpecularFactor(in float3 iLightDir,in float3 iEyeDir,in float3 iNormal,in float iGlossy,in float iAuxFactor,in bool iAuxGlazed,in bool bypass_glossy_coeff)
{
    float res = 0.0f;
    float glossiness = iGlossy;
    if(!bypass_glossy_coeff)
        glossiness = GetGlossyCoeff(iGlossy);
    float3 half_ = iLightDir - iEyeDir;
    float phi = dot(half_,iNormal);
    phi *= phi / dot(half_,half_);
    if(phi > 0.0f)
        res = exp((log(phi) * 0.5f) * glossiness);
    if(iAuxGlazed)
        res = adsk_aux_hermite_step(0.5f,0.8f,res);
    if(iAuxFactor > 0.0f)
        res *= iAuxFactor * iGlossy;
    return res;
}

float GetSpecularFactor(in float3 dir,in float3 light_dir,in float3 norm,in float3 aniso_u,in float3 aniso_v,in float glossy_factor,in float aniso_factor)
{
    float minin = 0.0001f;
    float dotNL = dot(light_dir,norm);
    float dotEye = -dot(dir,norm);
    if(dotEye * dotNL < minin)
        return 0.0f;
    else {
        float glossy_pow = glossy_factor * glossy_factor;
        float aniso_pow = aniso_factor * aniso_factor;
        float3 half_vector = light_dir - dir;
        half_vector = normalize(half_vector);
        float dotHN = dot(half_vector,norm);
        dotHN *= dotHN;
        if(dotHN > 1.0f)
            dotHN = 1.0f;
        float dotAU = dot(half_vector,aniso_u);
        dotAU *= dotAU;
        float dotAV = dot(half_vector,aniso_v);
        dotAV *= dotAV;
        if(dotHN < minin * (dotAU * glossy_pow + dotAV * aniso_pow))
            return 0.0f;
        else {
            float aniso_fx = -(dotAU * glossy_pow + dotAV * aniso_pow) / dotHN;
            return ((exp(aniso_fx) * glossy_factor) * aniso_factor) / ((sqrt((dotEye * dotNL)) * 4.0f) * 3.14159265358979323846f);
        }
    }
}

void GetIsotropyFactor(out float3 oAnisoU,out float3 oAnisoV,in float3 iNormal)
{
    float3 hVector = float3(0.0f,0.0f,1.0f);
    hVector = float3x3(get_transform("object","internal")) * hVector;
    hVector = normalize(hVector);
    float hDot = dot(iNormal,hVector);
    if(abs(hDot) > 0.999f) {
        hVector = float3(0.0f,1.0f,0.0f);
        hVector = float3x3(get_transform("object","internal")) * hVector;
        hVector = normalize(hVector);
        hDot = dot(iNormal,hVector);
        if(abs(hDot) > 0.999f) {
            hVector = float3(1.0f,0.0f,0.0f);
            hVector = float3x3(get_transform("object","internal")) * hVector;
            hVector = normalize(hVector);
            hDot = dot(iNormal,hVector);
        }
    }
    hVector -= iNormal * hDot;
    hVector = normalize(hVector);
    oAnisoV = hVector;
    oAnisoU = cross(oAnisoV,iNormal);
}

void GetAnisotropyFactor(out float3 oAnisoU,out float3 oAnisoV,in float iAnisotropy,in float iAnisoRot,in int iAnisoChannel,in float3 iNormal)
{
    GetIsotropyFactor(oAnisoU,oAnisoV,iNormal);
    if(iAnisotropy != 1.0f) {
        float aniso_cross_vec_dot = dot(iNormal,oAnisoU);
        oAnisoU -= iNormal * aniso_cross_vec_dot;
        oAnisoU = normalize(oAnisoU);
        aniso_cross_vec_dot = dot(iNormal,oAnisoV);
        oAnisoV -= iNormal * aniso_cross_vec_dot;
        oAnisoV = normalize(oAnisoV);
        if(iAnisoRot != 0.0f) {
            float aniso_rot = (iAnisoRot * 3.14159265358979323846f) * 2.0f;
            float aniso_rot_cos = cos(aniso_rot);
            float aniso_rot_sin = sin(aniso_rot);
            float3 aniso_interp = aniso_rot_cos * oAnisoU + aniso_rot_sin * oAnisoV;
            oAnisoV = -aniso_rot_sin * oAnisoU + aniso_rot_cos * oAnisoV;
            oAnisoU = aniso_interp;
        }
    }
}

float FresnelFactor(in float ior_in,in float ior_out,in float t1,in float t2)
{
    float d_p;
    float d_o;
    float r_p;
    float r_o;
    if(ior_in == ior_out)
        return 0.0f;
    else {
        d_p = ior_in * t2 + ior_out * t1;
        if(d_p == 0.0f)
            r_p = 1.0f;
        else
            r_p = (ior_in * t2 - ior_out * t1) / d_p;
        d_o = ior_in * t1 + ior_out * t2;
        if(d_o == 0.0f)
            r_o = 1.0f;
        else
            r_o = (ior_in * t1 - ior_out * t2) / d_o;
        return 0.5f * (r_p * r_p + r_o * r_o);
    }
}

float GetFresnelFactor(in float dot_nd,in float ior_in,in float ior_out)
{
    float ior;
    float theta;
    ior = ior_in / ior_out;
    theta = 1.0f - (ior * ior) * (1.0f - dot_nd * dot_nd);
    if(theta > 0.0f)
        return FresnelFactor(ior_in,ior_out,dot_nd,-sqrt(theta));
    else
        return 1.0f;
}

Color GetRefractionFactor(in float3 p,in float3 d,in float3 n,in float iorx)
{
    Color rColor = float4(0.0f);
    float3 refr_dir = d;
    refr_dir = refract(d,n,1.0f / iorx);
    if((refr_dir.x == 0.0f && refr_dir.y == 0.0f) && refr_dir.z == 0.0f)
        refr_dir = reflect(d,n);
    Ray rayx = Ray(p,refr_dir);
    Ray ray_dx, ray_dy;
    Trace_options trace_options;
    trace_options.set_ray_type("environment");
    trace(rayx,ray_dx,ray_dy,trace_options,"result",rColor);
    return rColor;
}

Color GetReflectionFactor(in float3 p,in float3 d,in float3 n)
{
    Color rColor = float4(0.0f);
    float3 refl_dir = reflect(d,n);
    Ray rayx = Ray(p,refl_dir);
    Ray ray_dx, ray_dy;
    Trace_options trace_options;
    trace_options.set_ray_type("environment");
    trace(rayx,ray_dx,ray_dy,trace_options,"result",rColor);
    return rColor;
}

float SimpleFalloff(float3 direction,float3 normal,float amount)
{
    float f = saturate(dot(-direction,normal));
    f = 1.0f - pow(f,1.0f / amount);
    return f;
}

Color GetOpacityFactor(in float3 p,in float3 d)
{
    Color rColor = float4(0.0f);
    Ray rayx = Ray(p,d);
    Ray ray_dx, ray_dy;
    Trace_options trace_options;
    trace_options.set_ray_type("environment");
    trace(rayx,ray_dx,ray_dy,trace_options,"result",rColor);
    return rColor;
}

void TransformBumpVector(in int b_mode,in float3 b_vector,inout float3 b_transform)
{
    if((b_vector.x == 0.0f && b_vector.y == 0.0f) && b_vector.z == 0.0f)
        return;
    switch(b_mode) {
    case 1:
    case 5:
        {
            break;
        }
    case 2:
    case 6:
        {
            b_vector = transform_vector("world","internal",b_vector);
            break;
        }
    case 3:
    case 7:
        {
            b_vector = transform_vector("object","internal",b_vector);
            break;
        }
    case 4:
    case 8:
        {
            b_vector = transform_vector("camera","internal",b_vector);
            break;
        }
    }
    if(b_mode <= 4)
        b_transform += b_vector;
    else
        b_transform = b_vector;
    b_transform = normalize(b_transform);
}

shader adsk_Utility_BRDF_Material {

output:

    Color result;
    Color diffuse_result;
    Color spec_result;
    Color refl_result;
    Color refr_result;

input:

    float diffuse_weight = 1.0f
            {
                display_name("Diffuse level");
                hard_range(0.0f,1.0f);
            };
    Color diffuse = float4(0.5f,0.5f,0.5f,1.0f)
            {
                display_name("Color");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    float diffuse_roughness = 0.0f
            {
                display_name("Roughness");
                hard_range(0.0f,1.0f);
            };
    float reflectivity = 0.6f
            {
                display_name("Reflectivity");
                hard_range(0.0f,1.0f);
            };
    Color refl_color = float4(1.0f,1.0f,1.0f,1.0f)
            {
                display_name("Reflection color");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    float refl_gloss = 1.0f
            {
                display_name("Reflection glossiness");
                hard_range(0.0f,1.0f);
            };
    float hl_vs_refl_balance = 1.0f
            {
                display_name("Highlights balance");
                hard_range(0.0f,1.0f);
            };
    bool refl_hl_only = false
            {
                display_name("Highlights only");
            };
    bool refl_is_metal = false
            {
                display_name("Metal material");
            };
    bool brdf_conserve_energy = true
            {
                display_name("BRDF Energy Conservation");
            };
    float brdf_0_degree_refl = 0.2f
            {
                display_name("BRDF 0 reflection");
                hard_range(0.0f,1.0f);
            };
    float brdf_90_degree_refl = 1.0f
            {
                display_name("BRDF 90 reflection");
                hard_range(0.0f,1.0f);
            };
    float brdf_curve = 5.0f
            {
                display_name("BRDF Curve shape ");
                soft_range(0.0f,10.0f);
            };
    bool brdf_fresnel = false
            {
                display_name("BRDF Fresnel");
            };
    float anisotropy = 1.0f
            {
                display_name("Anisotropy");
                soft_range(0.0f,2.0f);
            };
    float anisotropy_rotation = 0.0f
            {
                display_name("Anisotropy rotation");
                soft_range(0.0f,1.0f);
            };
    int anisotropy_channel = -1
            {
                display_name("Anisotropy channel");
                literal();
            };
    float transparency = 0.0f
            {
                display_name("Transparency");
                hard_range(0.0f,1.0f);
            };
    Color refr_color = float4(1.0f,1.0f,1.0f,1.0f)
            {
                display_name("Transparency color");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    float refr_ior = 1.4f
            {
                display_name("Transparency index");
            };
    float refr_trans_weight = 0.0f
            {
                display_name("Translucency");
                hard_range(0.0f,1.0f);
            };
    Color refr_trans_color = float4(0.7f,0.6f,0.5f,1.0f)
            {
                display_name("Translucency color");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    float cutout_opacity = 1.0f
            {
                display_name("Cutout opacity");
                hard_range(0.0f,1.0f);
            };
    Color additional_color = float4(.0f,.0f,.0f,.0f)
            {
                display_name("Additional color");
                soft_range(float4(0.0f,0.0f,0.0f,0.0f),float4(1.0f,1.0f,1.0f,1.0f));
            };
    float3 standard_bump = float3(0.0f,0.0f,0.0f)
            {
                display_name("Global bump");
            };
    float3 overall_bump = float3(0.0f,0.0f,0.0f)
            {
                display_name("Local bump");
            };
    bool no_diffuse_bump = false
            {
                display_name("No bump on diffuse");
            };
    bool shade_for_hw = true
            {
                display_name("Shade for Hardware");
            };

member:


    void X0000000(in float3 X0000002,in float3 X0000003,in float3 X0000004,inout Color X0000005)
    {
        X0000005 = float4(0.0f);
        float3 X0000006 = reflect(X0000003,X0000004);
        Ray X0000007 = Ray(X0000002,X0000006);
        Ray X0000008, X0000009;
        Trace_options X0000010;
        X0000010.set_ray_type("environment");
        trace(X0000007,X0000008,X0000009,X0000010,"result",X0000005);
        X0000005.a += 1.0f;
    }

    void X0000001(in float3 X0000011,in float3 X0000012,in float3 X0000013,in float X0000014,out Color X0000015)
    {
        X0000015 = float4(0.0f);
        if(X0000014 == 0.0f)
            return;
        float3 X0000016 = X0000012;
        X0000016 = refract(X0000012,X0000013,1.0f / X0000014);
        Ray X0000017 = Ray(X0000011,X0000016);
        Ray X0000018, X0000019;
        Trace_options X0000020;
        X0000020.set_ray_type("environment");
        trace(X0000017,X0000018,X0000019,X0000020,"result",X0000015);
    }

    void main()
    {
        result = float4(0.0f);
        diffuse_result = float4(0.0f);
        spec_result = float4(0.0f);
        refl_result = float4(0.0f);
        refr_result = float4(0.0f);
        Color X0000021 = float4(0.0f);
        Color X0000022 = float4(0.0f);
        Color X0000023 = float4(0.0f);
        Color X0000024 = float4(0.0f);
        Color X0000025 = diffuse;
        float X0000026 = diffuse_weight;
        Color X0000027 = float4(0.212671f,0.715160f,0.072169f,0.0f);
        float X0000028 = reflectivity;
        Color X0000029 = refl_color;
        bool X0000030 = refl_hl_only;
        float X0000031 = refl_gloss;
        float X0000032 = hl_vs_refl_balance;
        float X0000033 = 1.0f;
        float X0000034 = 1.0f;
        float X0000035 = transparency;
        Color X0000036 = refr_color;
        float X0000037 = refr_ior;
        if(cutout_opacity < 0.01f) {
            refr_result = GetOpacityFactor(state::position,state::direction);
            result = refr_result;
            return;
        }
        float3 X0000038 = state::normal;
        float3 X0000039 = state::normal;
        if(all(standard_bump) || all(overall_bump)) {
            float3 X0000040 = state::normal;
            TransformBumpVector(1,standard_bump,X0000040);
            state::normal = X0000040;
            X0000038 = X0000040;
            X0000039 = X0000040;
            TransformBumpVector(1,overall_bump,X0000040);
            if(!no_diffuse_bump) {
                X0000038 = X0000040;
                X0000039 = X0000040;
            } else {
                X0000038 = state::normal;
                X0000039 = state::normal;
            }
            state::normal = X0000040;
        }
        float X0000041 = anisotropy;
        float3 X0000042 = float3(0.0f,0.0f,0.0f);
        float3 X0000043 = float3(0.0f,0.0f,0.0f);
        GetAnisotropyFactor(X0000042,X0000043,X0000041,anisotropy_rotation,anisotropy_channel,state::normal);
        if(brdf_fresnel) {
            X0000034 = GetFresnelFactor(state::dot_nd,1.0f,X0000037);
            X0000028 *= X0000034;
        } else {
            float X0000044 = pow(1.0f - abs(dot(state::direction,state::normal)),brdf_curve);
            X0000034 = brdf_90_degree_refl * X0000044 + brdf_0_degree_refl * (1.0f - X0000044);
            X0000028 *= X0000034;
        }
        if(refl_is_metal) {
            X0000026 *= 1.0f - ((X0000029.r * X0000027.r + X0000029.g * X0000027.g) + X0000029.b * X0000027.b) * X0000028;
            if(X0000026 < 0.0f)
                X0000026 = 0.0f;
            X0000029.rgb *= X0000025.rgb;
        }
        X0000025.a = (X0000025.r * X0000027.r + X0000025.g * X0000027.g) + X0000025.b * X0000027.b;
        X0000029.a = (X0000029.r * X0000027.r + X0000029.g * X0000027.g) + X0000029.b * X0000027.b;
        X0000036.a = (X0000036.r * X0000027.r + X0000036.g * X0000027.g) + X0000036.b * X0000027.b;
        X0000029 *= X0000028;
        if(brdf_conserve_energy) {
            X0000026 *= 1.0f - X0000036.a * X0000035;
        }
        if(brdf_conserve_energy) {
            X0000035 *= 1.0f - X0000029.a;
            X0000026 *= 1.0f - X0000029.a;
        }
        if(transparency > 0.0f && refr_trans_weight > 0.0f) {
            X0000035 *= 1.0f - refr_trans_weight;
            float X0000045 = SimpleFalloff(state::direction,state::normal,1.0f);
            float3 X0000046 = lerp(refr_trans_color.rgb,float3(1.0f,1.0f,1.0f),X0000045);
            X0000021.rgb += X0000046.xyz * refr_trans_weight;
        }
        X0000036 *= X0000035;
        if(X0000030)
            X0000026 += X0000029.a;
        X0000025 *= X0000026;
        float X0000047 = 0.0f;
        float X0000048 = 0.0f;
        float X0000049 = 0.0f;
        Color X0000050 = float4(0.0f);
        float X0000051 = 0.0f;
        float X0000052 = 0.0f;
        float X0000053 = 0.0f;
        Light_iterator X0000054;
        foreach(X0000054) {
            X0000047 = X0000054.dot_nl;
            if(X0000047 >= 0.0f) {
                X0000048 = X0000047;
                X0000048 *= smoothstep(0.0f,0.25f,X0000047);
                X0000049 = saturate(X0000048);
                if(X0000049 > 0.0f) {
                    if(diffuse_roughness > 0.0f) {
                        X0000050 = GetOrenNayarFactor(X0000054.dot_nl,X0000054.direction,X0000025,diffuse_roughness,state::direction,X0000038);
                        X0000021 += ((X0000049 * X0000050) * X0000054.contribution) / 3.14159265358979323846f;
                    } else {
                        X0000021 += ((X0000049 * X0000025) * X0000054.contribution) / 3.14159265358979323846f;
                    }
                }
                X0000051 = GetGlossyCoeff(X0000031);
                X0000052 = anisotropy * X0000051;
                if(X0000051 >= 80.0f)
                    X0000051 = 80.0f + sqrt((X0000051 - 80.0f));
                if(X0000052 >= 80.0f)
                    X0000052 = 80.0f + sqrt((X0000052 - 80.0f));
                X0000053 = (GetSpecularFactor(state::direction,X0000054.direction,state::normal,X0000042,X0000043,X0000051,X0000052) * 0.5f + GetSpecularFactor(state::direction,X0000054.direction,state::normal,X0000042,X0000043,X0000051 / 2.0f,X0000052 / 2.0f)) + GetSpecularFactor(state::direction,X0000054.direction,state::normal,X0000042,X0000043,(X0000051 / 4.0f),(X0000052 / 4.0f)) * 1.5f;
                X0000053 *= X0000048 * X0000032;
                X0000022 += ((X0000054.contribution / 3.14159265358979323846f) * X0000029) * X0000053;
            }
        }
        if(X0000029.a > 0.0f && !X0000030) {
            X0000000(state::position,state::direction,state::normal,X0000023);
            X0000023.rgb *= X0000029.rgb;
        }
        if(X0000036.a > 0.0f) {
            X0000001(state::position,state::direction,state::normal,X0000037,X0000024);
            if(shade_for_hw)
                X0000024 *= X0000036 * (1.0f - X0000034);
            else
                X0000024.rgb *= X0000036.rgb;
        }
        diffuse_result = X0000021;
        spec_result = X0000022;
        refl_result = X0000023;
        refr_result = X0000024;
        result = ((X0000021 + X0000022) + X0000023) + X0000024;
        result.a = X0000024.a * X0000036.a + (1.0f - X0000036.a);
        result.rgb += additional_color.rgb;
        result *= cutout_opacity;
        result.a = 1.0f;
    }
};
