/*****************************************************************************
 * Copyright 1986-2009 by mental images GmbH, Fasanenstr. 81, D-10623 Berlin,
 * Germany. All rights reserved.
 *****************************************************************************/
/*** This code was generated by gen_msl ***/

shader metasl_mia_material_x {

input:

	float diffuse_weight = 1.0
		{
			description("the maximum amount of diffuse reflection");
			hard_range(0.0,1.0);
		};
	Color diffuse = float4(0.5,0.5,0.5,1.0)
		{
			display_name("Color");
			description("The color of the diffuse reflection, or, when using 'Metal Material' the color of the metal itself");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
		};
	float diffuse_roughness = 0.0
		{
			display_name("Roughness");
			description("adjusts the material's roughness. Higher values yield more 'powdery' surfaces like clay");
			hard_range(0.0,1.0);
		};
	float reflectivity = 0.6
		{
			display_name("Reflectivity");
			description("The maximum amount of glossy/mirror reflectivity. The final also amount depends on the settings of the BRDF curve as w scales the reflectivy of the material");
			hard_range(0.0,1.0);
		};
	Color refl_color = float4(1.0,1.0,1.0,1.0)
		{
			display_name("Reflection color");
			description("The color/intensity of the reflection. When metal material is on, the color of the reflection is influenced as well");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
		};
	float refl_gloss = 1.0
		{
			display_name("Reflection glossiness");
			description("The blurriness / sharpness of reflections. A value of 1.0 means that the surface is a perfect mirror");
			hard_range(0.0,1.0);
		};
	int refl_gloss_samples = 8
		{
			display_name("Reflection gloss samples");
			description("The quality of glossy reflections. The higher the value, the better the quality but rendering time will increase as well.");
			soft_range(0,128);
			literal();
		};
	const bool refl_interpolate = false
		{
			display_name("Fast Reflection (interpolate)");
			description("turns interpolation (= acceleration) for reflections on/off. When on, speed increases at a certain loss of quality. Works best with flat surfaces.");
			literal();
		};
	const bool refl_hl_only = false
		{
			display_name("Reflect highlights and FG only");
			description(" highlights / final gathering only will be reflected");
		};
	const bool refl_is_metal = false
		{
			display_name("Metal material");
			description("causes reflections to be tint in material's color");
		};
	float transparency = 0.0
		{
			display_name("Transparency");
			description("The maximum amount of transparency");
			hard_range(0.0,1.0);
		};
	Color refr_color = float4(1.0,1.0,1.0,1.0)
		{
			display_name("Refraction color");
			description("color / intensity of refractions. The 'easiest' way to create colored glass");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
		};
	float refr_gloss = 1.0
		{
			display_name("Refraction glossiness");
			description("The blurriness / sharpness of the transparency. A value of 1.0 means that the surface is 'clear'. The lower the value the glossier objects appear behind ");
			hard_range(0.0,1.0);
		};
	float refr_ior = 1.4
		{
			display_name("Index of refraction");
			description("Index of refraction. Water has the value 1.33 ");
			soft_range(0.01,4.0);
		};
	int refr_gloss_samples = 8
		{
			display_name("Refraction gloss samples");
			description("The quality of glossy transparency. Higher values yield better results but increase rendering time as well");
			soft_range(0,128);
			literal();
		};
	bool refr_interpolate = false
		{
			display_name("Refraction interpolate");
			description("Turns interpolation (=acceleration) for refractions on/off");
			literal();
		};
	bool refr_translucency = false
		{
			display_name("Refraction translucency");
			description("if on, a surface will be lit even if the light come from the opposite side");
		};
	Color refr_trans_color = float4(0.7,0.6,0.5,1.0)
		{
			display_name("Refraction translucent color");
			description("transluscent color for rays exiting a refractive object");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
		};
	float refr_trans_weight = 0.5
		{
			display_name("Refraction translucent weight");
			description("attenuation of translucency");
			hard_range(0.0,1.0);
		};
	float anisotropy = 1.0
		{
			display_name("Anisotropy");
			description("values different from 1.0 will stretch the highlight to give the impression of a brushed surface");
			soft_range(0.0,2.0);
		};
	float anisotropy_rotation = 0.0
		{
			display_name("Anisotropy rotation");
			description("orientation of anisotropic highlights. The range from 0 to 1 will be mapped to 0 to 360 degrees ");
			soft_range(0.0,1.0);
		};
	const int anisotropy_channel = -1
		{
			display_name("anisotropy channel");
			description("Direction of anisotropy will either be generated automatically or mapped using a given texture channel");
			literal();
		};
	const bool brdf_fresnel = false
		{
			display_name("BRDF fresnel");
			description("When on, uses fresnel term to calculate reflection falloff which is defined by a physical term. If off, the other BRDF terms will be used to calculate the falloff function");
		};
	float brdf_0_degree_refl = 0.2
		{
			display_name("BRDF 0 degree reflection");
			description("Reflectivity at 0 degrees, i.e. when the surface is directly facing the viewer");
			hard_range(0.0,1.0);
		};
	float brdf_90_degree_refl = 1.0
		{
			display_name("BRDF 90 degree reflection");
			description("Reflectivity at 90 degrees i.e. when the surface is seen at grazing angles ");
			hard_range(0.0,1.0);
		};
	float brdf_curve = 5.0
		{
			display_name("BRDF Curve shape ");
			description("Tweaks the shape of the falloff curve function. ");
			soft_range(0.0,10.0);
		};
	bool brdf_conserve_energy = true
		{
			display_name("BRDF conserve energy");
			description("when on, material is guarenteed to be energy conserving");
		};
	const int intr_grid_density = 2
		{
			display_name("Interpolation Grid density");
			description("interpolation grid size. Low values give more accurate results ");
			hard_range(0,5);
			literal();
		};
	const int intr_refl_samples = 2
		{
			display_name("Reflection interpolation points to look up");
			description("how many nearby points to look up. Higher values yield blurrier results ");
			hard_range(0,10);
			literal();
		};
	const bool intr_refl_ddist_on = false
		{
			display_name("Reflection interpolation use high detail");
			description("Uses true raytracing for nearby reflections to give more detail.");
			literal();
		};
	float intr_refl_ddist = 0.0
		{
			display_name("Reflection interpolation detail distance");
			description("Reflections within this distance will use 'regular' raytracing ");
			literal();
		};
	const int intr_refr_samples = 2
		{
			display_name("Refraction interpolation samples");
			description("how many nearby points to look up. Higher values yield blurrier results");
			literal();
		};
	const bool single_env_sample = false
		{
			display_name("Single sample from environment");
			description("Reduces noise in glosy environment reflections by looking it up only once");
			literal();
		};
	const bool refl_falloff_on = false
		{
			display_name("Reflection falloff");
			description("When on, limits the reach of reflections to a certain distance");
			literal();
		};
	float refl_falloff_dist = 0.0
		{
			display_name("Reflection falloff distance");
			description("maximum reach of reflections");
			soft_range(0,150);
			literal();
		};
	const bool refl_falloff_color_on = false
		{
			display_name("Reflection fade to end color");
			description("When on, reflections fade with the distance to a given color");
			literal();
		};
	Color refl_falloff_color = float4(0.0,0.0,0.0,1.0)
		{
			display_name("Reflection falloff color");
			description("reflection fades towards this color with the distance");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
			literal();
		};
	const int refl_depth = 5
		{
			display_name("Reflection max trace depth");
			description("maximum trace depth for reflections");
			soft_range(0,12);
			literal();
		};
	float refl_cutoff = 0.01
		{
			display_name("Reflection cutoff threshold");
			description("sets the relative level at which reflections begin to be optimized outto speed up rendering");
			soft_range(0.0,0.2);
			literal();
		};
	const bool refr_falloff_on = false
		{
			display_name("Refraction falloff active");
			description("when on, limits the reach of transparency so that it fades with the distancetowards a given color");
			literal();
		};
	float refr_falloff_dist = 0.0
		{
			display_name("Refraction falloff distance");
			description("maximum length for refractions");
			soft_range(0,200.0);
			literal();
		};
	const bool refr_falloff_color_on = false
		{
			display_name("Refraction fade to color");
			description("When active, refractions fade towards an end color.");
			literal();
		};
	Color refr_falloff_color = float4(0.0,0.0,0.0,1.0)
		{
			display_name("Refraction falloff color");
			description("when refraction falloff is on, falloff refraction will fade towards this color");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
			literal();
		};
	const int refr_depth = 5
		{
			display_name("Refraction max trace depth");
			description("maximum trace depth for refractions ");
			soft_range(0,12);
			literal();
		};
	float refr_cutoff = 0.01
		{
			display_name("refraction contribution cutoff");
			description("sets the relative level at which refractions begin to be optimized out to speed up rendering");
			soft_range(0.0,0.2);
			literal();
		};
	float indirect_multiplier = 1.0
		{
			display_name("FG / GI multiplier");
			description("Sets the level of indirect illumination contribution from final gathering / photons");
			soft_range(0.0,10.0);
			literal();
		};
	float fg_quality = 1.0
		{
			display_name("Final Gather quality");
			description("A local multiplier to the number of 'Rays per final gather point'");
			soft_range(0.0,100.0);
			literal();
		};
	float fg_quality_w = 1.0
		{
			display_name("Additional multiplier");
			description("Additional multiplier");
			soft_range(0.0,10.0);
			literal();
		};
	const bool ao_on = false
		{
			display_name("Ambient occlusion active");
			description("activates ambient occlusion (AO) ");
		};
	int ao_samples = 16
		{
			display_name("Ambient occlusion samples");
			description("The quality of ambient occlusion. Higher values will give better results at the cost of increased render time");
			literal();
		};
	float ao_distance = 10.0
		{
			display_name("Ambient occlusion max distance");
			description("Sets the distance within which the ambient occlusion operates ");
			soft_range(0.0,200.0);
		};
	Color ao_dark = float4(0.2,0.2,0.2,1.0)
		{
			display_name("ambient occlusion dark color");
			description("Sets the 'darkness' for the deepest crevice");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
		};
	Color ao_ambient = float4(0.0,0.0,0.0,1.0)
		{
			display_name("Ambient occlusion ambient color");
			description("Additional ambient light for ambient occlusion ");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
		};
	const bool ao_do_details = true
		{
			display_name("Ambient occlusion details");
			description("When on, AO will affect indirect illumination ");
		};
	const bool thin_walled = false
		{
			display_name("Thin walled mode");
			description("When on, objects need to be closed to have correct refractions. When on, refraction is discarded");
		};
	const bool no_visible_area_hl = true
		{
			display_name("No visible area highlights");
			description("visible area lights produce no specular highlight");
			literal();
		};
	const bool skip_inside_refl = true
		{
			display_name("Skip reflection on inside");
			description("skips weak internal reflections ");
		};
	const bool do_refractive_caustics = false
		{
			display_name("Refract caustics");
			description("When activated, caustics will be refracted. When off, photons can pass through the material without causing caustics");
			literal();
		};
	const bool backface_cull = false
		{
			display_name("Backface culling active");
			description("Makes surfaces invisible to the camera when seen from the other side");
		};
	const bool propagate_alpha = false
		{
			display_name("propagate alpha");
			description("When off transparent objects don't propagate the alpha channel.");
			literal();
		};
	float hl_vs_refl_balance = 1.0
		{
			display_name("Highlight vs. reflection balance");
			description("Adjusts the weight of the highlight. A value of 0 shows only reflections an no specular highlights at all.");
			hard_range(0.0,1.0);
		};
	float cutout_opacity = 1.0
		{
			display_name("Cutout opacity");
			description("Best to be mapped with a texture. Where the map is white, the object will be visible, black means that the object won't be seen at all");
			hard_range(0.0,1.0);
		};
	Color additional_color = float4(0.0,0.0,0.0,1.0)
		{
			display_name("Additional color");
			description("Use this parameter to add self illumination, for example");
			soft_range(float4(0.0,0.0,0.0,0.0),float4(1.0,1.0,1.0,1.0));
			literal();
		};
	Shader bump;
	bool no_diffuse_bump = false;
	const int mode = 0
		{
			literal();
		};
	const int lights = 0
		{
			literal();
		};
	const int lights2 = 0
		{
			literal();
		};
	const int lights3 = 0
		{
			literal();
		};
	const int bump_mode = 0
		{
			literal();
		};
	float3 overall_bump = float3(float(0),float(0),float(0));
	float3 standard_bump = float3(float(0),float(0),float(0));
	const bool multiple_outputs = true
		{
			literal();
		};

output:

	Color result;
	Color diffuse_result;
	Color diffuse_raw;
	Color diffuse_level;
	Color spec_result;
	Color spec_raw;
	Color spec_level;
	Color refl_result;
	Color refl_raw;
	Color refl_level;
	Color refr_result;
	Color refr_raw;
	Color refr_level;
	Color tran_result;
	Color tran_raw;
	Color tran_level;
	Color indirect_result;
	Color indirect_raw;
	Color indirect_post_ao;
	Color ao_raw;
	Color add_result;
	Color opacity_result;
	Color opacity_raw;
	float opacity;

member:


	void X0000000(in int X0000028,inout float3 X0000029,in float3 X0000030)
	{
		bool X0000031 = false;
		if((X0000030.x == 0.0 && X0000030.y == 0.0) && X0000030.z == 0.0)
			return ;
		switch(X0000028) {
		case 1:
		case 5:
			{
				break;
			}
		case 2:
		case 6:
			{
				X0000030 = transform_vector("world","internal",X0000030);
				break;
			}
		case 3:
		case 7:
			{
				X0000030 = transform_vector("object","internal",X0000030);
				break;
			}
		case 4:
		case 8:
			{
				X0000030 = transform_vector("camera","internal",X0000030);
				break;
			}
		}
		if(X0000028 <= 4)
			{
				X0000029 += X0000030;
			}
		else
			{
				X0000029 = X0000030;
			}
		X0000029 = normalize(X0000029);
	}


	void X0000001(out float3 X0000032,out float3 X0000033,in int X0000034,in float3 X0000035)
	{
		float3 X0000036 = float3(0.0,0.0,1.0);
		float X0000037;
		X0000036 = transform_vector("object","internal",X0000036);
		X0000036 = normalize(X0000036);
		X0000037 = dot(X0000035,X0000036);
		if(abs(X0000037) > 0.99999)
			{
				X0000036 = float3(0.0,1.0,0.0);
				X0000036 = transform_vector("object","internal",X0000036);
				X0000036 = normalize(X0000036);
				X0000037 = dot(X0000035,X0000036);
				if(abs(X0000037) > 0.99999)
					{
						X0000036 = float3(1.0,0.0,0.0);
						X0000036 = transform_vector("object","internal",X0000036);
						X0000036 = normalize(X0000036);
						X0000037 = dot(X0000035,X0000036);
					}
			}
		X0000036 -= X0000035 * X0000037;
		X0000036 = normalize(X0000036);
		X0000033 = X0000036;
		X0000032 = cross(X0000033,X0000035);
	}


	void X0000002(out float3 X0000038,out float3 X0000039,out float X0000040,out float3 X0000041,out float3 X0000042,in float3 X0000043,in float3 X0000044,float3 X0000045)
	{
		int X0000046 = anisotropy_channel;
		X0000038 = X0000044;
		X0000045 = X0000044;
		if(bump_mode == 0)
			{
				bump.call("output","normal_result",X0000044);
			}
		else
			{
				X0000000(bump_mode,X0000044,overall_bump);
				X0000045 = X0000044;
				X0000000(bump_mode,X0000044,standard_bump);
			}
		if(!no_diffuse_bump)
			X0000045 = X0000044;
		X0000039 = X0000044;
		X0000040 = dot(X0000043,X0000044);
		X0000001(X0000041,X0000042,X0000046,X0000044);
		float X0000047;
		X0000047 = dot(X0000044,X0000041);
		X0000041 -= X0000044 * X0000047;
		X0000041 = normalize(X0000041);
		X0000047 = dot(X0000044,X0000042);
		X0000042 -= X0000044 * X0000047;
		X0000042 = normalize(X0000042);
		if(anisotropy_rotation != 0.0)
			{
				float X0000048 = (anisotropy_rotation * 3.14159265358979323846) * 2.0;
				float X0000049 = cos(X0000048);
				float X0000050 = sin(X0000048);
				float3 X0000051 = X0000049 * X0000041 + X0000050 * X0000042;
				X0000042 = -X0000050 * X0000041 + X0000049 * X0000042;
				X0000041 = X0000051;
			}
	}


	float X0000003(in float X0000052,in float X0000053,in float X0000054,in float X0000055)
	{
		float X0000056;
		float X0000057;
		float X0000058;
		float X0000059;
		if(X0000052 == X0000053)
			{
				return 0.0;
			}
		else
			{
				X0000056 = X0000052 * X0000055 + X0000053 * X0000054;
				if(X0000056 == 0.0)
					{
						X0000058 = 1.0;
					}
				else
					{
						X0000058 = (X0000052 * X0000055 - X0000053 * X0000054) / X0000056;
					}
				X0000057 = X0000052 * X0000054 + X0000053 * X0000055;
				if(X0000057 == 0.0)
					{
						X0000059 = 1.0;
					}
				else
					{
						X0000059 = (X0000052 * X0000054 - X0000053 * X0000055) / X0000057;
					}
				return 0.5 * (X0000058 * X0000058 + X0000059 * X0000059);
			}
	}


	float X0000004(in float X0000060,in float X0000061,in float X0000062)
	{
		float X0000063;
		float X0000064;
		X0000063 = X0000061 / X0000062;
		X0000064 = 1.0 - (X0000063 * X0000063) * (1.0 - X0000060 * X0000060);
		if(X0000064 > 0.0)
			{
				return X0000003(X0000061,X0000062,X0000060,-sqrt(X0000064));
			}
		else
			{
				return 1.0;
			}
	}


	void X0000005(out bool X0000065,out bool X0000066,out float X0000067,out Color X0000068,out Color X0000069,out Color X0000070,out float X0000071,out bool X0000072,out bool X0000073,out float X0000074,out Color X0000075,out bool X0000076,out bool X0000077,out float X0000078,out int X0000079,out float X0000080,out float X0000081,out float X0000082,out int X0000083,out float X0000084,out float X0000085,out int X0000086,out float X0000087,out bool X0000088,out float X0000089,out bool X0000090,out Color X0000091,out bool X0000092,out bool X0000093,out float X0000094,in float3 X0000095,in float3 X0000096,in float X0000097,in bool X0000098)
	{
		X0000091 = float4(0.0,0.0,0.0,0.0);
		Color X0000099 = float4(0.212671,0.715160,0.072169,0.0);
		X0000065 = no_diffuse_bump;
		X0000066 = refl_hl_only;
		X0000067 = anisotropy;
		float X0000100 = diffuse_weight;
		float X0000101 = reflectivity;
		float X0000102 = transparency;
		X0000068 = diffuse;
		X0000069 = refl_color;
		X0000070 = refr_color;
		X0000071 = refr_ior;
		X0000072 = thin_walled;
		X0000073 = single_env_sample;
		if(brdf_fresnel)
			{
				if(X0000098 && !X0000072)
					{
						X0000101 *= X0000004(X0000097,X0000071,1.0);
					}
				else
					{
						X0000101 *= X0000004(X0000097,1.0,X0000071);
					}
			}
		else
			{
				float X0000103 = brdf_0_degree_refl;
				float X0000104 = brdf_90_degree_refl;
				float X0000105 = brdf_curve;
				float X0000106 = pow(1.0 - abs(dot(X0000095,X0000096)),X0000105);
				X0000101 *= X0000104 * X0000106 + X0000103 * (1.0 - X0000106);
			}
		if((X0000098 && !X0000072) && skip_inside_refl)
			{
				X0000074 = smoothstep(0.5,0.9,X0000101);
			}
		else
			{
				X0000074 = 1.0;
			}
		if(refl_is_metal)
			{
				X0000100 *= 1.0 - ((X0000069.r * X0000099.r + X0000069.g * X0000099.g) + X0000069.b * X0000099.b) * X0000101;
				if(X0000100 < 0.0)
					{
						X0000100 = 0.0;
					}
				X0000069.r *= X0000068.r;
				X0000069.g *= X0000068.g;
				X0000069.b *= X0000068.b;
			}
		X0000068.a = (X0000068.r * X0000099.r + X0000068.g * X0000099.g) + X0000068.b * X0000099.b;
		X0000069.a = (X0000069.r * X0000099.r + X0000069.g * X0000099.g) + X0000069.b * X0000099.b;
		X0000070.a = (X0000070.r * X0000099.r + X0000070.g * X0000099.g) + X0000070.b * X0000099.b;
		X0000069 *= X0000101;
		if(brdf_conserve_energy)
			{
				float X0000107 = X0000070.a * X0000102;
				if(X0000107 > 1.0)
					{
						X0000107 = 1.0;
					}
				X0000100 *= 1.0 - X0000107;
			}
		if(brdf_conserve_energy)
			{
				float X0000108 = X0000069.a;
				if(X0000108 > 1.0)
					{
						X0000108 = 1.0;
					}
				X0000102 *= 1.0 - X0000108;
				X0000100 *= 1.0 - X0000108;
			}
		if((X0000098 || X0000072) && refr_translucency)
			{
				float X0000109 = refr_trans_weight;
				X0000075 = refr_trans_color;
				X0000075.r *= (X0000070.r * X0000102) * X0000109;
				X0000075.g *= (X0000070.g * X0000102) * X0000109;
				X0000075.b *= (X0000070.b * X0000102) * X0000109;
				X0000075.a = (X0000075.r * X0000099.r + X0000075.g * X0000099.g) + X0000075.b * X0000099.b;
				X0000102 *= 1.0 - X0000109;
			}
		else
			{
				X0000075 = float4(0.0,0.0,0.0,0.0);
			}
		X0000070 *= X0000102;
		if(X0000066)
			{
				X0000100 += X0000069.a;
			}
		X0000068 *= X0000100;
		X0000076 = ao_on;
		if(X0000076)
			{
				X0000077 = ao_do_details;
				X0000078 = ao_distance;
				X0000079 = ao_samples;
			}
		else
			{
				X0000077 = false;
				X0000078 = float(0);
				X0000079 = 0;
			}
		X0000080 = 0.0;
		if(X0000069.a > 0.0)
			{
				X0000081 = hl_vs_refl_balance;
				X0000082 = refl_gloss;
				X0000083 = refl_gloss_samples;
				X0000084 = refl_cutoff;
				if(intr_refl_ddist_on)
					{
						X0000080 = intr_refl_ddist;
					}
			}
		if(X0000070.a > 0.0)
			{
				X0000085 = refr_gloss;
				X0000086 = refr_gloss_samples;
				X0000087 = refr_cutoff;
				X0000088 = refr_falloff_on;
				if(X0000088)
					{
						X0000089 = refr_falloff_dist;
						X0000090 = refr_falloff_color_on;
						if(X0000090)
							{
								X0000091 = refr_falloff_color;
								if(X0000091.r < 0.0)
									{
										X0000091.r = 0.0;
									}
								if(X0000091.g < 0.0)
									{
										X0000091.g = 0.0;
									}
								if(X0000091.b < 0.0)
									{
										X0000091.b = 0.0;
									}
								X0000091.a = (X0000091.r * X0000099.r + X0000091.g * X0000099.g) + X0000091.b * X0000099.b;
							}
					}
				else
					{
						X0000089 = 0.0;
					}
			}
		else
			{
				X0000088 = false;
				X0000090 = false;
				X0000085 = float(1);
				X0000086 = 0;
				X0000087 = float(0);
				X0000089 = float(0);
			}
		X0000092 = refl_interpolate;
		X0000093 = refr_interpolate;
		float X0000110 = fg_quality_w;
		X0000094 = fg_quality;
		if(X0000110 > 0.0)
			{
				X0000094 *= X0000110;
				if(X0000094 < 1.0)
					{
						X0000094 = 1.0;
					}
			}
	}


	Color X0000006(in Light_iterator X0000111,in Color X0000112,in float3 X0000113,in float3 X0000114)
	{
		float X0000115 = 0.0;
		if(X0000111.dot_nl < 0.9999)
			{
				X0000115 = acos(X0000111.dot_nl);
			}
		if(X0000115 < -3.14159265358979323846 * 0.49)
			{
				X0000115 = -3.14159265358979323846 * 0.49;
			}
		if(X0000115 > 3.14159265358979323846 * 0.49)
			{
				X0000115 = 3.14159265358979323846 * 0.49;
			}
		float3 X0000116 = X0000113;
		float X0000117 = dot(X0000114,X0000116);
		if(X0000117 < 0.0)
			{
				X0000117 = -X0000117;
				X0000116.x = -(X0000116.x);
				X0000116.y = -(X0000116.y);
				X0000116.z = -(X0000116.z);
			}
		float X0000118 = 0.0;
		if(X0000117 < 0.9999)
			{
				X0000118 = acos(X0000117);
			}
		if(X0000115 < X0000118)
			{
				float X0000119 = X0000118;
				X0000118 = X0000115;
				X0000115 = X0000119;
			}
		float3 X0000120;
		float3 X0000121;
		X0000120.x = X0000116.x - X0000114.x * X0000117;
		X0000120.y = X0000116.y - X0000114.y * X0000117;
		X0000120.z = X0000116.z - X0000114.z * X0000117;
		X0000121.x = (X0000111.direction).x - X0000114.x * X0000111.dot_nl;
		X0000121.y = (X0000111.direction).y - X0000114.y * X0000111.dot_nl;
		X0000121.z = (X0000111.direction).z - X0000114.z * X0000111.dot_nl;
		float X0000122 = length(X0000120) * length(X0000121);
		float X0000123;
		if(abs(X0000122) < 0.0001)
			{
				X0000123 = 1.0;
			}
		else
			{
				X0000123 = dot(X0000120,X0000121) / X0000122;
			}
		if(X0000123 < -1.0)
			{
				X0000123 = -1.0;
			}
		if(X0000123 > 1.0)
			{
				X0000123 = 1.0;
			}
		float X0000124;
		float X0000125;
		if(X0000123 >= 0.0)
			{
				X0000125 = (2.0 * -X0000118) * (1.0 / 3.14159265358979323846);
			}
		else
			{
				X0000125 = (2.0 * X0000118) * (1.0 / 3.14159265358979323846);
			}
		X0000124 = (X0000125 * X0000125) * X0000125;
		float X0000126 = diffuse_roughness * diffuse_roughness;
		float X0000127 = X0000126 / (X0000126 + 0.09);
		float X0000128 = 1.0 - 0.5 * (X0000126 / (X0000126 + 0.33));
		float X0000129 = (0.45 * X0000127) * (sin(X0000115) - X0000124);
		X0000125 = ((4.0 * X0000115) * X0000118) * (1.0 / (3.14159265358979323846 * 3.14159265358979323846));
		float X0000130 = ((0.125 * X0000127) * X0000125) * X0000125;
		float X0000131 = tan(X0000118);
		float X0000132 = tan((X0000115 + X0000118) * 0.5);
		if(X0000131 < -100.0)
			{
				X0000131 = -100.0;
			}
		if(X0000131 > 100.0)
			{
				X0000131 = 100.0;
			}
		if(X0000132 < -100.0)
			{
				X0000132 = -100.0;
			}
		if(X0000132 > 100.0)
			{
				X0000132 = 100.0;
			}
		float X0000133 = (X0000128 + (X0000129 * X0000123) * X0000131) + (X0000130 * (1.0 - abs(X0000123))) * X0000132;
		X0000125 = (2.0 * X0000118) * (1.0 / 3.14159265358979323846);
		float X0000134 = (0.17 * (X0000126 / (X0000126 + 0.13))) * (1.0 - (X0000123 * X0000125) * X0000125);
		float X0000135;
		Color X0000136 = float4(0.0,0.0,0.0,0.0);
		X0000135 = (X0000133 * X0000112.r + (X0000134 * X0000112.r) * X0000112.r) / 3.14159265358979323846;
		if(X0000135 > 1.0)
			{
				X0000136.r = 1.0;
			}
		else
			{
				X0000136.r = X0000135;
			}
		X0000135 = (X0000133 * X0000112.g + (X0000134 * X0000112.g) * X0000112.g) / 3.14159265358979323846;
		if(X0000135 > 1.0)
			{
				X0000136.g = 1.0;
			}
		else
			{
				X0000136.g = X0000135;
			}
		X0000135 = (X0000133 * X0000112.b + (X0000134 * X0000112.b) * X0000112.b) / 3.14159265358979323846;
		if(X0000135 > 1.0)
			{
				X0000136.b = 1.0;
			}
		else
			{
				X0000136.b = X0000135;
			}
		return X0000136;
	}


	float X0000007(in float X0000137)
	{
		return pow(2.0,X0000137 * 8.0);
	}


	float X0000008(in float3 X0000138,in float3 X0000139,in float3 X0000140,in float3 X0000141,in float3 X0000142,in float X0000143,in float X0000144)
	{
		float X0000145 = 0.0001;
		float X0000146 = dot(X0000139,X0000140);
		float X0000147 = -dot(X0000138,X0000140);
		if(X0000147 * X0000146 < X0000145)
			{
				return 0.0;
			}
		else
			{
				float X0000148 = X0000143 * X0000143;
				float X0000149 = X0000144 * X0000144;
				float3 X0000150 = X0000139 - X0000138;
				X0000150 = normalize(X0000150);
				float X0000151 = dot(X0000150,X0000140);
				X0000151 *= X0000151;
				if(X0000151 > 1.0)
					{
						X0000151 = 1.0;
					}
				float X0000152 = dot(X0000150,X0000141);
				X0000152 *= X0000152;
				float X0000153 = dot(X0000150,X0000142);
				X0000153 *= X0000153;
				if(X0000151 < X0000145 * (X0000152 * X0000148 + X0000153 * X0000149))
					{
						return 0.0;
					}
				else
					{
						float X0000154 = -(X0000152 * X0000148 + X0000153 * X0000149) / X0000151;
						return ((exp(X0000154) * X0000143) * X0000144) / ((sqrt(X0000147 * X0000146) * 4.0) * 3.14159265358979323846);
					}
			}
	}


	void X0000009(inout float X0000155,inout float X0000156,in float X0000157,in float X0000158)
	{
		float X0000159 = float(2) * X0000157 - float(1);
		float X0000160 = float(2) * X0000158 - float(1);
		if(X0000159 == 0.0 && X0000160 == 0.0)
			{
				X0000156 = 0.0;
				X0000155 = 0.0;
			}
		else
			{
				if(X0000159 > -X0000160)
					{
						if(X0000159 > X0000160)
							{
								X0000155 = X0000159;
								X0000156 = (3.14159265358979323846 / 4.0) * (1.0 + X0000160 / X0000159);
							}
						else
							{
								X0000155 = X0000160;
								X0000156 = (3.14159265358979323846 / 4.0) * (3.0 - X0000159 / X0000160);
							}
					}
				else
					{
						if(X0000159 < X0000160)
							{
								X0000155 = -X0000159;
								X0000156 = (3.14159265358979323846 / 4.0) * (5.0 + X0000160 / X0000159);
							}
						else
							{
								X0000155 = -X0000160;
								X0000156 = (3.14159265358979323846 / 4.0) * (7.0 - X0000159 / X0000160);
							}
					}
			}
	}


	void X0000010(inout float3 X0000161,in float3 X0000162,in float X0000163,in float X0000164,in float X0000165)
	{
		float3 X0000166;
		float3 X0000167;
		float3 X0000168 = transform_normal("internal","object",X0000162);
		if(abs(X0000168.x) < abs(X0000168.y))
			{
				X0000166.x = 0.0;
				X0000166.y = -(X0000168.z);
				X0000166.z = X0000168.y;
			}
		else
			{
				X0000166.x = X0000168.z;
				X0000166.y = 0.0;
				X0000166.z = -(X0000168.x);
			}
		X0000166 = transform_vector("object","internal",X0000166);
		if(length(X0000166) == 0.0)
			{
				if(abs(X0000162.x) < abs(X0000162.y))
					{
						X0000166.x = 0.0;
						X0000166.y = -(X0000162.z);
						X0000166.z = X0000162.y;
					}
				else
					{
						X0000166.x = X0000162.z;
						X0000166.y = 0.0;
						X0000166.z = -(X0000162.x);
					}
			}
		X0000166 = normalize(X0000166);
		X0000167 = cross(X0000162,X0000166);
		X0000161 = (X0000163 * X0000166 + X0000164 * X0000167) + X0000165 * X0000162;
	}


	void X0000011(inout float3 X0000169,in float3 X0000170,in float2 X0000171)
	{
		float X0000172 = 0.0;
		float X0000173 = 0.0;
		X0000009(X0000172,X0000173,X0000171.x,X0000171.y);
		float X0000174 = X0000172 * cos(X0000173);
		float X0000175 = X0000172 * sin(X0000173);
		float X0000176 = (1.0 - X0000174 * X0000174) - X0000175 * X0000175;
		float X0000177;
		if(X0000176 > 0.0)
			{
				X0000177 = sqrt(X0000176);
			}
		else
			{
				X0000177 = 0.0;
			}
		X0000010(X0000169,X0000170,X0000174,X0000175,X0000177);
	}


	void X0000012(inout float3 X0000178,in float3 X0000179,in float3 X0000180,in float X0000181,in float2 X0000182)
	{
		float X0000183 = 1000000000000000000000000000000000000.0;
		float X0000184 = 0.0;
		float3 X0000185 = reflect(X0000179,X0000180);
		if(X0000181 > float(0))
			{
				X0000184 = 1.0 / X0000181;
			}
		else
			{
				X0000184 = X0000183;
			}
		float X0000186 = (2.0 * 3.14159265358979323846) * X0000182.x;
		float X0000187 = atan(X0000184 * sqrt(-log(1.0 - X0000182.y)));
		float X0000188 = cos(X0000186) * sin(X0000187);
		float X0000189 = sin(X0000186) * sin(X0000187);
		float X0000190 = cos(X0000187);
		X0000010(X0000178,X0000185,X0000188,X0000189,X0000190);
	}


	void X0000013(inout float3 X0000191,in float3 X0000192,in float3 X0000193,in float3 X0000194,in float X0000195,in float X0000196,in float X0000197)
	{
		float X0000198 = dot(X0000193,X0000192);
		float3 X0000199 = X0000193 - X0000198 * X0000192;
		X0000199 = normalize(X0000199);
		float3 X0000200 = cross(X0000192,X0000199);
		X0000191 = (X0000195 * X0000199 + X0000196 * X0000200) + X0000197 * X0000192;
	}


	void X0000014(inout float3 X0000201,in float3 X0000202,in float3 X0000203,in float3 X0000204,in float X0000205,in float3 X0000206,in float3 X0000207,in float X0000208,in float X0000209,in float2 X0000210)
	{
		float3 X0000211 = float3(0.0,0.0,0.0);
		X0000211 = reflect(X0000202,X0000203);
		float X0000212 = atan2(X0000208 * cos((2.0 * 3.14159265358979323846) * X0000210.x),X0000209 * sin((2.0 * 3.14159265358979323846) * X0000210.x));
		float X0000213 = cos(X0000212) * X0000208;
		float X0000214 = sin(X0000212) * X0000209;
		float X0000215 = atan(sqrt(-log(1.0 - X0000210.y) / (X0000213 * X0000213 + X0000214 * X0000214)));
		float X0000216 = cos(X0000212) * sin(X0000215);
		float X0000217 = sin(X0000212) * sin(X0000215);
		float X0000218 = cos(X0000215);
		X0000013(X0000201,X0000211,X0000206,X0000207,X0000216,X0000217,X0000218);
		float X0000219 = dot(X0000201,X0000204);
		if(X0000219 < 0.0)
			{
				float3 X0000220 = X0000204;
				X0000220 *= -2.0 * X0000219;
				X0000201 = X0000201 + X0000220;
			}
	}


	float X0000015(inout int X0000221,in float X0000222)
	{
		if(is_ray_history_group("final_gather"))
			{
				X0000221 = 1;
			}
		if(X0000221 > 1)
			{
				X0000221 = int(float(X0000221) * (sqrt(X0000222) * importance));
			}
		if(X0000221 < 1)
			{
				X0000221 = 1;
			}
		return X0000222 * importance;
	}


	void X0000016(inout float3 X0000223,in float3 X0000224,in float3 X0000225,in float3 X0000226,in float X0000227,in float3 X0000228,in float3 X0000229,in float X0000230,in float X0000231,in float2 X0000232)
	{
		if(X0000230 >= 1.0)
			{
				X0000223 = reflect(X0000224,X0000225);
			}
		else
			{
				if(X0000230 <= 0.0)
					{
						X0000011(X0000223,X0000225,X0000232);
					}
				else
					{
						float X0000233 = X0000007(X0000230);
						float3 X0000234 = -X0000225;
						float X0000235 = -1.0;
						if(abs(X0000231 - 1.0) < 0.01)
							{
								X0000012(X0000223,X0000234,X0000225,X0000233,X0000232);
							}
						else
							{
								X0000014(X0000223,X0000234,X0000225,X0000226,X0000235,X0000228,X0000229,X0000233,X0000233 * X0000231,X0000232);
							}
						X0000223 += X0000225;
						X0000223 = normalize(X0000223);
						float3 X0000236 = X0000223;
						X0000235 = dot(X0000224,X0000236);
						float3 X0000237 = X0000224 - (X0000236 * X0000235) * 2.0;
						float X0000238 = dot(X0000226,X0000237);
						X0000223 = reflect(X0000224,X0000236);
						if(X0000238 < float(0))
							{
								X0000238 = dot(X0000237,X0000226);
								X0000223 = X0000237 - (X0000226 * X0000238) * 2.0;
							}
					}
			}
	}


	void X0000017(inout Color X0000239,in bool X0000240,in float X0000241,in bool X0000242,in Color X0000243,in float3 X0000244,in float3 X0000245,in float3 X0000246,in float3 X0000247,in float X0000248,in int X0000249,in float X0000250,in float X0000251,in float3 X0000252,in float3 X0000253,in float X0000254,in float X0000255)
	{
		Color X0000256 = float4(0.0,0.0,0.0,0.0);
		float X0000257 = 0.0;
		float2 X0000258;
		int X0000259 = X0000249;
		float X0000260 = X0000250;
		float X0000261 = X0000251;
		if(X0000259 <= 0 || X0000260 >= 1.0)
			{
				X0000259 = 1;
				X0000260 = 1.0;
				X0000261 = 1.0;
			}
		float X0000262 = X0000015(X0000259,X0000255);
		Sample_iterator X0000263 = Sample_iterator(X0000259);
		foreach(X0000263)
			{
				float X0000264 = X0000263.sample();
				if(X0000262 >= X0000254 * X0000264)
					{
						X0000257 += 1.0;
						X0000258 = X0000263.sample2();
						float3 X0000265 = float3(0.0,0.0,0.0);
						float X0000266 = X0000250;
						X0000016(X0000265,X0000245,X0000246,X0000247,X0000248,X0000252,X0000253,X0000266,X0000261,X0000258);
						Color X0000267 = float4(float(0),float(0),float(0),float(0));
						Ray X0000268;
						Ray X0000269;
						Ray X0000270;
						X0000268 = Ray(X0000244,X0000265);
						Trace_options X0000271;
						X0000271.set_ray_type("reflect");
						if(X0000266 < 1.0)
							{
								X0000271.set_ray_dispersal_group("glossy");
							}
						else
							{
								X0000271.set_ray_dispersal_group("specular");
							}
						float X0000272 = 0.0;
						if(X0000240)
							{
								X0000272 = X0000241;
							}
						if(X0000272 > 0.0)
							{
								X0000271.set_far(X0000272);
							}
						X0000271.set_importance(X0000255 / float(X0000259));
						float X0000273 = 0.0;
						if(trace(X0000268,X0000269,X0000270,X0000271,"result",X0000267,"State::ray_length",X0000273))
							{
								Color X0000274 = float4(0.0,0.0,0.0,0.0);
								if(X0000240)
									{
										if(X0000242)
											{
												X0000274 = X0000243;
											}
										else
											{
												Trace_options X0000275;
												X0000275.set_ray_type("environment");
												Ray X0000276 = Ray(float3(float(0)),float3(float(0)));
												Ray X0000277 = Ray(float3(float(0)),float3(float(0)));
												trace(X0000268,X0000276,X0000277,X0000275,"result",X0000274);
											}
										if(X0000273 > 0.0)
											{
												if(X0000272 > 0.0 && X0000273 < X0000272)
													{
														float X0000278 = pow(1.0 - X0000273 / X0000272,2.0);
														float X0000279 = 1.0 - X0000278;
														X0000256 += X0000267 * X0000278 + X0000274 * X0000279;
													}
												else
													{
														X0000256 += X0000267;
													}
											}
										else
											{
												X0000256 += X0000274;
											}
									}
								else
									{
										X0000256 += X0000267;
									}
							}
						else
							{
								X0000256 += X0000267;
							}
					}
			}
		if(X0000257 > 0.0)
			{
				X0000239 = X0000256 / X0000257;
			}
	}


	void X0000018(inout Color X0000280,in bool X0000281,in float X0000282,in bool X0000283,in Color X0000284,in float3 X0000285,in float3 X0000286,in float3 X0000287,in float3 X0000288,in float X0000289,in float X0000290,in bool X0000291,in int X0000292,in float X0000293,in float X0000294,in float3 X0000295,in float3 X0000296,in float X0000297,in float X0000298)
	{
		if(X0000281)
			{
				warning("TODO: shd_refl_falloff_on");
			}
		if(X0000290 > 0.0)
			{
				if(!X0000291)
					{
						X0000017(X0000280,X0000281,X0000282,X0000283,X0000284,X0000285,X0000286,X0000287,X0000288,X0000289,X0000292,X0000293,X0000294,X0000295,X0000296,X0000297,X0000298);
					}
			}
	}


	void X0000019(inout Color X0000299,out Color X0000300,out Color X0000301,out Color X0000302,in bool X0000303,in float X0000304,in bool X0000305,in Color X0000306,in float3 X0000307,in float3 X0000308,in float3 X0000309,in float3 X0000310,in float X0000311,in bool X0000312,in Color X0000313,in float X0000314,in bool X0000315,in int X0000316,in float X0000317,in float X0000318,in float3 X0000319,in float3 X0000320,in float X0000321)
	{
		if(X0000312)
			{
			}
		else
			{
				X0000018(X0000299,X0000303,X0000304,X0000305,X0000306,X0000307,X0000308,X0000309,X0000310,X0000311,X0000314,X0000315,X0000316,X0000317,X0000318,X0000319,X0000320,X0000321,X0000313.a);
			}
		X0000301 = X0000299;
		X0000302 = X0000313;
		X0000299.r *= X0000313.r;
		X0000299.g *= X0000313.g;
		X0000299.b *= X0000313.b;
		X0000300 = X0000299;
	}


	bool X0000020(inout float3 X0000322,in float X0000323,in float X0000324,in float3 X0000325,in float3 X0000326,in float3 X0000327,in float X0000328)
	{
		if(X0000324 <= 0.0)
			{
				return false;
			}
		else
			{
				float X0000329 = X0000323 / X0000324;
				float X0000330 = 1.0 - (X0000329 * X0000329) * (1.0 - X0000328 * X0000328);
				if(X0000330 < 0.0)
					{
						return false;
					}
				else
					{
						if(X0000330 == 0.0)
							{
								X0000322 = X0000325;
								return true;
							}
						else
							{
								X0000330 = -X0000329 * X0000328 - sqrt(X0000330);
								X0000322 = X0000330 * X0000326 + X0000329 * X0000325;
								if(dot(X0000322,X0000327) > 0.0)
									{
										X0000322 = X0000325;
										return true;
									}
								else
									{
										X0000322 = normalize(X0000322);
										return true;
									}
							}
					}
			}
	}


	void X0000021(inout float3 X0000331,in float3 X0000332,in float2 X0000333)
	{
		X0000011(X0000331,X0000332,X0000333);
		X0000331 = -X0000331;
	}


	bool X0000022(inout float3 X0000334,in float X0000335,in float X0000336,in float3 X0000337,in float3 X0000338,in float3 X0000339,in float X0000340,in float X0000341,in float2 X0000342)
	{
		float3 X0000343 = float3(0.0,0.0,0.0);
		float X0000344 = 1000000000000000000000000000000000000.0;
		float X0000345;
		if(!X0000020(X0000343,X0000335,X0000336,X0000337,X0000338,X0000339,X0000340))
			{
				return false;
			}
		if(X0000341 > 0.0)
			{
				X0000345 = 1.0 / X0000341;
			}
		else
			{
				X0000345 = X0000344;
			}
		float X0000346 = (2.0 * 3.14159265358979323846) * X0000342.x;
		float X0000347 = atan(X0000345 * sqrt(-log(1.0 - X0000342.y)));
		float X0000348 = cos(X0000346) * sin(X0000347);
		float X0000349 = sin(X0000346) * sin(X0000347);
		float X0000350 = cos(X0000347);
		X0000010(X0000334,X0000343,X0000348,X0000349,X0000350);
		return dot(X0000334,X0000339) < 0.0;
	}


	bool X0000023(inout float3 X0000351,in float X0000352,in float X0000353,in float3 X0000354,in float3 X0000355,in float3 X0000356,in float X0000357,in float3 X0000358,in float3 X0000359,in float X0000360,in float X0000361,in float2 X0000362)
	{
		float3 X0000363 = float3(0.0,0.0,0.0);
		if(!X0000020(X0000363,X0000352,X0000353,X0000354,X0000355,X0000356,X0000357))
			{
				return false;
			}
		float X0000364 = atan2(X0000360 * cos((2.0 * 3.14159265358979323846) * X0000362.x),X0000361 * sin((2.0 * 3.14159265358979323846) * X0000362.x));
		float X0000365 = cos(X0000364) * X0000360;
		float X0000366 = sin(X0000364) * X0000361;
		float X0000367 = atan(sqrt(-log(1.0 - X0000362.x) / (X0000365 * X0000365 + X0000366 * X0000366)));
		float X0000368 = cos(X0000364) * sin(X0000367);
		float X0000369 = sin(X0000364) * sin(X0000367);
		float X0000370 = cos(X0000367);
		X0000013(X0000351,X0000363,X0000358,X0000359,X0000368,X0000369,X0000370);
		return dot(X0000351,X0000356) < 0.0;
	}


	bool X0000024(inout float3 X0000371,in float X0000372,in float X0000373,in float3 X0000374,in float3 X0000375,in float3 X0000376,in float X0000377)
	{
		return X0000020(X0000371,X0000372,X0000373,X0000374,X0000375,X0000376,X0000377);
	}


	bool X0000025(inout float3 X0000378,in bool X0000379,in float3 X0000380,in float3 X0000381,in float3 X0000382,in float X0000383,in bool X0000384,in float X0000385,in float3 X0000386,in float3 X0000387,in float X0000388,in float X0000389,in float2 X0000390)
	{
		float X0000391 = 1.0;
		float X0000392 = 1.0;
		if(!X0000384)
			{
				if(X0000379)
					{
						X0000391 = X0000385;
					}
				else
					{
						X0000392 = X0000385;
					}
			}
		if(X0000388 >= 1.0)
			{
				return X0000024(X0000378,X0000391,X0000392,X0000380,X0000381,X0000382,X0000383);
			}
		if(X0000388 <= 0.0)
			{
				X0000021(X0000378,X0000381,X0000390);
				return true;
			}
		float X0000393 = X0000007(X0000388);
		if(abs(X0000389 - 1.0) < 0.01)
			{
				return X0000022(X0000378,X0000391,X0000392,X0000380,X0000381,X0000382,X0000383,X0000393,X0000390);
			}
		return X0000023(X0000378,X0000391,X0000392,X0000380,X0000381,X0000382,X0000383,X0000386,X0000387,X0000393,X0000393 * X0000389,X0000390);
	}


	void X0000026(inout Color X0000394,in bool X0000395,in float3 X0000396,in float3 X0000397,in float3 X0000398,in float3 X0000399,in float X0000400,in int X0000401,in float X0000402,in float X0000403,in bool X0000404,in float X0000405,in float3 X0000406,in float3 X0000407,in float X0000408,in float X0000409)
	{
		Color X0000410 = float4(0.0,0.0,0.0,0.0);
		float X0000411 = 0.0;
		float2 X0000412;
		int X0000413 = X0000401;
		float X0000414 = X0000402;
		float X0000415 = X0000403;
		if(X0000413 <= 0 || X0000414 >= 1.0)
			{
				X0000413 = 1;
				X0000414 = 1.0;
				X0000415 = 1.0;
			}
		float X0000416 = X0000015(X0000413,X0000409);
		Sample_iterator X0000417 = Sample_iterator(X0000413);
		foreach(X0000417)
			{
				float X0000418 = X0000417.sample();
				if(X0000416 >= X0000408 * X0000418)
					{
						X0000411 += 1.0;
						X0000412 = X0000417.sample2();
						float3 X0000419 = float3(0.0,0.0,0.0);
						float X0000420 = X0000402;
						bool X0000421 = X0000025(X0000419,X0000395,X0000397,X0000398,X0000399,X0000400,X0000404,X0000405,X0000406,X0000407,X0000420,X0000415,X0000412);
						if(!X0000421)
							{
								X0000016(X0000419,X0000397,X0000398,X0000399,X0000400,X0000406,X0000407,X0000420,X0000415,X0000412);
								Color X0000422 = float4(float(0),float(0),float(0),float(0));
								Ray X0000423;
								Ray X0000424;
								Ray X0000425;
								X0000423 = Ray(X0000396,X0000419);
								Trace_options X0000426;
								X0000426.set_ray_type("reflect");
								if(X0000420 < 1.0)
									{
										X0000426.set_ray_dispersal_group("glossy");
									}
								else
									{
										X0000426.set_ray_dispersal_group("specular");
									}
								X0000426.set_importance(X0000409 / float(X0000413));
								if(trace(X0000423,X0000424,X0000425,X0000426,"result",X0000422))
									{
										X0000410.r += X0000422.r;
										X0000410.g += X0000422.g;
										X0000410.b += X0000422.b;
										X0000410.a += 1.0;
									}
							}
						else
							{
								Color X0000427 = float4(float(0),float(0),float(0),float(0));
								Ray X0000428;
								Ray X0000429;
								Ray X0000430;
								X0000428 = Ray(X0000396,X0000419);
								Trace_options X0000431;
								X0000431.set_ray_type("refract");
								X0000431.set_ray_dispersal_group("glossy");
								X0000431.set_importance(X0000409 / float(X0000413));
								trace(X0000428,X0000429,X0000430,X0000431,"result",X0000427);
								X0000410 += X0000427;
							}
					}
			}
		if(X0000411 > 0.0)
			{
				X0000394 = X0000410 / X0000411;
			}
	}


	void X0000027(inout Color X0000432,out Color X0000433,out Color X0000434,out Color X0000435,in bool X0000436,in float3 X0000437,in float3 X0000438,in float3 X0000439,in float3 X0000440,in float X0000441,in bool X0000442,in Color X0000443,in int X0000444,in float X0000445,in float X0000446,in bool X0000447,in float X0000448,in float3 X0000449,in float3 X0000450,in float X0000451)
	{
		if(!X0000442)
			{
				X0000026(X0000432,X0000436,X0000437,X0000438,X0000439,X0000440,X0000441,X0000444,X0000445,X0000446,X0000447,X0000448,X0000449,X0000450,X0000451,X0000443.a);
			}
		X0000434 = X0000432;
		X0000435 = X0000443;
		X0000432.r *= X0000443.r;
		X0000432.g *= X0000443.g;
		X0000432.b *= X0000443.b;
		X0000433 = X0000432;
	}


	void main()
	{
		result = float4(0.0,0.0,0.0,0.0);
		Color X0000452 = float4(0.0,0.0,0.0,0.0);
		Color X0000453 = float4(0.0,0.0,0.0,0.0);
		Color X0000454 = float4(0.0,0.0,0.0,0.0);
		Color X0000455 = float4(0.0,0.0,0.0,0.0);
		Color X0000456 = float4(0.0,0.0,0.0,0.0);
		Color X0000457 = float4(0.0,0.0,0.0,0.0);
		Color X0000458 = float4(0.0,0.0,0.0,0.0);
		float3 X0000459 = float3(0.);
		diffuse_result = float4(float(0),float(0),float(0),float(1));
		diffuse_raw = float4(float(0),float(0),float(0),float(1));
		diffuse_level = float4(float(0),float(0),float(0),float(1));
		spec_result = float4(float(0),float(0),float(0),float(1));
		spec_raw = float4(float(0),float(0),float(0),float(1));
		spec_level = float4(float(0),float(0),float(0),float(1));
		refl_result = float4(float(0),float(0),float(0),float(1));
		refl_raw = float4(float(0),float(0),float(0),float(1));
		refl_level = float4(float(0),float(0),float(0),float(1));
		refr_result = float4(float(0),float(0),float(0),float(1));
		refr_raw = float4(float(0),float(0),float(0),float(1));
		refr_level = float4(float(0),float(0),float(0),float(1));
		tran_result = float4(float(0),float(0),float(0),float(1));
		tran_raw = float4(float(0),float(0),float(0),float(1));
		tran_level = float4(float(0),float(0),float(0),float(1));
		indirect_result = float4(float(0),float(0),float(0),float(1));
		indirect_raw = float4(float(0),float(0),float(0),float(1));
		indirect_post_ao = float4(float(0),float(0),float(0),float(1));
		ao_raw = float4(float(1),float(1),float(1),float(1));
		opacity_result = float4(float(0),float(0),float(0),float(0));
		opacity_raw = float4(float(0),float(0),float(0),float(0));
		opacity = cutout_opacity;
		if(backface_cull && backside)
			{
				opacity = 0.0;
			}
		if(opacity < 0.01)
			{
				Ray X0000460;
				Ray X0000461;
				Ray X0000462;
				Trace_options X0000463;
				X0000460 = Ray(position,direction);
				X0000463.set_ray_type("transparent");
				trace(X0000460,X0000461,X0000462,X0000463,"result",opacity_raw);
				opacity_result = opacity_raw;
				result += opacity_result;
			}
		else
			{
				float3 X0000464 = float3(0.0,0.0,0.0);
				float3 X0000465 = float3(0.0,0.0,0.0);
				float X0000466 = 0.0;
				float3 X0000467 = float3(0.0,0.0,0.0);
				float3 X0000468 = float3(0.0,0.0,0.0);
				X0000002(X0000464,X0000465,X0000466,X0000467,X0000468,direction,normal,X0000459);
				bool X0000469 = false;
				bool X0000470 = false;
				float X0000471 = 0.0;
				Color X0000472 = float4(0.0,0.0,0.0,0.0);
				Color X0000473 = float4(0.0,0.0,0.0,0.0);
				Color X0000474 = float4(0.0,0.0,0.0,0.0);
				float X0000475 = 0.0;
				bool X0000476 = false;
				bool X0000477 = false;
				float X0000478 = 0.0;
				Color X0000479 = float4(0.0,0.0,0.0,0.0);
				bool X0000480 = false;
				bool X0000481 = false;
				float X0000482 = 0.0;
				int X0000483 = 0;
				float X0000484 = 0.0;
				float X0000485 = 0.0;
				float X0000486 = 0.0;
				int X0000487 = 0;
				float X0000488 = 0.0;
				float X0000489 = 0.0;
				int X0000490 = 0;
				float X0000491 = 0.0;
				bool X0000492 = false;
				float X0000493 = 0.0;
				bool X0000494 = false;
				Color X0000495 = float4(0.0,0.0,0.0,0.0);
				bool X0000496 = false;
				bool X0000497 = false;
				float X0000498 = 0.0;
				X0000005(X0000469,X0000470,X0000471,X0000472,X0000473,X0000474,X0000475,X0000476,X0000477,X0000478,X0000479,X0000480,X0000481,X0000482,X0000483,X0000484,X0000485,X0000486,X0000487,X0000488,X0000489,X0000490,X0000491,X0000492,X0000493,X0000494,X0000495,X0000496,X0000497,X0000498,direction,normal,dot_nd,backside);
				Color X0000499 = float4(1.0,1.0,1.0,1.0);
				if((X0000472.a > 0.0 || X0000473.a > 0.0) || X0000479.a > 0.0)
					{
						diffuse_level = X0000472;
						spec_level = X0000473 * X0000485;
						Light_iterator X0000500;
						foreach(X0000500)
							{
								float X0000501 = dot(X0000500.direction,X0000464);
								if(X0000501 >= 0.0)
									{
										float X0000502 = dot(X0000500.direction,X0000465);
										X0000502 *= smoothstep(0.0,0.25,X0000501);
										float X0000503 = saturate(X0000502);
										if(X0000469)
											{
												X0000503 = dot(X0000500.direction,X0000459);
											}
										if(X0000503 > 0.0)
											{
												if(diffuse_roughness <= 0.0)
													{
														X0000503 /= 3.14159265358979323846;
														X0000453 += (X0000503 * X0000472) * X0000500.contribution;
														diffuse_raw += X0000503 * X0000500.contribution;
													}
												else
													{
														Color X0000504 = X0000006(X0000500,X0000472,direction,normal);
														Color X0000505 = Color((X0000503 * X0000504) * X0000500.contribution);
														X0000453 += X0000505;
														diffuse_raw += X0000505 / X0000472;
													}
											}
										float X0000506 = 0.0;
										float X0000507 = X0000007(X0000486);
										float X0000508 = anisotropy * X0000507;
										if(X0000507 >= 80.0)
											X0000507 = 80.0 + sqrt(X0000507 - 80.0);
										if(X0000508 >= 80.0)
											X0000508 = 80.0 + sqrt(X0000508 - 80.0);
										X0000506 = (X0000008(direction,X0000500.direction,normal,X0000467,X0000468,X0000507,X0000508) * 0.5 + X0000008(direction,X0000500.direction,normal,X0000467,X0000468,X0000507 / 2.0,X0000508 / 2.0) * 1.0) + X0000008(direction,X0000500.direction,normal,X0000467,X0000468,X0000507 / 4.0,X0000508 / 4.0) * 1.5;
										X0000506 *= (X0000502 * X0000485) / 3.14159265358979323846;
										X0000506 *= sqrt(importance);
										Color X0000509 = Color(X0000500.contribution * X0000506);
										X0000454 += X0000509 * X0000473;
										spec_raw += X0000509 / X0000485;
									}
							}
						diffuse_result = diffuse_raw * diffuse_level;
						spec_result = spec_raw * spec_level;
						Irradiance_options X0000510 = Irradiance_options();
						float X0000511 = dot(X0000472.rgb,float3(1. / float(3)));
						X0000510.set_importance(X0000511);
						indirect_raw = irradiance(X0000510) / 3.14159265358979323846;
						if(ao_on)
							{
								Occlusion_options X0000512;
								X0000512.set_near(float(0));
								X0000512.set_far(ao_distance);
								ao_raw = lerp(float4(float(1)),ao_dark,occlusion(X0000512));
							}
						indirect_post_ao = indirect_raw * ao_raw;
						indirect_result = X0000472 * indirect_post_ao;
						X0000453 += indirect_result;
						normal = -normal;
						Light_iterator X0000513;
						tran_level = X0000479;
						foreach(X0000513)
							{
								if(X0000479.a > 0.0)
									{
										float X0000514 = X0000513.dot_nl;
										if(X0000469)
											{
												X0000514 = dot(X0000513.direction,X0000464);
											}
										X0000514 /= 3.14159265358979323846;
										if(X0000514 > 0.0)
											{
												Color X0000515 = Color(X0000513.contribution * X0000514);
												tran_raw += X0000515;
												X0000455 += X0000515 * X0000479;
											}
									}
							}
						normal = -normal;
						tran_result = tran_raw * tran_level;
					}
				if(X0000473.a > 0.0)
					{
						X0000019(X0000456,refl_result,refl_raw,refl_level,refl_falloff_on,refl_falloff_dist,refl_falloff_color_on,refl_falloff_color,position,direction,normal,geometry_normal,dot_nd,X0000470,X0000473,X0000478,X0000496,X0000487,X0000486,X0000471,X0000467,X0000468,X0000488);
					}
				if(X0000474.a > 0.0)
					{
						X0000027(X0000457,refr_result,refr_raw,refr_level,backside,position,direction,normal,geometry_normal,dot_nd,X0000497,X0000474,X0000490,X0000489,X0000471,X0000476,X0000475,X0000467,X0000468,X0000491);
					}
				result = ((((X0000452 + X0000453) + X0000454) + X0000455) + X0000456) + X0000457;
				if(propagate_alpha)
					{
						result.a = result.a * (1.0 - X0000474.a) + X0000457.a * X0000474.a;
					}
				else
					{
						result.a = 1.0;
					}
				add_result = additional_color;
				result.rgb += add_result.rgb;
				result.r *= X0000499.r;
				result.g *= X0000499.g;
				result.b *= X0000499.b;
				result.a = result.a * X0000499.a + (1.0 - X0000499.a);
				result.r *= opacity;
				result.g *= opacity;
				result.b *= opacity;
				result.a *= opacity;
				if(opacity < float(1))
					{
						Ray X0000516;
						Ray X0000517 = Ray(float3(float(0)),float3(float(0)));
						Ray X0000518 = Ray(float3(float(0)),float3(float(0)));
						Trace_options X0000519;
						X0000516 = Ray(position,direction);
						X0000519.set_ray_type("transparent");
						trace(X0000516,X0000517,X0000518,X0000519,"result",opacity_raw);
						opacity_result = opacity_raw * (float(1) - opacity);
						result += opacity_result;
					}
			}
	}

};

/*** end of file ***/
