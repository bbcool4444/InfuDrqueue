<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Pyramid Filtering</title>
<meta http-equiv="content-type" content="text/html; charset=us-ascii" />
<meta name="author" content="mental images GmbH" />
<link href="mailto:office@mentalimages.com" rev="made" />
<link href="mental.css" rel="stylesheet" media="all" type="text/css" />
<link rel="shortcut icon" href="mentalicon.ico" type="image/x-icon" />
</head>
<body>
<ul class="nav">
<li><a href="index.html">home</a></li>
<li><a href="node22.html">&laquo;&nbsp;prev</a></li>
<li><a href="node24.html">next&nbsp;&raquo;</a></li>
<li><a href="globalindex.html">index</a></li>
</ul>
<a id="SECTION21"></a>
<h3>Pyramid Filtering</h3>
<p>This method can be used very easily with existing .mi files, it
is only necessary to add a "<tt>filter</tt> <i>scale</i>" modifier
to the texture load statements in the scene file. Here is an
example:</p>
<pre>
     local filter 0.8 color texture "tex_0" "mytexture.map"
</pre>
<p>The basic idea behind pyramid filtering is that when a pixel
rectangle (the current sampling location) is projected into texture
space, mental ray has to calculate the (weighted) average of all
texture pixels (texels) inside this area and return it for the
texture lookup. Using the average of the pixels, high frequencies
which cause aliasing are eliminated. To speed up this averaging,
the compression value is calculated for the current pixel location
which is the inverse size of the pixel in texture space. For
example, if the pixel has a projected size of four texels in
texture space, then one texel is compressed to 1/4 in the focal
plane (severe compression gives those aliasing artifacts).</p>
<p class="note"><b>Note:</b> for memory-mapped textures the filter
value in the .mi file is ignored, and filtering is not applied in
this case for technical reasons. As a workaround, it is possible to
specify the filter value when creating the texture with the
<tt>imf_copy</tt> tool with the <tt>-f</tt> option.</p>
<p>It is very costly to project a rectangle to texture space, so
usually the quadrilateral in texture space is approximated by a
square and the length of one side is used for the compression
value. The compression value is used as an index into the image
pyramid, and since this value has a fractional part, the two levels
that the value falls in between are looked up using bilinear
interpolation at each level, followed by a linear interpolation of
the two colors from the level lookups. (mental ray uses also
bilinear texture interpolation when no filtering is applied).</p>
<p>Just specifying "<tt>filter</tt> <i>scale</i> <tt>color
texture</tt>" is not sufficient for an exact projection of the
pixel to texture space. The <a href="node166.html#INDEX846">texture
shader</a> modifies the UV <a href="node108.html#INDEX409">texture
coordinate</a>s (either from specified texture surfaces or
generated by cylinder projections) according to remapping shader
parameters etc. the standard shader interface function
<i><a href="node150.html#INDEX741">mi_lookup_color_texture</a></i> provides
only the UV <a href="node108.html#INDEX409">texture coordinate</a>s
to mental ray, and it is almost impossible to project the pixel
corners to texture space since it is not known how to obtain
additional UV coordinates or how to remap them. The remapping is
done before <i>mi_lookup_color_texture</i> is called.</p>
<p>mental ray's implementation of pyramid mapping therefore adds a
vector to the current intersection point in
<a href="node101.html#INDEX369">object space</a> and transforms this point
into <a href="node101.html#INDEX371">raster space</a>. The length
of the offset vector is calculated by dividing the object extent by
the texture resolution (the larger value of width and height is
used). This approach assumes that texture space corresponds to
<a href="node101.html#INDEX369">object space</a> (that is, if the
object size is one object unit, the texture fully covers it). If a
texture shader applies texture replications, the filter value
should be set to the replication count or larger to adjust for this
effect. The compression value is calculated as the distance between
the raster position mentioned above and the current raster position
(using two variables provided to the shader,
<tt>state-&gt;raster_x</tt> and <tt>state-&gt;raster_y</tt> ).</p>
<p>Since this can not always attain satisfying results, mental ray
allows multiplication of a "user scaling" value - the <i>scale</i>
value in the <tt>filter</tt> statement. Using this value, it is
possible to reduce blurring ( <i>scale &lt; 1</i>) or increase
blurring ( <i>scale &gt; 1</i>). For example, if the texture is
replicated 10 times, which makes it appear smaller in
<a href="node101.html#INDEX371">raster space</a> and hence requires more
blurring, the filter constant should be multiplied by 10. Since
texture projections are handled by shaders and not by the mental
ray core, this cannot be done automatically.</p>
<p>Pyramid filtering also works when reflection or
<a href="node115.html#INDEX446">refraction</a> is used, but mathematical
correctness cannot be guaranteed since mental ray cannot take
reflection or refraction paths into account, for the same
reason.</p>
<ul class="nav">
<li><a href="index.html">home</a></li>
<li><a href="node22.html">&laquo;&nbsp;prev</a></li>
<li><a href="node24.html">next&nbsp;&raquo;</a></li>
<li><a href="globalindex.html">index</a></li>
</ul>
<p><a href="copyright.html">Copyright</a> &copy; 1986-2010 by
<a href="http://www.mental.com">mental images GmbH</a></p>
</body>
</html>
