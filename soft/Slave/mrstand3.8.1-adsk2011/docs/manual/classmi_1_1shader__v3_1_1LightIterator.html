<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mental ray Interface: mi::shader_v3::LightIterator Class Reference</title>
<link href="mi_iface.css" rel="stylesheet" type="text/css">
</head>
<body>
<ul class="nav">
<li><a href="index.html">home</a></li>
<li><a href="shader_if_cpp.html">up</a></li>
<li><a href="globalindex.html">index</a></li>
</ul>

<!-- Generated by Doxygen 1.5.6 -->
  <div class="navpath"><a class="el" href="namespacemi.html">mi</a>::<a class="el" href="namespacemi_1_1shader__v3.html">shader_v3</a>::<a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html">LightIterator</a>
  </div>
<div class="contents">
<h1>mi::shader_v3::LightIterator Class Reference</h1><!-- doxytag: class="mi::shader_v3::LightIterator" -->Iterate over shader or instance light lists.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="shader__lightlist_8h-source.html">shader_lightlist.h</a>&gt;</code>
<p>

<p>
<a href="classmi_1_1shader__v3_1_1LightIterator-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html#ac718a9cd15e60d735e17ab8467d7d80">LightIterator</a> (miState *state, miTag *shader_light_list=0, int n_shader_lights=0, int version=mi_ray_interface_version)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the constructor for the <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a>  <a href="#ac718a9cd15e60d735e17ab8467d7d80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html#c693ee71ac2e8c0c139457c4078c69c1">LightIterator</a> (miState *state, const miVector &amp;axis, miScalar spread_cos, miTag *shader_light_list=0, int n_shader_lights=0, int version=mi_ray_interface_version)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the constructor for the <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> with sampling cone.  <a href="#c693ee71ac2e8c0c139457c4078c69c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html#ef595af85583a8da86e358402ea9d99c">LightIterator</a> (const <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html">LightIterator</a> &amp;iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the copy constructor.  <a href="#ef595af85583a8da86e358402ea9d99c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html#1129815f7c2d15c205101a6fb0fab596">~LightIterator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the destructor  <a href="#1129815f7c2d15c205101a6fb0fab596"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">miTag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html#1cb264ffdbe0e1eb6164f8184d16f937">operator*</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">obtain the tag for the current light  <a href="#1cb264ffdbe0e1eb6164f8184d16f937"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmi_1_1shader__v3_1_1LightList.html">LightList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html#cf1a7f9818b20547f6149f934a0aa929">operator-&gt;</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">access to light list from iterator  <a href="#cf1a7f9818b20547f6149f934a0aa929"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html">LightIterator</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html#30ed07723f9bc6b5af2b7e7b09c486f8">operator++</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pre-increment operator  <a href="#30ed07723f9bc6b5af2b7e7b09c486f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html">LightIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html#de13f5f41c6d13756f65314dcc03b427">operator++</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">post-increment operator  <a href="#de13f5f41c6d13756f65314dcc03b427"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html#8829296f034bc662d04aa4a3a993f4ac">at_end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">check if iteration should continue.  <a href="#8829296f034bc662d04aa4a3a993f4ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html">LightIterator</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html#8137373c7fc70f2b774301bd5e4f2f04">operator=</a> (const <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html">LightIterator</a> &amp;iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">assign <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a>  <a href="#8137373c7fc70f2b774301bd5e4f2f04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html#9807e34f92369c389003cf8442c8eb10">operator==</a> (const <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html">LightIterator</a> &amp;iter) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">check if two LightIterators are equal  <a href="#9807e34f92369c389003cf8442c8eb10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html#19d274b36e21ea710282a4603d1b7375">operator!=</a> (const <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html">LightIterator</a> &amp;iter) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">check if two LightIterators are unequal.  <a href="#19d274b36e21ea710282a4603d1b7375"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Iterate over shader or instance light lists. 
<p>
mental ray 3.5 introduced the concept of instance light lists. These lists are not explicitly passed to the shader as a parameter. Instead mental ray makes them available through LightIterators. The <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> class allows shaders to iterate over lights for the purpose of sampling. A typical use would look like <div class="fragment"><pre class="fragment"> <span class="keywordflow">for</span> (mi::shader::LightIterator iter(state); !iter.at_end(); ++iter) {
     miColor col = {0,0,0,1};
     <span class="keywordflow">while</span> (iter-&gt;sample()) {
         miColor light_color;
         iter-&gt;get_contribution(&amp;light_color);
         col.r += light_color.r;
         col.g += light_color.g;
         col.b += light_color.b;
     }
     <span class="keyword">const</span> <span class="keywordtype">int</span> n_samples = iter-&gt;get_number_of_samples();
     <span class="keywordflow">if</span> (n_samples &gt; 1) {
         col.r /= n_samples;
         col.g /= n_samples;
         col.b /= n_samples;
     }
 }
</pre></div> <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="ac718a9cd15e60d735e17ab8467d7d80"></a><!-- doxytag: member="mi::shader_v3::LightIterator::LightIterator" ref="ac718a9cd15e60d735e17ab8467d7d80" args="(miState *state, miTag *shader_light_list=0, int n_shader_lights=0, int version=mi_ray_interface_version)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mi::shader_v3::LightIterator::LightIterator           </td>
          <td>(</td>
          <td class="paramtype">miState *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">miTag *&nbsp;</td>
          <td class="paramname"> <em>shader_light_list</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n_shader_lights</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>mi_ray_interface_version</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the constructor for the <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> 
<p>
Construct a <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> from state and an optional shader light list. Note that two different light lists may be assigned to instances: a light list and a shadow light list. During regular rendering the iterator uses the light list, but when either rendering shadow maps or tracing shadow rays, then the iterator prefers the shadow light list over the light list, that is, in these cases the light list will only be used if no shadow light list is present. It is also possible to instantiate the iterator with an explicit light list provided by the shader.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>provides the iterator with information about the rendering state, especially where to find the lights for the iteration. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shader_light_list</em>&nbsp;</td><td>allows to provide a custom list of lights for the iteration. This optional list overrides the instance light lists used by default. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_shader_lights</em>&nbsp;</td><td>tells the iterator the number of custom lights passed in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>allows to specify a specific interface version. By default this is set to the current interface version. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c693ee71ac2e8c0c139457c4078c69c1"></a><!-- doxytag: member="mi::shader_v3::LightIterator::LightIterator" ref="c693ee71ac2e8c0c139457c4078c69c1" args="(miState *state, const miVector &amp;axis, miScalar spread_cos, miTag *shader_light_list=0, int n_shader_lights=0, int version=mi_ray_interface_version)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mi::shader_v3::LightIterator::LightIterator           </td>
          <td>(</td>
          <td class="paramtype">miState *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const miVector &amp;&nbsp;</td>
          <td class="paramname"> <em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">miScalar&nbsp;</td>
          <td class="paramname"> <em>spread_cos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">miTag *&nbsp;</td>
          <td class="paramname"> <em>shader_light_list</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n_shader_lights</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>mi_ray_interface_version</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the constructor for the <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> with sampling cone. 
<p>
The cone for light samples is defined by axis and the cosine of the angle.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>provides the iterator with information about the rendering state, especially where to find the lights for the iteration. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td>specifies the axis for the light cone. The value should be normalized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spread_cos</em>&nbsp;</td><td>specifies the cosine of the angle to the light cone axis. The value 0 corresponds to a hemisphere, the value -1 to the complete sphere. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shader_light_list</em>&nbsp;</td><td>allows to provide a custom list of lights for the iteration. This optional list overrides the instance light lists used by default. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_shader_lights</em>&nbsp;</td><td>tells the iterator the number of custom lights passed in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>allows to specify a specific interface version. By default this is set to the current interface version. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ef595af85583a8da86e358402ea9d99c"></a><!-- doxytag: member="mi::shader_v3::LightIterator::LightIterator" ref="ef595af85583a8da86e358402ea9d99c" args="(const LightIterator &amp;iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mi::shader_v3::LightIterator::LightIterator           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html">LightIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the copy constructor. 
<p>
creates a copy of a given <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a>. This constructor is needed to return LightIterators from methods.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>the <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> to be copied. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="classmi_1_1shader__v3_1_1LightList.html#6c1a0f200a32fa1030e20413f81d1610">mi::shader_v3::LightList::connect()</a>.</p>

</div>
</div><p>
<a class="anchor" name="1129815f7c2d15c205101a6fb0fab596"></a><!-- doxytag: member="mi::shader_v3::LightIterator::~LightIterator" ref="1129815f7c2d15c205101a6fb0fab596" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mi::shader_v3::LightIterator::~LightIterator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the destructor 
<p>
The destructor for a <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> instance is called when it goes out of scope. It releases all resources associated with this instance. 
<p>References <a class="el" href="classmi_1_1shader__v3_1_1LightList.html#664882fddb11ce1bfcbec3ee4a5ef2d2">mi::shader_v3::LightList::release()</a>.</p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="1cb264ffdbe0e1eb6164f8184d16f937"></a><!-- doxytag: member="mi::shader_v3::LightIterator::operator*" ref="1cb264ffdbe0e1eb6164f8184d16f937" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">miTag mi::shader_v3::LightIterator::operator*           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
obtain the tag for the current light 
<p>
dereferencing a <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> with the unary prefix operator '*' yields the tag of the current light. Note that this operation is distinctly different from dereferencing a <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> with the postfix operator '-&gt;'.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the tag of the current light in the light list. </dd></dl>

<p>References <a class="el" href="classmi_1_1shader__v3_1_1LightList.html#7fc1b496e511af71506e50ac701230bf">mi::shader_v3::LightList::get_light_tag()</a>.</p>

</div>
</div><p>
<a class="anchor" name="cf1a7f9818b20547f6149f934a0aa929"></a><!-- doxytag: member="mi::shader_v3::LightIterator::operator-&gt;" ref="cf1a7f9818b20547f6149f934a0aa929" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmi_1_1shader__v3_1_1LightList.html">LightList</a> * mi::shader_v3::LightIterator::operator-&gt;           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
access to light list from iterator 
<p>
the postfix dereference operator allows to invoke public methods of the <a class="el" href="classmi_1_1shader__v3_1_1LightList.html" title="Light lists, used internally by LightIterator.">LightList</a> class from the <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the <a class="el" href="classmi_1_1shader__v3_1_1LightList.html" title="Light lists, used internally by LightIterator.">LightList</a> associated with the <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a>. Note that the <a class="el" href="classmi_1_1shader__v3_1_1LightList.html" title="Light lists, used internally by LightIterator.">LightList</a> pointer is not available for direct use. Instead C++ will immediately use it to invoke the <a class="el" href="classmi_1_1shader__v3_1_1LightList.html" title="Light lists, used internally by LightIterator.">LightList</a> method written to the right of the '-&gt;' operator. For example, <div class="fragment"><pre class="fragment"> <a class="code" href="classmi_1_1shader__v3_1_1LightIterator.html#ac718a9cd15e60d735e17ab8467d7d80" title="the constructor for the LightIterator">LightIterator</a> iter(state)-&gt;sample();
</pre></div> will invoke the sample method of the <a class="el" href="classmi_1_1shader__v3_1_1LightList.html" title="Light lists, used internally by LightIterator.">LightList</a> class. </dd></dl>

<p>References <a class="el" href="classmi_1_1shader__v3_1_1LightList.html#8f39078ac3dc3c627350a3ed156f0fbb">mi::shader_v3::LightList::set_current()</a>.</p>

</div>
</div><p>
<a class="anchor" name="30ed07723f9bc6b5af2b7e7b09c486f8"></a><!-- doxytag: member="mi::shader_v3::LightIterator::operator++" ref="30ed07723f9bc6b5af2b7e7b09c486f8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html">LightIterator</a> &amp; mi::shader_v3::LightIterator::operator++           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
pre-increment operator 
<p>
The operator advances the <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> to the next light in the light list. The pre-increment operator should be preferred over the post-increment operator, since it avoids the generation of a temporary <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a>.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a constant reference of the iterator </dd></dl>

</div>
</div><p>
<a class="anchor" name="de13f5f41c6d13756f65314dcc03b427"></a><!-- doxytag: member="mi::shader_v3::LightIterator::operator++" ref="de13f5f41c6d13756f65314dcc03b427" args="(int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html">LightIterator</a> mi::shader_v3::LightIterator::operator++           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
post-increment operator 
<p>
The increment operator advances the <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> to the next light in the light list. The post-increment operator is more expensive than the pre-increment operator, since it need to construct an extra copy of the iterator.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a copy of the <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> before it was advanced to the next light. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8829296f034bc662d04aa4a3a993f4ac"></a><!-- doxytag: member="mi::shader_v3::LightIterator::at_end" ref="8829296f034bc662d04aa4a3a993f4ac" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mi::shader_v3::LightIterator::at_end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
check if iteration should continue. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the end of the light list has been reached, false otherwise. </dd></dl>

<p>References <a class="el" href="classmi_1_1shader__v3_1_1LightList.html#5bd5d7b4be9c83ea8c42f78545cc7ee3">mi::shader_v3::LightList::get_number_of_lights()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8137373c7fc70f2b774301bd5e4f2f04"></a><!-- doxytag: member="mi::shader_v3::LightIterator::operator=" ref="8137373c7fc70f2b774301bd5e4f2f04" args="(const LightIterator &amp;iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html">LightIterator</a> &amp; mi::shader_v3::LightIterator::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html">LightIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
assign <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> 
<p>
Assign a <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> to this <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a>. If the two iterators refer to different light lists, make sure that proper reference counting is performed on the two lists.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>gives the <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> to be assigned </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a constant reference to the <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> that has been assigned to. </dd></dl>

<p>References <a class="el" href="classmi_1_1shader__v3_1_1LightList.html#6c1a0f200a32fa1030e20413f81d1610">mi::shader_v3::LightList::connect()</a>, <a class="el" href="shader__lightlist_8h-source.html#l00215">m_current</a>, <a class="el" href="shader__lightlist_8h-source.html#l00210">m_list</a>, and <a class="el" href="classmi_1_1shader__v3_1_1LightList.html#664882fddb11ce1bfcbec3ee4a5ef2d2">mi::shader_v3::LightList::release()</a>.</p>

</div>
</div><p>
<a class="anchor" name="9807e34f92369c389003cf8442c8eb10"></a><!-- doxytag: member="mi::shader_v3::LightIterator::operator==" ref="9807e34f92369c389003cf8442c8eb10" args="(const LightIterator &amp;iter) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mi::shader_v3::LightIterator::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html">LightIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
check if two LightIterators are equal 
<p>
Two LightIterators are considered equal if they refer to the same light list and have the same current light within the list.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the two iterators are equal, false else. </dd></dl>

<p>References <a class="el" href="shader__lightlist_8h-source.html#l00215">m_current</a>, and <a class="el" href="shader__lightlist_8h-source.html#l00210">m_list</a>.</p>

<p>Referenced by <a class="el" href="shader__lightlist_8h-source.html#l00416">operator!=()</a>.</p>

</div>
</div><p>
<a class="anchor" name="19d274b36e21ea710282a4603d1b7375"></a><!-- doxytag: member="mi::shader_v3::LightIterator::operator!=" ref="19d274b36e21ea710282a4603d1b7375" args="(const LightIterator &amp;iter) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mi::shader_v3::LightIterator::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html">LightIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
check if two LightIterators are unequal. 
<p>
Two LightIterators are unequal if they do not refer to the same <a class="el" href="classmi_1_1shader__v3_1_1LightList.html" title="Light lists, used internally by LightIterator.">LightList</a> or have two different current lights within the list.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the two iterators are unequal, false else. </dd></dl>

<p>References <a class="el" href="shader__lightlist_8h-source.html#l00411">operator==()</a>.</p>

</div>
</div><p>
</div>

<ul class="nav">
<li><a href="index.html">home</a></li>
<li><a href="shader_if_cpp.html">up</a></li>
<li><a href="globalindex.html">index</a></li>
</ul>
<p><a href="copyright.html">Copyright</a> &copy; 1986-2010 by
<a href="http://www.mental.com">mental images GmbH</a><br></p>
</body>
</html>

