<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Geometric Objects</title>
<meta http-equiv="content-type" content="text/html; charset=us-ascii" />
<meta name="author" content="mental images GmbH" />
<link href="mailto:office@mentalimages.com" rev="made" />
<link href="mental.css" rel="stylesheet" media="all" type="text/css" />
<link rel="shortcut icon" href="mentalicon.ico" type="image/x-icon" />
</head>
<body>
<ul class="nav">
<li><a href="index.html">home</a></li>
<li><a href="node188.html">&laquo;&nbsp;prev</a></li>
<li><a href="assembly_api.html">next&nbsp;&raquo;</a></li>
<li><a href="globalindex.html">index</a></li>
</ul>

<a id="SECTION187"></a>

<ul class="nav tag">
<li><a href="#api:mi_api_basis_add">mi_api_basis_add</a></li>
<li><a href="#api:mi_api_basis_list_clear">mi_api_basis_list_clear</a></li>
<li><a href="#api:mi_api_basis_lookup">mi_api_basis_lookup</a></li>
<li><a href="#api:mi_api_ccmesh_approx">mi_api_ccmesh_approx</a></li>
<li><a href="#api:mi_api_ccmesh_begin">mi_api_ccmesh_begin</a></li>
<li><a href="#api:mi_api_ccmesh_crease">mi_api_ccmesh_crease</a></li>
<li><a href="#api:mi_api_ccmesh_derivative">mi_api_ccmesh_derivative</a></li>
<li><a href="#api:mi_api_ccmesh_end">mi_api_ccmesh_end</a></li>
<li><a href="#api:mi_api_ccmesh_polygon">mi_api_ccmesh_polygon</a></li>
<li><a href="#api:mi_api_curve_approx">mi_api_curve_approx</a></li>
<li><a href="#api:mi_api_curve_begin">mi_api_curve_begin</a></li>
<li><a href="#api:mi_api_curve_end">mi_api_curve_end</a></li>
<li><a href="#api:mi_api_curve_specpnt">mi_api_curve_specpnt</a></li>
<li><a href="#api:mi_api_geovector_xyz_add">mi_api_geovector_xyz_add</a></li>
<li><a href="#api:mi_api_hair_begin">mi_api_hair_begin</a></li>
<li><a href="#api:mi_api_hair_end">mi_api_hair_end</a></li>
<li><a href="#api:mi_api_hair_hairs_add">mi_api_hair_hairs_add</a></li>
<li><a href="#api:mi_api_hair_hairs_begin">mi_api_hair_hairs_begin</a></li>
<li><a href="#api:mi_api_hair_hairs_end">mi_api_hair_hairs_end</a></li>
<li><a href="#api:mi_api_hair_info">mi_api_hair_info</a></li>
<li><a href="#api:mi_api_hair_scalars_begin">mi_api_hair_scalars_begin</a></li>
<li><a href="#api:mi_api_hair_scalars_end">mi_api_hair_scalars_end</a></li>
<li><a href="#api:mi_api_object_begin">mi_api_object_begin</a></li>
<li><a href="#api:mi_api_object_callback">mi_api_object_callback</a></li>
<li><a href="#api:mi_api_object_end">mi_api_object_end</a></li>
<li><a href="#api:mi_api_object_file">mi_api_object_file</a></li>
<li><a href="#api:mi_api_object_group_begin">mi_api_object_group_begin</a></li>
<li><a href="#api:mi_api_object_group_connection">mi_api_object_group_connection</a></li>
<li><a href="#api:mi_api_object_group_end">mi_api_object_group_end</a></li>
<li><a href="#api:mi_api_object_matrix">mi_api_object_matrix</a></li>
<li><a href="#api:mi_api_object_placeholder_callback">mi_api_object_placeholder_callback</a></li>
<li><a href="#api:mi_api_poly_approx">mi_api_poly_approx</a></li>
<li><a href="#api:mi_api_poly_begin">mi_api_poly_begin</a></li>
<li><a href="#api:mi_api_poly_end">mi_api_poly_end</a></li>
<li><a href="#api:mi_api_poly_index_add">mi_api_poly_index_add</a></li>
<li><a href="#api:mi_api_poly_hole_add">mi_api_poly_hole_add</a></li>
<li><a href="#api:mi_api_primlist_approx">mi_api_primlist_approx</a></li>
<li><a href="#api:mi_api_primlist_begin">mi_api_primlist_begin</a></li>
<li><a href="#api:mi_api_primlist_begin_2">mi_api_primlist_begin_2</a></li>
<li><a href="#api:mi_api_primlist_dimensions">mi_api_primlist_dimensions</a></li>
<li><a href="#api:mi_api_primlist_end">mi_api_primlist_end</a></li>
<li><a href="#api:mi_api_spacecurve_approx">mi_api_spacecurve_approx</a></li>
<li><a href="#api:mi_api_spacecurve_begin">mi_api_spacecurve_begin</a></li>
<li><a href="#api:mi_api_spacecurve_curveseg">mi_api_spacecurve_curveseg</a></li>
<li><a href="#api:mi_api_spacecurve_end">mi_api_spacecurve_end</a></li>
<li><a href="#api:mi_api_subdivsurf_approx">mi_api_subdivsurf_approx</a></li>
<li><a href="#api:mi_api_subdivsurf_approx_displace">mi_api_subdivsurf_approx_displace</a></li>
<li><a href="#api:mi_api_subdivsurf_baseface">mi_api_subdivsurf_baseface</a></li>
<li><a href="#api:mi_api_subdivsurf_begin">mi_api_subdivsurf_begin</a></li>
<li><a href="#api:mi_api_subdivsurf_crease">mi_api_subdivsurf_crease</a></li>
<li><a href="#api:mi_api_subdivsurf_crease_edge">mi_api_subdivsurf_crease_edge</a></li>
<li><a href="#api:mi_api_subdivsurf_derivative">mi_api_subdivsurf_derivative</a></li>
<li><a href="#api:mi_api_subdivsurf_detail">mi_api_subdivsurf_detail</a></li>
<li><a href="#api:mi_api_subdivsurf_end">mi_api_subdivsurf_end</a></li>
<li><a href="#api:mi_api_subdivsurf_index">mi_api_subdivsurf_index</a></li>
<li><a href="#api:mi_api_subdivsurf_mtl">mi_api_subdivsurf_mtl</a></li>
<li><a href="#api:mi_api_subdivsurf_mtl_tag">mi_api_subdivsurf_mtl_tag</a></li>
<li><a href="#api:mi_api_subdivsurf_pop">mi_api_subdivsurf_pop</a></li>
<li><a href="#api:mi_api_subdivsurf_push">mi_api_subdivsurf_push</a></li>
<li><a href="#api:mi_api_subdivsurf_subdivide">mi_api_subdivsurf_subdivide</a></li>
<li><a href="#api:mi_api_subdivsurf_texspace">mi_api_subdivsurf_texspace</a></li>
<li><a href="#api:mi_api_subdivsurf_trim">mi_api_subdivsurf_trim</a></li>
<li><a href="#api:mi_api_surface_approx">mi_api_surface_approx</a></li>
<li><a href="#api:mi_api_surface_approx_displace">mi_api_surface_approx_displace</a></li>
<li><a href="#api:mi_api_surface_approx_trim">mi_api_surface_approx_trim</a></li>
<li><a href="#api:mi_api_surface_begin">mi_api_surface_begin</a></li>
<li><a href="#api:mi_api_surface_begin_tag">mi_api_surface_begin_tag</a></li>
<li><a href="#api:mi_api_surface_curveseg">mi_api_surface_curveseg</a></li>
<li><a href="#api:mi_api_surface_derivative">mi_api_surface_derivative</a></li>
<li><a href="#api:mi_api_surface_end">mi_api_surface_end</a></li>
<li><a href="#api:mi_api_surface_params">mi_api_surface_params</a></li>
<li><a href="#api:mi_api_surface_specpnt">mi_api_surface_specpnt</a></li>
<li><a href="#api:mi_api_surface_texture_begin">mi_api_surface_texture_begin</a></li>
<li><a href="#api:mi_api_trilist_approx">mi_api_trilist_approx</a></li>
<li><a href="#api:mi_api_trilist_begin">mi_api_trilist_begin</a></li>
<li><a href="#api:mi_api_trilist_end">mi_api_trilist_end</a></li>
<li><a href="#api:mi_api_trilist_triangle">mi_api_trilist_triangle</a></li>
<li><a href="#api:mi_api_trilist_triangles">mi_api_trilist_triangles</a></li>
<li><a href="#api:mi_api_trilist_vectors">mi_api_trilist_vectors</a></li>
<li><a href="#api:mi_api_trilist_vertices">mi_api_trilist_vertices</a></li>
<li><a href="#api:mi_api_vector_lookup">mi_api_vector_lookup</a></li>
<li><a href="#api:mi_api_vector_xyz_add">mi_api_vector_xyz_add</a></li>
<li><a href="#api:mi_api_vertex_add">mi_api_vertex_add</a></li>
<li><a href="#api:mi_api_vertex_deriv_add">mi_api_vertex_deriv_add</a></li>
<li><a href="#api:mi_api_vertex_deriv2_add">mi_api_vertex_deriv2_add</a></li>
<li><a href="#api:mi_api_vertex_flags_add">mi_api_vertex_flags_add</a></li>
<li><a href="#api:mi_api_vertex_lookup">mi_api_vertex_lookup</a></li>
<li><a href="#api:mi_api_vertex_motion_add">mi_api_vertex_motion_add</a></li>
<li><a href="#api:mi_api_vertex_normal_add">mi_api_vertex_normal_add</a></li>
<li><a href="#api:mi_api_vertex_ref_add">mi_api_vertex_ref_add</a></li>
<li><a href="#api:mi_api_vertex_tex_add">mi_api_vertex_tex_add</a></li>
<li><a href="#api:mi_api_vertex_user_add">mi_api_vertex_user_add</a></li>
</ul>

<h3>Geometric Objects</h3>

<ul class="toc">
<li><a href="#api:object">Objects</a>
<li><a href="#api:base">Bases</a>
<li><a href="#api:poly">Polygonal Geometry</a>
<li><a href="#api:surface">Free-Form Surface Geometry</a>
<li><a href="#api:curve">Curves</a>
<li><a href="#api:spacecurve">Space Curves</a>
<li><a href="#api:hair">Hair</a>
<li><a href="#api:sds">Subdivision Surfaces</a>
<li><a href="#api:ccmesh">Catmull-Clark Meshes</a>
<li><a href="#api:primlist">Primitive List Objects</a>
<li><a href="#api:trilist">Triangle List Objects</a>
</ul>
<p>Geometric objects can be divided into polygonal, free-form and subdivision
surface, and curve geometry. Each object contains one (or more)
<a href="node83.html#mi:group">object group</a>s that define geometry.
Multiple object groups are supported for backwards compatibility; new designs
should create multiple objects rather than a single object with multiple
<a href="node83.html#mi:group">object group</a>s. Object groups are unrelated
to instance groups as described above.</p>

<h4 id="api:object">Objects</h4>

<a id="INDEX942"></a>
<h5 class="anchor" id="api:mi_api_object_begin">mi_api_object_begin</h5>
<pre>
    miObject *mi_api_object_begin(
        char            *name)     /* object name */
</pre>
<p class="brief">Begin the definition of an object with the given <i>name</i>.
</p><p>
If the <i>name</i> parameter is zero, the object is not registered in
the symbol tables, so it cannot be referenced by name. In this case
the tag returned by <i>mi_api_object_end</i> can be used to reference
the object. All geometrical information is deleted regardless of incremental
mode. This is the first call of the object definition sequence. After the
object begin, first bases are defined if the object contains free-form
surfaces. Next, the <a href="node83.html#mi:group">object group</a> (or
groups) must be defined. The returned <tt>miObject</tt> pointer can be used
to write the <tt>visible</tt> and other flags into the object. Note, that
since the final size of the object is not known at this point, the returned
pointer points to a temporary structure that does not contain geometry and
will be deleted by <i>mi_api_object_end</i>.</p>

<a id="INDEX943"></a>
<h5 class="anchor" id="api:mi_api_object_matrix">mi_api_object_matrix</h5>
<pre>
    miBoolean *mi_api_object_matrix(
        miMatrix        transform)
</pre>
<p><span class="depr">Deprecated</span> Store the object's texture transformation
matrix. It is kept for backwards compatibility only.</p>

<a id="INDEX944"></a>
<h5 class="anchor" id="api:mi_api_object_group_begin">mi_api_object_group_begin</h5>
<pre>
    miBoolean mi_api_object_group_begin(
        double          merge)     /* merge epsilon */
</pre>
<p class="brief">Begin the definition of a group.</p>
<p>The next step after the begin call is beginning an
<a href="node83.html#mi:group">object group</a>. The <i>merge</i> argument is
obsolete and must be set to 0.0.</p>

<a id="INDEX945"></a>
<h5 class="anchor" id="api:mi_api_object_group_connection">mi_api_object_group_connection</h5>
<pre>
    miBoolean mi_api_object_group_connection(
        char            *surfname1,   /* first surface */
        char            *curvename1,  /* first curve */
        miGeoRange      *range1,      /* of first curve */
        char            *surfname2,   /* second surface */
        char            *curvename2,  /* second curve */
        miGeoRange      *range2)      /* of second curve */
</pre>
<p class="brief">Define connections of free-form surfaces.</p>
<p>After all surfaces in the free-form object have been defined, just before
<i>mi_api_object_group_end</i> is called, this function can be used to
establish connections between surfaces. Connections can only be defined
along the trimming curves on the surfaces, which must exist. Untrimmed
surfaces cannot be connected, but a trivial trim curve that follows the
parameter boundaries such that no part is actually trimmed off is simple
to create. A <a href="node85.html#INDEX309">parameter range</a> must be
specified for both curves.</p>

<a id="INDEX946"></a>
<h5 class="anchor" id="api:mi_api_object_group_end">mi_api_object_group_end</h5>
<pre>
    miBoolean mi_api_object_group_end(void)
</pre>
<p class="brief">End the definition of a group.</p>
<p>After all geometry in the <a href="node83.html#mi:group">object group</a>
has been defined, this function completes the
<a href="node83.html#mi:group">object group</a> definition. Another group can
be started after ending the current one.</p>

<a id="INDEX947"></a>
<h5 class="anchor" id="api:mi_api_object_file">mi_api_object_file</h5>
<pre>
    miBoolean mi_api_object_file(
        char            *file)
</pre>
<p class="brief">Load an object definition from a file.</p>
<p>Instead of explicitly defining geometry with
<i><a href="node189.html#INDEX944">mi_api_object_group_begin</a></i> and
<i><a href="node189.html#INDEX946">mi_api_object_group_end</a></i>, define
the object as a <var>placeholder</var> object. This requires that a bounding
box and, if applicable, a motion bounding box and a max displacement are
defined in the object. mental ray will read the object from the specified
.mi scene file <i>file</i> when it needs the geometry during rendering only.
The <i>file</i> must define the exact same object, including the name and all
flags and options, except that it must contain the actual geometry bracketed
with <tt>group</tt> and <tt>end group</tt>. Note, that placeholder objects can
 only contain a single <a href="node83.html#mi:group">object group</a>.</p>

<a id="INDEX948"></a>
<h5 class="anchor" id="api:mi_api_object_callback">mi_api_object_callback</h5>
<pre>
    typedef miBoolean (*miApi_object_callback)(miTag, void *);

    miBoolean mi_api_object_callback(
        miApi_object_callback cb,
        void                  *data)
</pre>
<p class="brief">Create an object definition in a custom callback function.</p>
<p>This is an alternative way to load a <var>placeholder</var> object, but
instead of reading a file mental ray will call the callback <i>cb</i>.
The callback receives the opaque data pointer <i>data</i> (intended to
pass C++ <i>this</i> pointers, for example), and the tag of the object to
define. The callback must then look up the name
(<i><a href="node182.html#INDEX867">mi_api_tag_lookup</a></i>), enter
incremental mode (<i>mi_api_incremental</i>), and redefine the object from
scratch, this time with complete geometry. It is important that the object
has only a single <a href="node83.html#mi:group">object group</a>. The
function may add a user data tag by looking up an existing userdata block
and assign it, but it may not create a new one (it would be leaked because
nobody is going to delete it later).</p>
<p>
mental ray copies the object flags and label automatically, the callback has
no control over them. If the callback does not set the bounding boxes, max
displace, or ray offset, mental ray will copy them automatically too. Note,
that the callback may provide smaller bounding boxes and max displace than
originally specified, in case it has better knowledge about the object and
can provide tighter bounding boxes, but it may never enlarge them. In previous
versions of mental ray, the callback had to specify the same flags, the same
label, and the same or smaller bounding box, motion bounding box, max displace,
and ray offset values.</p>
<p>
This is the recommended method for defining large objects with
<a href="node179.html#INDEX857">geometry shader</a>s, and for integrations
applications which support multi-threading and asynchronous translation,
because no memory or time is spent until the object is actually needed for
rendering. If memory runs out (see
<i><a href="node156.html#api:mi_mem_memory_limit">mi_mem_memory_limit</a></i>),
mental ray can dispose of the object from the cache to make room for more
important data. It could not throw out normal geometry shader-generated objects
because they cannot be rebuilt on demand. Also, mental ray may run different
object callbacks in parallel if necessary.</p>

<h5 class="anchor" id="api:mi_api_object_placeholder_callback">mi_api_object_placeholder_callback</h5>
<pre>
    typedef miBoolean (*miApi_object_placeholder_callback) (miTag, miObject *, void *);

    miBoolean mi_api_object_placeholder_callback(
        miApi_object_placeholder_callback cb_create,
        miApi_object_placeholder_callback cb_delete, void *data);

</pre>
<p class="brief">
Create and delete an object definition in a custom callback function.</p>
<p>This function may be used instead of <tt>mi_api_object_callback()</tt>.
The syntax is unified with other callbacks in mental ray like those for
user data and texture elements: two functions can be specified which are called
upon create and delete events, both receiving the same object tag. The
separate delete function is optional. The callback gets the object tag being
created (which should only be used for name lookups), a <code>miObject</code>
pointer (<code>NULL</code> for the create, non-null for delete callback), and
always passes the custom <var>data</var> pointer of the application. If the
same function is installed for both create and delete callbacks, it can detect
the type of the call by checking if the <code>miObject</code> pointer argument
is <code>NULL</code>.</p>

<a id="INDEX949"></a>
<h5 class="anchor" id="api:mi_api_object_end">mi_api_object_end</h5>
<pre>
    miTag mi_api_object_end(void)
</pre>
<p class="brief">Complete the definition of the object.</p>
<p>This is the last call of the object definition sequence. If an error
occurs, a null tag is returned; otherwise the tag of the new object or group
element is returned. API decides whether to create and return an object or an
instance group element based on the object complexity: if it has multiple
object groups or connections, an instance group is created that has the
<i>merge_group</i> flag set, and references one or more instances, each of
which references an object element containing a single
<a href="node83.html#mi:group">object group</a>. If there is only one such
group and no connections, the object is created and returned directly without
creating intermediate instances or connections. This decision is transparent
to the caller; the tessellator accepts instance groups in this case as well
as objects. The type of the returned element is either <tt>miSCENE_OBJECT</tt>
or <tt>miSCENE_GROUP</tt>.</p>

<h4 id="api:base">Bases</h4>

<p>Objects containing free-form surfaces must contain at least one
basis. A basis defines the curve type or one of the two surface
parameter axis types (e.g., NURBS or B&eacute;zier), a rational
flag, and the degree. All surfaces in all
<a href="node83.html#mi:group">object group</a>s of an object share the
same basis list in the object, and reference bases by name.</p>

<a id="INDEX950"></a>
<h5 class="anchor" id="api:mi_api_basis_list_clear">mi_api_basis_list_clear</h5>
<pre>
    miBoolean mi_api_basis_list_clear(void)
</pre>
<p class="brief">Delete all bases in the current object basis list.</p>
<p>This function is largely obsolete because it is implicitly called when
beginning and ending objects.</p>

<a id="INDEX951"></a>
<h5 class="anchor" id="api:mi_api_basis_add">mi_api_basis_add</h5>
<pre>
    miBoolean mi_api_basis_add(
        char              *name,    /* name of basis */
        miBoolean         rational, /* rational surface? */
        enum miBasis_type type,     /* basis type */
        miUshort          degree,   /* degree of basis */
        miUshort          stepsize, /* opt. step size */
        miDlist           *matrix)  /* opt. basis matrix */
</pre>
<p class="brief">Append a basis to the basis list of the current object.</p>
<p>The basis <i>name</i>, a <i>rational</i> flag, the basis <i>type</i>,
and the <i>degree</i> must be defined. The matrix <i>stepsize</i>
and the basis <i>matrix</i> must be defined only for the basis
matrix type. The matrix is passed as a dlist (dynamic list, see
above) because its size depends on the degree of the basis;
<span class="math">(degree+1)<sup>2</sup></span> floating-point numbers
of type <tt>miGeoScalar</tt> are expected.</p>

<a id="INDEX952"></a>
<h5 class="anchor" id="api:mi_api_basis_lookup">mi_api_basis_lookup</h5>
<pre>
    miGeoIndex mi_api_basis_lookup(
        char            *name,      /* basis to look up */
        miBoolean       *rational,  /* rational flag */
        miUshort        *degree)    /* returned degree */
</pre>
<p class="brief">Look up a basis by name.</p>
<p>The sequential number of the basis in the object's basis list is returned,
as well as the rational flag and the degree if the second and third
arguments are non-null pointers. This function is not essential for
scene definition.</p>

<h4 id="api:poly">Polygonal Geometry</h4>

<p>Polygonal geometry requires the definition of three blocks of data:
vectors, vertices, and polygons. Optionally, an approximation may be given
which is used by the tessellator for displacement-mapped polygons.</p>

<a id="INDEX953"></a><a id="INDEX954"></a>
<h5>
<span class="anchor" id="api:mi_api_geovector_xyz_add">mi_api_geovector_xyz_add</span>
<br /><span class="anchor" id="api:mi_api_vector_xyz_add">mi_api_vector_xyz_add</span>
</h5>
<pre>
    miBoolean mi_api_geovector_xyz_add(
        miGeoVector     *newvec)   /* vector to append */

    miBoolean mi_api_vector_xyz_add(
        miVector        *newvec)   /* vector to append */
</pre>
<p class="brief">Add a vector to the current vector list.</p>
<p>After beginning the <a href="node83.html#mi:group">object
group</a> that should contain polygonal geometry, calls to this function for
every <span class="math">(x,y,z)</span> vector to be used must be done.
Vectors will be referenced by sequential number, beginning with 0 in every
<a href="node83.html#mi:group">object group</a>, to be used as
points in space, normals, motion vectors, and various other
purposes. There are restrictions of vector sharing; for example, a
vector cannot be used as a point in space and a normal at the same
time. Also, vectors should be listed in a certain order (points in
space first, then normals, and so on) for maximum efficiency. Any
other order will be re-sorted automatically.</p>
<p>There are two versions of this call. The first accepts
double-precision vectors and the second accepts single-precision
vectors. Both store the vectors in double precision. If the vector
is available in double precision, always use
<i><a href="node189.html#INDEX954">mi_api_geovector_xyz_add</a></i>
to avoid precision loss. Both versions can be mixed, they are identical
except for the argument type.</p>

<a id="INDEX955"></a>
<h5 class="anchor" id="api:mi_api_vector_lookup">mi_api_vector_lookup</h5>
<pre>
    miBoolean mi_api_vector_lookup(
        miGeoVector     *pos,      /* vertex position */
        int             idx)       /* index of vector */
</pre>
<p class="brief">Look up a vector by index.</p>
<p>This function looks up a vector in the current object by index,
and returns its value. This function is not essential for scene definition.</p>

<a id="INDEX956"></a>
<a id="api:mi_api_vertex_add"></a>
<a id="api:mi_api_vertex_deriv_add"></a>
<a id="api:mi_api_vertex_deriv2_add"></a>
<a id="api:mi_api_vertex_motion_add"></a>
<a id="api:mi_api_vertex_normal_add"></a>
<a id="api:mi_api_vertex_tex_add"></a>
<a id="api:mi_api_vertex_user_add"></a>
<h5 class="anchor">mi_api_vertex_add<br />
mi_api_vertex_deriv_add<br />
mi_api_vertex_deriv2_add<br />
mi_api_vertex_motion_add<br />
mi_api_vertex_normal_add<br />
mi_api_vertex_tex_add<br />
mi_api_vertex_user_add</h5>
</h5>
<pre>
    miBoolean mi_api_vertex_add(
        int             p)         /* point in space */

    miBoolean mi_api_vertex_deriv_add(
        int             u,         /* dPdu derivative */
        int             v)         /* dPdv derivative */

    miBoolean mi_api_vertex_deriv2_add(
        int             u,         /* d2Pdu2 derivative */
        int             v,         /* d2Pdv2 derivative */
        int             uv)        /* d2Pduv derivative */

    miBoolean mi_api_vertex_motion_add(
        int             m)         /* motion vector */

    miBoolean mi_api_vertex_normal_add(
        int             n)         /* normal vector */

    miBoolean mi_api_vertex_tex_add(
        int             t,         /* texture parameter vector */
        int             x,         /* X basis vec or -1 */
        int             y)         /* Y basis vec or -1 */

    miBoolean mi_api_vertex_user_add(
        int             u)         /* user vector */
</pre>
<p class="brief">Add a vertex and optional data to the current vertex list.</p>
<p>After all vectors have been defined, vertices must be defined.
Vertices must contain a point in space, defined with <i>mi_api_vertex_add</i>,
optionally followed by a normal, first and second surface derivatives, one or
more texture vectors with optional bump basis vectors, a motion vector, and
one or more user vectors. After the initial point in space, the order of the
other calls is fixed. Vectors are referenced by sequential number in the
<a href="node83.html#mi:group">object group</a>, with 0 being the first
vector. A vector index <i>-1</i> means "none," which is useful for defining
texture vectors without bump basis vectors. Either no or two bump basis vector
indices must be given. All <i>add</i> functions until the next call to
<i>mi_api_vertex_add</i> or the end of the vertex list append to the current
vertex. The next <i>mi_api_vertex_add</i> begins the next vertex.</p>

<a id="INDEX957"></a>
<h5 class="anchor" id="api:mi_api_vertex_lookup">mi_api_vertex_lookup</h5>
<pre>
    miBoolean mi_api_vertex_lookup(
        miGeoVector     *pos,      /* vertex position */
        int             idx)       /* index of vertex */
</pre>
<p class="brief">Look up a vertex by index.</p>
<p>This functions looks up the point in space of the vertex specified by
the index <i>idx</i>. Vertices, like vectors, are sequentially beginning
with 0 in every <a href="node83.html#mi:group">object group</a>. This
function is not essential for scene definition.</p>

<a id="INDEX958"></a><a id="INDEX959"></a>
<h5 class="anchor" id="api:mi_api_poly_begin">mi_api_poly_begin</h5>
<pre>
    miBoolean mi_api_poly_begin(
        int             type,      /* 0=concave, 1=convex */
        char            *material) /* material name */

    miBoolean mi_api_poly_begin_tag(
        int             type,       /* 0=concave, 1=convex */
        miTag           material)   /* material tag */
</pre>
<p class="brief">Begin a polygon definition.</p>
<p>After all vectors and vertices have been defined, polygons are defined.
Each polygon requires a begin call followed by at least three index add
calls followed by an end call. Optionally, holes may be defined. At this
time, <i>type</i> must be either 0 (concave or unknown) or 1 (convex).
Specifying type 1 improves performance because the tessellator does not
need to test the convexity of the polygon. The first polygon in an object
group must always specify a material by either a name or a tag, therefore
the two begin functions are provided. For all following polygons, a null
pointer or a null tag may be passed to specify "same material as before in
the same <a href="node83.html#mi:group">object group</a>." This improves
API performance. In the case of <tt>tagged</tt> objects, the material
pointer or tag <i>must</i> be null; the label is passed as an extra index
(using <i><a href="node189.html#INDEX960">mi_api_poly_index_add</a></i>)
before the regular vertex indices.</p>

<a id="INDEX960"></a>
<h5 class="anchor" id="api:mi_api_poly_index_add">mi_api_poly_index_add</h5>
<pre>
    miBoolean mi_api_poly_index_add(
        int             idx)         /* new index to append */
</pre>
<p class="brief">Add a vertex reference to the current polygon.</p>
<p>After the polygon begin call, at least three vertices must be specified
by index. The first vertex in the current <a href="node83.html#mi:group">object
group</a> has index 0. The order is significant; polygon vertices must be
defined in counter-clockwise order. Polygons (and their holes) should be
planar. Small deviations are handled gracefully but very large deviations
may lead to unpredictable behavior. This function is also used to store
the polygon label directly after
<i><a href="node189.html#INDEX958">mi_api_poly_begin</a></i> if the object is
<tt>tagged</tt>.</p>

<a id="INDEX961"></a>
<h5 class="anchor" id="api:mi_api_poly_hole_add">mi_api_poly_hole_add</h5>
<pre>
    miBoolean mi_api_poly_hole_add(void)
</pre>
<p class="brief">Add a hole vertex reference to the current polygon.</p>
<p>After the boundary loop of the polygon has been specified using index
add calls, this call may be used to indicate the end of the current loop
and the beginning of a hole loop. Hole loops, like boundary loops, consist
of a sequence of at least three index add calls. No two loops may intersect,
and a hole loop must be fully contained in the boundary loop in the plane
of the polygon.</p>

<a id="INDEX962"></a>
<h5 class="anchor" id="api:mi_api_poly_end">mi_api_poly_end</h5>
<pre>
    miBoolean mi_api_poly_end(void)
</pre>
<p class="brief">End a polygon definition.</p>
<p>After all boundary and optional hole loops have been added, the
polygon must be completed with this call. After the end call, a new
polygon definition may be started.</p>

<a id="INDEX963"></a>
<h5 class="anchor" id="api:mi_api_poly_approx">mi_api_poly_approx</h5>
<pre>
    miBoolean mi_api_poly_approx(
        miApprox        *approx)      /* approx technique */
</pre>
<p class="brief">Attach a displacement approximation.</p>
<p>After the last polygon an approximation statement may be specified.
It is used by the tessellator for displacement-mapped polygons only.
Displacement mapping is a feature of the material assigned to polygons.</p>

<h4 id="api:surf">Free-Form Surface Geometry</h4>

<p>Object groups containing free-form surfaces also consist of three sections:
the vector list, the vertex list (more accurately called the control point
list), and the curve and surface lists. The vector list is defined using
one call to <i><a href="#api:mi_api_vector_xyz_add">mi_api_vector_xyz_add</a></i>
for every vector. All vectors have three components x, y, z; weights for
rational curves and surfaces are specified as part of the vertex references
later.</p>
<p>The vertex list is defined with calls to
<i><a href="#api:mi_api_vertex_add">mi_api_vertex_add</a></i>, exactly like
in the polygonal case, except that all normals, textures, and other optional
vertex information except motion vectors is ignored and should not be specified.
Surfaces always compute their own normals, and there are special constructs
for textures and bump maps.</p>
<p>The curve and surface list uses the vertices defined in the
first section as control points. Curves can be used as trimming
curves, hole curves, and special curves. Vertices can also be used
as special points on surfaces. Special points and special curves
are always included in the tessellated surface.</p>

<a id="INDEX964"></a>
<h5 class="anchor" id="api:mi_api_surface_begin">mi_api_surface_begin</h5>
<pre>
    miBoolean mi_api_surface_begin(
        char            *name,     /* surface name */
        char            *mtlname)  /* material name */
</pre>
<p class="brief">Begin the definition of a free-form surface.</p>
<p>The <var>name</var> is valid only inside the
<a href="node83.html#mi:group">object group</a> to be refernced in connections
and approximations. The given material is assigned to the surface. The
<var>name</var> may not be a null pointer.</p>

<a id="INDEX965"></a>
<h5 class="anchor" id="api:mi_api_surface_begin_tag">mi_api_surface_begin_tag</h5>
<pre>
    miBoolean mi_api_surface_begin_tag(
        char            *name,     /* surface name */
        miTag           mtltag)    /* material name */
</pre>
<p class="brief">Begin the definition of a free-form surface.</p>
<p>This function is similar to
<i><a href="#api:mi_api_surface_begin">mi_api_surface_begin</a></i> but the
material is given by a tag instead of by name. This tag may not be a null tag.</p>

<a id="INDEX966"></a>
<h5 class="anchor" id="api:mi_api_surface_params">mi_api_surface_params</h5>
<pre>
    miBoolean mi_api_surface_params(
        int             dimen,       /* miU or muV */
        char            *basis_name, /* basis for U or V */
        miGeoScalar     range_min,   /* minimum range */
        miGeoScalar     range_max,   /* maximum range */
        miDlist         *params,     /* params for U or V */
        miBoolean       rational)    /* rational flag */
</pre>
<p class="brief">Set free-form surface parameters.</p>
<p>A free-form surface has two parameter directions,
<span class="math">u</span> and <span class="math">v</span>. After the surface
begin call, both must be defined with this call, first time with <i>dimen</i>
<tt>= miU</tt> and second time with <i>dimen</i> <tt>= miV</tt>. Both times,
the basis name as defined at the beginning of the object definition must be
given, as well as the <a href="node85.html#INDEX309">parameter range</a>, the
surface parameter list, and the rational flag. The rational flag can either
be set here or in the basis; the latter is recommended. The rational flag
can be specified here for backwards compatibility.</p>
<p>The parameter list is a <var>dynamic list</var> (see <a href="">dlist</a>)
containing the parameter vector. The length of this vector depends on the
basis, see <a href="node85.html#mi:surface_parms">surface parameter list</a>
for the exact numbers. The type of the dlist is <tt>miDLIST_GEOSCALAR</tt>,
containing floating-point numbers of type <tt>miGeoScalar</tt>.</p>

<a id="INDEX967"></a>
<h5 class="anchor" id="api:mi_api_vertex_ref_add">mi_api_vertex_ref_add</h5>
<pre>
    miBoolean mi_api_vertex_ref_add(
        int             ref,         /* vertex reference */
        double          w)           /* homogeneous coordinate */
</pre>
<p class="brief">
Add a control point reference to the current free-form surface.</p>
<p>After both surface parameter vectors have been specified, the
control points must be listed. The number of control points depends
on both bases and the length of their parameter vectors; again
refer to the mental ray manual for details. For every control point
one call to <i>mi_api_vertex_ref_add</i> is required. If both bases
are non-rational, it is sufficient to specify a vertex index
<i>ref</i>. As with polygons, 0 selects the first vertex in the
current <a href="node83.html#mi:group">object group</a>. For
rational bases, a weight <i>w</i> must be given for every control
point reference.</p>

<a id="INDEX968"></a>
<h5 class="anchor" id="api:mi_api_surface_curveseg">mi_api_surface_curveseg</h5>
<pre>
    miBoolean mi_api_surface_curveseg(
        miBoolean         newloop,   /* new loop? */
        enum miCurve_type type,      /* type of curve */
        char              *name,     /* existing curve */
        miGeoRange        *range)    /* curve range */
</pre>
<p class="brief">Add a curve or curve segment to a freeform surface.</p>
<p>After the surface parameters have been defined, this call can be
used to attach curves to the surface. The curve must have been
defined in the same <a href="node83.html#mi:group">object group</a>
(see below) and is referenced by <i>name</i>. The <i>type</i> of
the curve is one of <tt>miCURVE_TRIM</tt>, <tt>miCURVE_HOLE</tt>,
and <tt>miCURVE_SPECIAL</tt>. The parameter <i>range</i> specifies
the piece of the curve to be used. Multiple curves or pieces of
curves can be concatenated to form the final loop; curves specified
by consecutive <i>mi_api_surface_curveseg</i> are concatenated to a
single loop by setting <i>newloop</i> to <tt>miTRUE</tt> for the
first call and to <tt>miFALSE</tt> for all following curves to be
appended.</p>

<a id="INDEX969"></a>
<h5 class="anchor" id="api:mi_api_surface_specpnt">mi_api_surface_specpnt</h5>
<pre>
    miBoolean mi_api_surface_specpnt(
        int             uv_index,    /* 2D point reference */
        int             v_index)     /* optional 3D point */
</pre>
<p class="brief">Attach a special point to a free-form surface.</p>
<p>A vertex index <i>uv_index</i> must be given that contains the coordinate
in the surface's UV space. The tessellated surface will contain a triangle
vertex at that UV coordinate. If <i>v_index</i> is not <i>-1</i>, the special
point is assigned the XYZ coordinate contained in the indexed vertex.</p>

<a id="INDEX970"></a>
<h5 class="anchor" id="api:mi_api_surface_texture_begin">mi_api_surface_texture_begin</h5>
<pre>
    miBoolean mi_api_surface_texture_begin(
        miBoolean       is_volume,
        miBoolean       is_bump,
        char            *ubasis_name,
        miDlist         *uparams,
        miBoolean       u_rational,
        char            *vbasis_name,
        miDlist         *vparams,
        miBoolean       v_rational)
</pre>
<p class="brief">Attach a texture surface to a free-form surface.</p>
<p>This call attaches a texture surface to the most recently defined surface.
A texture surface is a simplified type of surface that causes texture vectors
to appear in the vertices of the triangles that result from tessellation.
Whenever the tessellator creates a triangle vertex at a certain UV coordinate
of the main surface, it looks up this UV coordinate in the texture surface
and computes the location of the texture surface at that point, and stores
that as texture vector. If <i>is_volume</i> is <tt>miFALSE</tt>, wrap
compensation is applied before storing the texture vector; this ensures that
texture lookups near the surface seam do not "rewind." Generally it should
be <tt>miFALSE</tt> for 2D textures and <tt>miTRUE</tt> for 3D (volume)
textures. If <i>is_bump</i> is <tt>miTRUE</tt>, a pair of basis vectors is
created in the tessellated surface instead of a texture vector. The bases
and parameters in both the U and V directions are specified in the same call;
they must use the same <a href="node85.html#INDEX309">parameter range</a>s as
the base surface.</p>
<p>Note that whenever the texture on a surface looks strangely shifted, or if
<a href="node108.html#INDEX409">texture coordinate</a>s are too large by a
constant of <i>1</i>, the reason is usually that <i>is_volume</i> had not been
set to <tt>miTRUE</tt> on a 3D texture.</p>

<a id="INDEX971"></a>
<h5 class="anchor" id="api:mi_api_surface_derivative">mi_api_surface_derivative</h5>
<pre>
    miBoolean mi_api_surface_derivative(
        int             degree)     /* 1=1st, 2=2nd deriv */
</pre>
<p class="brief">Request computation of surface derivatives.</p>
<p>Specify that during tessellation, first or second order derivatives should
be computed and stored with the vertices of the tessellated surface that was
most recently started with <i>mi_api_surface_begin</i>. If both first and
second order derivatives should be stored, this function must be called twice.
</p>

<a id="INDEX972"></a>
<h5 class="anchor" id="api:mi_api_surface_end">mi_api_surface_end</h5>
<pre>
    miBoolean mi_api_surface_end(void)
</pre>
<p class="brief">End a free-form surface definition.</p>
<p>After the surface, both of its parameter directions, all its texture
surfaces and its derivatives have been specified, this call must be used
to complete the surface definition. After this call, the next surface may
be started by repeating the sequence beginning with
<i>mi_api_surface_begin</i>.</p>

<a id="INDEX973"></a>
<h5 class="anchor" id="api:mi_api_surface_approx">mi_api_surface_approx</h5>
<pre>
    miBoolean mi_api_surface_approx(
        char            *name,      /* name of surface */
        miApprox        *approx)    /* approx technique */
</pre>
<p class="brief">Attach a surface approximation to a free-form surface.</p>
<p>After the definition of a surface is complete, an approximation can be
attached to it. The default is parametric approximation. This call can be
used to change the default to regular parametric, curvature-dependent or
spatial approximations. This call must be used before the
<a href="node83.html#mi:group">object group</a> ends because at that point
the surface names go out of scope.</p>

<a id="INDEX974"></a>
<h5 class="anchor" id="api:mi_api_surface_approx_displace">mi_api_surface_approx_displace</h5>
<pre>
    miBoolean mi_api_surface_approx_displace(
        char            *name,     /* name of surface */
        miApprox        *approx)   /* approx technique */
</pre>
<p class="brief">Attach a displacement approximation to a free-form surface.</p>
<p>In addition to <i>mi_api_surface_approx</i>, which control the approximation
of the base surface, this function stores an approximation for the displaced
surface. The default is parametric. This is often useful to provide a
high-resolution parametric approximation for the base surface to catch small
displacement map features, and a curvature or view dependent tessellation
like <a href="node89.html#INDEX337">fine approximation</a> for the displaced
surface to properly approximate the details introduced by the displacement.
</p>

<a id="INDEX975"></a>
<h5 class="anchor" id="api:mi_api_surface_approx_trim">mi_api_surface_approx_trim</h5>
<pre>
    miBoolean mi_api_surface_approx_trim(
        char            *name,     /* name of surface */
        miApprox        *approx)   /* approx technique */
</pre>
<p class="brief">Attach a curve approximation to a surface.</p>
<p>This function assigns an approximation to the trimming, hole,
and special curves attached to the named surface, just like the
previous function assigns an approximation to the surface
itself.</p>

<h4 id="api:curve">Curves</h4>

<p>Curves can be used as trimming curves, hole curves, and special curves for
free-form surfaces as described in the previous section. In addition, space
curves can be used to desribe 3D curve objects. A special variant of curves
is used to represent <a href="#api:hair">hair</a>.</p>

<p>This section lists the API functions to create curves. This can
be done inside any <a href="node83.html#mi:group">object group</a>,
after the vectors and vertices are defined, in any place where a
surface definition would be legal. Like surface names, curve names
are in <a href="node83.html#mi:group">object group</a> scope and
can only be referenced in the <a href="node83.html#mi:group">object
group</a> they are defined in.</p>
<a id="INDEX976"></a>
<h5 class="anchor" id="api:mi_api_curve_begin">mi_api_curve_begin</h5>
<pre>
    miBoolean mi_api_curve_begin(
        char            *name,       /* name of the curve */
        char            *basis,      /* name of the basis */
        miBoolean       rational)
</pre>
<p>Create a new curve with the given <i>name</i>, using the
specified basis. Like surfaces, a <i>rational</i> flag can be set
for backwards compatibility reasons. The recommended method is
setting the rational flag in the basis. Curves and surfaces can
share the same bases.</p>
<a id="INDEX977"></a>
<h5 class="anchor" id="api:mi_api_curve_specpnt">mi_api_curve_specpnt</h5>
<pre>
    miBoolean mi_api_curve_specpnt(
        int             t_index,     /* 1D point reference */
        int             v_index)
</pre>
<p>Attach a special point to a curve at the parameter point
<i>v_index</i> of the curve. <i>v_index</i> references the vertex
to use; only the X value is used.</p>

<a id="INDEX978"></a>
<h5 class="anchor" id="api:mi_api_curve_end">mi_api_curve_end</h5>
<pre>
    miBoolean mi_api_curve_end(
        miDlist         *dlp)        /* parameter list */
</pre>
<p>Complete the definition of the curve, and pass the parameter
vector. The type of the dlist is either <tt>miScalar</tt> for the
non-rational case or <tt>miVref</tt> for the rational case.</p>

<a id="INDEX979"></a>
<h5 class="anchor" id="api:mi_api_curve_approx">mi_api_curve_approx</h5>
<pre>
    miBoolean mi_api_curve_approx(
        char            *name,       /* name of curve */
        miApprox        *approx)     /* approx technique */
</pre>
<p>This function assigns an approximation to the curve.
Alternatively, an approximation can be assigned to all curves used
in a surface at once using <i>mi_api_surface_approx_trim</i>, which
overrides the approximation set with
<i>mi_api_curve_approx</i>.</p>

<h4 id="api:spacecurve">Space Curves</h4>

<p>This section lists the API functions to create space curves.
Space curve objects are primarily useful in geometry shaders, they
are not used for rendering. Geometry shaders can build renderable
surfaces with space curve objects or use them for dynamic trimming
operations on surfaces. The definition can be done inside any
<a href="node83.html#mi:group">object group</a>, after the vectors
and vertices are specified. Like curve or surface names, space
curve names are in <a href="node83.html#mi:group">object group</a>
scope and can only be referenced in the
<a href="node83.html#mi:group">object group</a> they are defined in.</p>

<a id="INDEX980"></a>
<h5 class="anchor" id="api:mi_api_spacecurve_begin">mi_api_spacecurve_begin</h5>
<pre>
    miBoolean mi_api_spacecurve_begin(
        char            *name)     /* space curve */
</pre>
<p>Create a new space curve with the given <i>name</i>.</p>

<a id="INDEX981"></a>
<h5 class="anchor" id="api:mi_api_spacecurve_curveseg">mi_api_spacecurve_curveseg</h5>
<pre>
    miBoolean mi_api_spacecurve_curveseg(
        miBoolean       newloop,   /* is this a new loop */
        char            *name,     /* curve name */
        miGeoRange      *range)    /* range of the curve */
</pre>
<p>This call can be used to attach curve segments to the space
curve. The curve must have been defined in the same
<a href="node83.html#mi:group">object group</a> (see below) and is
referenced by <i>name</i>. The parameter <i>range</i> specifies the
piece of the curve to be used. Multiple curves or pieces of curves
can be concatenated to form the final space curve; curves specified
by consecutive <i>mi_api_spacecurve_curveseg</i> are concatenated
to a single curve by setting <i>newloop</i> to <tt>miTRUE</tt> for
the first call and to <tt>miFALSE</tt> for all following curves to
be appended.</p>

<a id="INDEX982"></a>
<h5 class="anchor" id="api:mi_api_spacecurve_approx">mi_api_spacecurve_approx</h5>
<pre>
    miBoolean mi_api_spacecurve_approx(
        char            *name,     /* name of surface */
        miApprox        *approx)   /* approx technique */
</pre>
<p>After the definition of a space curve is complete, an
approximation can be attached to it. The default is parametric
approximation. This call can be used to change the default to
regular parametric, curvature-dependent or spatial approximations.
This call must be used before the
<a href="node83.html#mi:group">object group</a> ends because at that point
the space curve names go out of scope.</p>
<a id="INDEX983"></a>
<h5 class="anchor" id="api:mi_api_spacecurve_end">mi_api_spacecurve_end</h5>
<pre>
    miBoolean mi_api_spacecurve_end(void)
</pre>
<p>This function must be called to finalize the definition of a
space curve. After this call, the next space curve can be started
by repeating the sequence beginning with
<i>mi_api_spacecurve_begin</i>.</p>

<h4 id="api:hair">Hair</h4>

<p>Hair<a id="INDEX984"></a> geometry shares the same object begin and end
calls with all other geometry types, but the actual geometry uses special
<i>mi_api_hair_*</i> calls instead of
<i><a href="node189.html#INDEX944">mi_api_object_group_begin</a></i> and
<i><a href="node189.html#INDEX946">mi_api_object_group_end</a></i>.
A typical sequence is:</p>
<pre>
    mi_api_hair_begin
        mi_api_hair_info                    (zero or more calls)
        mi_api_hair_scalars_begin
        mi_api_hair_scalars_end             (followed by array write)
        mi_api_hair_hairs_begin
            mi_api_hair_hairs_add           (once per hair plus 1)
        mi_api_hair_hairs_end
    mi_api_hair_end
</pre>
<p>The <i><a href="node189.html#INDEX986">mi_api_hair_info</a></i> calls are
optional; they describe the information attached to hairs and vertices (see
<a href="node87.html#mi:hair">hair geometry</a> for details).
</p>

<a id="INDEX985"></a>
<h5 class="anchor" id="api:mi_api_hair_begin">mi_api_hair_begin</h5>
<pre>
    miHair_list *mi_api_hair_begin(void)
</pre>
<p>Begin a hair block in an object. The returned hair list may be
used to specify the global fields <i>material</i>, <i>radius</i>,
<i>degree</i>, <i>approx</i>, <i>space_max_size</i>, and
<i>space_max_depth</i>.</p>

<a id="INDEX986"></a>
<h5 class="anchor" id="api:mi_api_hair_info">mi_api_hair_info</h5>
<pre>
    miBoolean mi_api_hair_info(
        int             where,     /* 0=per hair, 1=per vertex */
        char            what,      /* n=norm,m=mot,t=tex,u=user,r=radius*/
        int             num)       /* how many? */
</pre>
<p>Specify that each hair (if <i>where</i> == 0) or each vertex (if
<i>where</i> == 1) has the specified number of normal scalars
(<i>what</i> == 'n', <i>num</i> must be 0 or 3), number of motion
scalars (<i>what</i> == 'm', <i>num</i> must be 0 or a multiple of
3), number of texture scalars ( <i>what</i> == 't'), number of user
scalars (<i>what</i> == 'u'), or whether it has a radius (
<i>what</i> == 'r', either 0 or 1). If there are vertex normals,
vertex motion vectors, or a vertex radius, the hair normals, hair
motion vectors, or hair radius, respectively, are ignored.</p>

<a id="INDEX987"></a>
<h5 class="anchor" id="api:mi_api_hair_scalars_begin">mi_api_hair_scalars_begin</h5>
<pre>
    miScalar *mi_api_hair_scalars_begin(
        int             num)       /* expected number of scalars */
</pre>
<p>After the hair info, the scalar list follows in the hair object
definition. The <i>num</i> argument specifies the number of scalars
in the hair object. This function returns a scalar array with room
for <i>num</i> scalars, which the caller must fill. See page
<a href="node205.html#hairlayout">hairlayout</a> for the scalar
layout. There is no add-scalar function for performance
reasons.</p>

<a id="INDEX988"></a>
<h5 class="anchor" id="api:mi_api_hair_scalars_end">mi_api_hair_scalars_end</h5>
<pre>
    miBoolean mi_api_hair_scalars_end(
        int             num)       /* received number of scalars */
</pre>
<p>After all scalars have been defined, this function must be
called. It performs some consistency checks.</p>

<a id="INDEX989"></a>
<h5 class="anchor" id="api:mi_api_hair_hairs_begin">mi_api_hair_hairs_begin</h5>
<pre>
    miGeoIndex *mi_api_hair_hairs_begin(
        int             num)       /* expected number of hairs + 1 */
</pre>
<p>After the scalar definition, the hair indices must be defined
with this function. The number <i>num</i> is the number of indices
that follow, which is the number of hairs plus 1. Again, see page
<a href="node205.html#hairlayout">hairlayout</a>. A pointer to an
index array with <i>num</i> indices is returned, which the caller
must fill by calling <i><a href="node189.html#INDEX990">mi_api_hair_hairs_add</a></i>
repeatedly, or manually.</p>

<a id="INDEX990"></a>
<h5 class="anchor" id="api:mi_api_hair_hairs_add">mi_api_hair_hairs_add</h5>
<pre>
    miBoolean mi_api_hair_hairs_add(
        int             si)        /* index into scalar list */
</pre>
<p>Add a hair index <i>si</i>. This ends the definition of the
previous hair, if any, and begins a new hair (unless this is the
last index). Each hair needs a fixed number of scalars: the number
required by the hair info (data shared by all vertices of the
hair), followed by one or more vertex info blocks (data separate
for each hair), as defined with
<i><a href="node189.html#INDEX986">mi_api_hair_info</a></i>. Note that there
need to be as many calls to this function as have been specified by
the <i>num</i> argument of the
<i><a href="node189.html#INDEX990">mi_api_hair_hairs_add</a></i> call, which
is one more than the number of hairs (to terminate the last hair).
The first hair index is normally 0, and the last hair index
normally equals the number of scalars <i>num</i> passed to
<i><a href="node189.html#INDEX987">mi_api_hair_scalars_begin</a></i>.</p>

<a id="INDEX991"></a>
<h5 class="anchor" id="api:mi_api_hair_hairs_end">mi_api_hair_hairs_end</h5>
<pre>
    miBoolean mi_api_hair_hairs_end(void)
</pre>
<p>This function concludes the definition of indices. The next call
is probably <i><a href="node189.html#INDEX992">mi_api_hair_end</a></i>.</p>

<a id="INDEX992"></a>
<h5 class="anchor" id="api:mi_api_hair_end">mi_api_hair_end</h5>
<pre>
    void mi_api_hair_end(void)
</pre>
<p>Finish the definition of the hair geometry. The next call is
probably <i><a href="node189.html#INDEX949">mi_api_object_end</a></i>.</p>

<h4 id="api:sds">Subdivision Surfaces</h4>

<p id="INDEX993"><a id="INDEX994"></a>
Object groups containing subdivision surfaces consist of three sections:
the vector list, the vertex list, and the subdivision surface list. As common,
the vector list is defined using one call to
<i><a href="node189.html#INDEX953">mi_api_vector_xyz_add</a></i> for every
vector, and the vertex list is defined with calls to
<i><a href="node189.html#INDEX956">mi_api_vertex_add</a></i> like in the
polygon case. The subdivision surface list uses the vertices for both position
and detail vertices. Subdivision surface vertices can have flags attached,
they can be added by calling:</p>

<a id="INDEX995"></a>
<h5 class="anchor" id="api:mi_api_vertex_flags_add">mi_api_vertex_flags_add</h5>
<pre>
    typedef enum {
        miAPI_V_SMOOTH=0,
        miAPI_V_CORNER,
        miAPI_V_CONIC,
        miAPI_V_CUSP,
        miAPI_V_DART
    } miApi_vertexflags;

    miBoolean mi_api_vertex_flags_add(
        miApi_vertexflags flags,
        miScalar          value)
</pre>
<p>This function adds a sharpness feature to the current vertex
beginning with a specified level. It should be called only once for
each vertex, and may be called for individual vertices. If not
called for a vertex, default flags are used (miAPI_V_SMOOTH), which
will lead to smooth vertex processing. <i>value</i> specifies the
sharpness for conic and cusp vertices. For corner vertices zero
sharpness should be passed. It is redundant to mark a vertex smooth
with this call.</p>
<p>A typical call order for subdivision surface construction is:</p>
<pre>
     mi_api_subdivsurf_begin
        mi_api_subdivsurf_index                 (n times)
        mi_api_subdivsurf_baseface
        [mi_api_subdivsurf_crease_edge          (optional)
         mi_api_subdivsurf_crease]              (optional)
        mi_api_subdivsurf_trim                  (optional)
        mi_api_subdivsurf_mtl                   (optional)
           [mi_api_subdivsurf_push              (block optional)
              mi_api_subdivsurf_subdivide
                 mi_api_subdivsurf_mtl          (optional)
                 [mi_api_subdivsurf_index       (up to 6/9 times)
                  mi_api_subdivsurf_detail]     (optional)
                 [mi_api_subdivsurf_crease_edge (optional)
                  mi_api_subdivsurf_crease]     (optional)
                 mi_api_subdivsurf_trim         (optional)
                 [mi_api_subdivsurf_push        (optional)
                    mi_api_subdivsurf_subdivide
                    ...
                  mi_api_subdivsurf_pop]
            mi_api_subdivsurf_pop]
     mi_api_subdivsurf_end
</pre>
<p><tt>n</tt> is 3 or 4 for triangles or quads, respectively, plus
either 1 (base polygon) or 4 (polygon kit) if the object is tagged,
in which case the triangle/quad labels must be passed first. A
"kit" consists of 3 or 4 indices that subdivide the edge of the
parent polygon into four sub-polygons, each of which may have its
own material (part of the kit) and each may in turn be subdivided
(using up to four separate push/pop blocks).</p>

<a id="INDEX996"></a>
<h5 class="anchor" id="api:mi_api_subdivsurf_begin">mi_api_subdivsurf_begin</h5>
<pre>
    miBoolean mi_api_subdivsurf_begin(
        char            *name)          /* name of the surface */
</pre>
<p>Begin the definition of a subdivision surface with the given
<i>name</i>. The name is valid only inside the
<a href="node83.html#mi:group">object group</a>.</p>

<a id="INDEX997"></a>
<h5 class="anchor" id="api:mi_api_subdivsurf_baseface">mi_api_subdivsurf_baseface</h5>
<pre>
    miBoolean mi_api_subdivsurf_baseface(void)
</pre>
<p>Define a base triangle or quad. Before calling this function
there must be either 3 or 4 vertices specified with
<i><a href="node189.html#INDEX1000">mi_api_subdivsurf_index</a></i>. If the
object is tagged, one additional index must be specified, for a
total of either 4 or 5.</p>

<a id="INDEX998"></a>
<h5 class="anchor" id="api:mi_api_subdivsurf_mtl">mi_api_subdivsurf_mtl</h5>
<pre>
    miBoolean mi_api_subdivsurf_mtl(
        int             child,          /* 0-3 */
        char            *mtlname)       /* material name or 0 */
</pre>
<p>Add a material to the current face. A face may have only one
material. <i>child</i> specifies to which child of the current kit
the material is assigned. If the current face is a base polygon, -1
must be passed for <i>child</i>.</p>

<a id="INDEX999"></a>
<h5 class="anchor" id="api:mi_api_subdivsurf_mtl_tag">mi_api_subdivsurf_mtl_tag</h5>
<pre>
    miBoolean mi_api_subdivsurf_mtl_tag(
        int             child,
        miTag           mtltag)         /* material tag or 0 */
</pre>
<p>This function is equivalent to the previous but specifies the
material as a tag.</p>

<a id="INDEX1000"></a>
<h5 class="anchor" id="api:mi_api_subdivsurf_index">mi_api_subdivsurf_index</h5>
<pre>
    miBoolean mi_api_subdivsurf_index(
        int             idx)            /* another base face vertex index */
</pre>
<p>If the object is tagged, the first index specified by this
function is interpreted as a face material, subsequent indices
specify base face vertices. If the object is not tagged, only the
three or four vertex indices may be specified. When using this
function for detail vector specification, object tagging is not
admissible since materials are specified in other ways for kits.
The first index specified will directly correspond to the first
detail vector, even if tagging is enabled.</p>

<a id="INDEX1001"></a>
<h5 class="anchor" id="api:mi_api_subdivsurf_push">mi_api_subdivsurf_push</h5>
<pre>
    miBoolean mi_api_subdivsurf_push(void)
</pre>
<p>This function prepares a face subdivision. It must be called immediately before
<i><a href="node189.html#INDEX1003">mi_api_subdivsurf_subdivide</a></i>. The
purpose of this function is to save the current face context, i.e.
current face and level.</p>

<a id="INDEX1002"></a>
<h5 class="anchor" id="api:mi_api_subdivsurf_pop">mi_api_subdivsurf_pop</h5>
<pre>
    miBoolean mi_api_subdivsurf_pop(void)
</pre>
<p>When a face subdivision is completed, this function must be
called to restore the state as it was before face subdivision.</p>

<a id="INDEX1003"></a>
<h5 class="anchor" id="api:mi_api_subdivsurf_subdivide">mi_api_subdivsurf_subdivide</h5>
<pre>
    miBoolean mi_api_subdivsurf_subdivide(
        int             child)
</pre>
<p>This function subdivides the specified child of the current kit.
It must be called after
<i><a href="node189.html#INDEX1001">mi_api_subdivsurf_push</a></i>. Initially
no detail vectors are assigned to the vertices. If the current face
is a base polygon, -1 must be passed for <i>child</i>.</p>

<a id="INDEX1004"></a>
<h5 class="anchor" id="api:mi_api_subdivsurf_detail">mi_api_subdivsurf_detail</h5>
<pre>
    miBoolean mi_api_subdivsurf_detail(
        int             mask)
</pre>
<p>This function sets <a href="node88.html#INDEX331">detail
vector</a>s for the current face and for the current level. A
vertex may have details beginning with the vertex definition level,
and also on higher levels. <i>mask</i> specifies which vertices of
the current kit will have details. This parameter is a bitmap. Bit
0-2 for triangles and 0-3 for quads specify whether the even
vertices of the kit have details, bits 3-5 for triangles and 4-6
for quads specify whether the odd vertices of the kit have details.
Detail vectors must be specified before calling this function with
enough calls to <i><a href="node189.html#INDEX1000">mi_api_subdivsurf_index</a></i>.
These detail vectors are associated to the kit vertices using the
<i>mask</i> bitmap. The current face must be a kit.</p>

<a id="INDEX1005"></a>
<h5 class="anchor" id="api:mi_api_subdivsurf_crease_edge">mi_api_subdivsurf_crease_edge</h5>
<pre>
    miBoolean mi_api_subdivsurf_crease_edge(
        miScalar        value)
</pre>
<p>Specifies the sharpness for a crease edge, in the range <var>0...1</var>.</p>

<a id="INDEX1006"></a>
<h5 class="anchor" id="api:mi_api_subdivsurf_crease">mi_api_subdivsurf_crease</h5>
<pre>
    miBoolean mi_api_subdivsurf_crease(
        int             child,
        int             mask)
</pre>
<p>This function defines a crease edge for the current face. The
face is specified with <i>child</i>, for base polygons -1 must be
given for <i>child</i>. The crease edges are specified with the
bitmap <i>mask</i>. Bits 0..2 for triangles and 0..3 for quads
specify the edges to be used for the crease. It is sufficient to
mark a crease edge only in one direction, the other direction is
marked automatically. Before calling this function enough crease
sharpness values must be specified with calls to
<i><a href="node189.html#INDEX1005">mi_api_subdivsurf_crease_edge</a></i>. The
bitmap <i>mask</i> is used to associate the sharpness values to the
selected crease edges.</p>

<a id="INDEX1007"></a>
<h5 class="anchor" id="api:mi_api_subdivsurf_trim">mi_api_subdivsurf_trim</h5>
<pre>
    miBoolean mi_api_subdivsurf_trim(
        int             child,
        int             mask)
</pre>
<p>This function defines a trim edge for the current face. The face
is specified with <i>child</i>, for base polygons -1 must be given
for <i>child</i>. The trim edges are specified with the bitmap
<i>mask</i>. Bits 0-2 for triangles and 0-3 for quads specify the
edges to be used for the trim edge. The current face will be
located inside the trimmed region, i.e. it is cut out of the
surface.</p>
<p>Trim edges must form a connected loop on the same level.
Connected trim edges <b>must</b> be defined on the same level in
the hierarchy. A trim edge may not be defined on the outer boundary
loop of the subdivision surface. Nested trimming regions are not
supported, i.e. it is only possible to define a single level of
trim regions, not trim regions within trim regions. Edges of two
different trim regions may not share the same edge or vertex. Trim
regions may not overlap, intersect or touch.</p>

<a id="INDEX1008"></a>
<h5 class="anchor" id="api:mi_api_subdivsurf_end">mi_api_subdivsurf_end</h5>
<pre>
    miBoolean mi_api_subdivsurf_end(void)
</pre>
<p>Complete the definition of the subdivision surface started with
<i>mi_api_subdiv_begin</i>.</p>

<a id="INDEX1009"></a>
<h5 class="anchor" id="api:mi_api_subdivsurf_approx">mi_api_subdivsurf_approx</h5>
<pre>
    miBoolean mi_api_subdivsurf_approx(
        char            *name,
        miApprox        *approx)
</pre>
<p>Change the default approximation of a subdivision surface with
name <i>name</i> to <i>approx</i>.</p>

<a id="INDEX1010"></a>
<h5 class="anchor" id="api:mi_api_subdivsurf_approx_displace">mi_api_subdivsurf_approx_displace</h5>
<pre>
    miBoolean mi_api_subdivsurf_approx_displace(
        char            *name,
        miApprox        *approx)
</pre>
<p>Change the default displacement approximation of a subdivision
surface with name <i>name</i> to <i>approx</i>.</p>

<a id="INDEX1011"></a>
<h5 class="anchor" id="api:mi_api_subdivsurf_derivative">mi_api_subdivsurf_derivative</h5>
<pre>
    miBoolean mi_api_subdivsurf_derivative(
        int             degree,
        int             space)
</pre>
<p>Enable computation of derivatives for the current subdivision
surface. <i>degree</i> must be 1. <i>space</i> selects which
texture space should be used for the parameterization of the
<a href="node189.html#INDEX993">subdivision surface</a>.</p>

<a id="INDEX1012"></a>
<h5 class="anchor" id="api:mi_api_subdivsurf_texspace">mi_api_subdivsurf_texspace</h5>
<pre>
    typedef struct miApi_texspace_options {
        miBoolean              face;
    } miApi_texspace_options;

    miBoolean mi_api_subdivsurf_texspace(
        miApi_texspace_options *opt,
        miUint                 no_opt)
</pre>
<p>This function sets the interpolation methods used for the
defined texture spaces: if <tt>face</tt> is <tt>miTRUE</tt>,
textures are evaluated per face (faceted) instead of being
interpolated between vertices, which is the default. The method
must be selected in the options array passed to this function. The
array has one member for each texture space; <i>no_opt</i> is the
number of array members.</p>

<h4 id="api:ccmesh">Catmull-Clark Meshes</h4>

<p id="INDEX1019">Catmull-Clark meshes are defined in a similar way
as polygonal objects, however the mesh is subdivided using certain
rules to get a smoother surface. The individual polygons in the
input mesh can have an arbitrary number of edges. A fractional
sharpness value can be assigned to the polygon edges, resulting in
a local crease on the surface. Each polygon vertex may be tagged
with a corner feature (see the Subdivision Surface section above
for more details on vertex features).</p>

<a id="INDEX1020"></a>
<h5 class="anchor" id="api:mi_api_ccmesh_begin">mi_api_ccmesh_begin</h5>
<pre>
    struct miApi_ccmesh_options {
        miUint                 no_polygons;
        miUint                 no_vertices;
    }
    miBoolean mi_api_ccmesh_begin(
        char                   *name,
        miApi_ccmesh_options   *opt)
</pre>
<p>Begin a Catmull-Clark mesh object with the given name and
options. <i>no_polygons</i> specifies the total number of polygons
which will be defined, <i>no_vertices</i> the total number of
polygon vertices.</p>

<a id="INDEX1022"></a>
<h5 class="anchor" id="api:mi_api_ccmesh_polygon">mi_api_ccmesh_polygon</h5>
<pre>
    miBoolean mi_api_ccmesh_polygon(
        miUint                 no_vertices,
        miUint                 *vertices,
        miUint                 mtl_tag)
</pre>
<p>Adds a single polygon to the current Catmull-Clark mesh object.
The polygon has <i>no_vertices</i> vertices, the vertex indices are
given in <i>vertices</i>. An optional material can be given in
<i>mtl_tag</i>. If the object is created in <tt>tagged</tt>
material mode, <i>mtl_tag</i> is the material label, otherwise it
is either a material tag or null.</p>

<a id="INDEX1023"></a>
<h5 class="anchor" id="api:mi_api_ccmesh_crease">mi_api_ccmesh_crease</h5>
<pre>
    miBoolean mi_api_ccmesh_crease(
        miScalar               *sharpness)
</pre>
<p>Assigns crease values to the current polygon, so this function
must be called after <i><a href="node189.html#INDEX1022">mi_api_ccmesh_polygon</a></i>.
For each polygon edge a sharpness value must be given in the
<i>sharpness</i> array. A smooth edge has a value 0, an infinitely
sharp edge a value 1. If some edges do not have creases, 0 must be
given in the corresponding array entries.</p>

<a id="INDEX1024"></a>
<h5 class="anchor" id="api:mi_api_ccmesh_approx">mi_api_ccmesh_approx</h5>
<pre>
    miBoolean mi_api_ccmesh_approx(
        char                   *name,
        miApprox               *approx)
</pre>
<p>Assign an approximation to the current Catmull-Clark mesh
object. In the current implementation, a single subdivision step is
always done. Any further subdivision is applied to this resulting
quad mesh using the given approximation.</p>

<a id="INDEX1025"></a>
<h5 class="anchor" id="api:mi_api_ccmesh_derivative">mi_api_ccmesh_derivative</h5>
<pre>
    miBoolean mi_api_ccmesh_derivative(
        miUint                 degree,
        miUint                 space)
</pre>
<p>Request generation of first or second derivatives for the
current Catmull-Clark mesh object. For the first derivatives, a
corresponding texture space index must be given, used for alignment
of the tangent vectors.</p>

<h5 class="anchor" id="api:mi_api_ccmesh_end">mi_api_ccmesh_end</h5>
<pre>
    miBoolean mi_api_ccmesh_end()
</pre>
<p>Complete definition of the current Catmull-Clark mesh object.</p>

<h4 id="api:primlist">Primitive List Objects</h4>

<p>
Primitive list objects provide a way to directly specify the renderable
representation of geometry in mental ray, as boxes of final triangles.
Displacement mapping is fully supported. Primitive list objects are way more
efficient in terms of storage and runtime compared to polygon objects because
no further face tessellation needs to be performed, and no copies of mostly
big data blocks need to be made. However, primitive lists expose internal
data structures used for rendering <em>which may change with any major update
of mental ray</em>. That may require to re-compile and potentially adjust the
code which utilize them. Primitive list objects replace
<var><a href="#api:trilist">triangle lists</a></var>.</p>

<h5 class="anchor" id="api:mi_api_primlist_begin">mi_api_primlist_begin</h5>
<pre>
    miBox *mi_api_primlist_begin(
        miVertex_info   *info,
        miUint          no_lines,
        miUint          no_prim_lists,
        miUint          no_indices,
        miUint          no_materials,
        miUint          pd_size,
        miUint          no_prims)
</pre>
<p>The current object being created is set to type <tt>miOBJECT_BOXES</tt>
and a scene element of type <tt>miSCENE_NBOX</tt> is created.
<i>no_lines</i> specifies the number of vertex lines containing floating point
vertex data, <i>no_prim_lists</i> is the number of primitive lists requested.
Each primitive list contains multiple primitives of the same type. In current
mental ray, <i>no_prim_lists</i> must be 1 and only primitives of type
<tt>miSCENE_PRIM_TRI</tt> are supported. The number of primitive indices (
references to the vertex lines) is given with <i>no_indices</i>, the number of
materials with <i>no_materials</i>. There must be a corresponding material
entry defined for each primitive (triangle). The total number of primitives
in all primitive lists is given with <i>no_prims</i>. Each primitive may have
user data attached to it, <i>pd_size</i> specifies the total size reserved in
the <tt>miBox</tt> in multiples of 32 bit units.</p>

<h5 class="anchor" id="api:mi_api_primlist_begin_2">mi_api_primlist_begin_2</h5>
<pre>
      miBox *mi_api_primlist_begin_2(
          miVertex_info   *info,
          miUint          no_lines,
          miUint          no_prim_lists,
          miUint          no_indices,
          miUint          no_materials,
          miUint          primdata_size,
          miUint          pd_info_size,
          miUint          no_prims)
  
</pre>
<p>The second primlist object constructor has one additional argument
<em>pd_info_size</em>. It allows attaching an information block to the box,
describing the per face user data layout. If set to zero, no such block is
allocated in the box, but per face user data can still be defined. The
<em>primdata_size</em> is the size of user data per primitive in multiples
of 32 bit units.</p>

<h5 class="anchor" id="api:mi_api_primlist_dimensions">mi_api_primlist_dimensions</h5>
<pre>
    miBoolean mi_api_primlist_dimensions(
        miUint          *tex_dims,
        miUint          *user_dims)
</pre>
<p>This function helps initializing the texture and user offset section in a
<tt>miBox</tt>. Both <i>tex_dims</i> and <i>user_dims</i> specify the dimension
for each texture/user space defined in the box. Memory for both arrays is not
released by this function.</p>

<h5 class="anchor" id="api:mi_api_primlist_approx">mi_api_primlist_approx</h5>
<pre>
    miBoolean mi_api_primlist_approx(
        miApprox        *approx)
</pre>
<p>Attaches a displacement approximation to the current primlist object.</p>

<h5 class="anchor" id="api:mi_api_primlist_end">mi_api_primlist_end</h5>
<pre>
    miBoolean mi_api_primlist_end(void)
</pre>
<p>Completes the definition of a primlist object.</p>

<h4 id="api:trilist">Triangle List Objects</h4>

<p><a id="INDEX1013"></a><a id="INDEX1014"></a>
<span class="depr">Deprecated</span>
Triangle list objects provide a way to directly specify the renderable
representation of geometry in mental ray, as boxes of final triangles.
Displacement mapping may still be applied. Triangle list objects are more
efficient in terms of storage and runtime than polygon objects because no
tessellation or other operation are performed that copy data. However, since
triangle lists expose data structures used for rendering <em>which may change
at any major update of mental ray</em> may require to change the code that
uses them. mental ray now supports a different data structure called
<var><a href="api:primlist">primitive lists</a></var> which replace trilists.
The <tt>miGeoBox</tt> data structure has been replaced by the new type
<tt>miBox</tt>. The <var>trilist</var> family of API functions can still be
used for defining triangle objects, however maximum performance is achieved
by using the <var><a href="api:primlist">primlist</a></var>functions.</p>

<a id="INDEX1015"></a>
<h5 class="anchor" id="api:mi_api_trilist_begin">mi_api_trilist_begin</h5>
<pre>
    miGeoBox * mi_api_trilist_begin(
        miVertex_content       *vc,
        miUint                 no_vectors,
        miUint                 no_vertices,
        miUint                 no_triangles)
</pre>
<p><span class="depr">Deprecated</span>
Begin definition of a triangle list object. The vertex layout is
specified in <i>vc</i>, the other parameters specify the number of
vectors, vertices and triangles for the object.</p>
<p>Returns a pointer to the low level result structure of a
triangle list object, which is a <i>miGeoBox</i>. Instead of using
<i>mi_api_trilist_vectors</i>, <i>mi_api_trilist_vertices</i>,
<i>mi_api_trilist_triangle</i> or <i>mi_api_trilist_triangles</i>
for geometry specification, the returned box may be initialized
directly with help of the <tt>miBOX_GET_VERTICES</tt> and
<tt>miBOX_GET_PRIMITIVES</tt> macros.</p>

<a id="INDEX1016"></a>
<h5 class="anchor" id="api:mi_api_trilist_approx">mi_api_trilist_approx</h5>
<pre>
    miBoolean mi_api_trilist_approx(
        miApprox               *approx)
</pre>
<p><span class="depr">Deprecated</span>
Attaches a displacement approximation to the current triangle list object.</p>

<a id="INDEX1017"></a>
<h5 class="anchor" id="api:mi_api_trilist_vectors">mi_api_trilist_vectors</h5>
<pre>
    miBoolean mi_api_trilist_vectors(
        miVector               *vectors,
        miUint                 no_vectors)
</pre>
<p><span class="depr">Deprecated</span>
Appends <i>no_vectors</i> vectors to the triangle list. The <i>vectors</i> array
is not released by this function.</p>

<a id="INDEX1018"></a>
<h5 class="anchor" id="api:mi_api_trilist_vertices">mi_api_trilist_vertices</h5>
<pre>
    miBoolean mi_api_trilist_vertices(
        miGeoIndex             *vertices,
        miUint                 no_vertices)
</pre>
<p><span class="depr">Deprecated</span>
Appends <i>no_vertices</i> vertices to the triangle list. Each
vertex requires corresponding <code>vc&rarr;sizeof_vertex</code>
integers in the <i>vertices</i> array. The <i>vertices</i> array is
not released by this function.</p>

<a id="INDEX1019"></a>
<h5 class="anchor" id="api:mi_api_trilist_triangle">mi_api_trilist_triangle</h5>
<pre>
    miBoolean mi_api_trilist_triangle(
        char                   *material,
        miGeoIndex             *indices)
</pre>
<p><span class="depr">Deprecated</span>
Defines a single triangle with a named material. The
<i>indices</i> array contains exactly three triangle indices
referencing the vertex section of the box. The material string must
be allocated and is released by this function, but the
<i>indices</i> array is not released.</p>

<a id="INDEX1020"></a>
<h5 class="anchor" id="api:mi_api_trilist_triangles">mi_api_trilist_triangles</h5>
<pre>
    miBoolean mi_api_trilist_triangles(
        miGeoIndex             *indices,
        miUint                 no_triangles)
</pre>
<p>Defines multiple triangles. The number of trinagles is specified
in <i>no_triangles</i>. The triangle vertices are specified in the
<i>indices</i> array. If the triangle list object has been created
with the <a href="node83.html#INDEX280">tagged flag</a>, the
material index must be given first in the index array, followed by
the three triangle vertices. These three or four index groups must
be repeated <i>no_triangles</i> times. The <i>indices</i> array is
not released by this function.</p>

<a id="INDEX1021"></a>
<h5 class="anchor" id="api:mi_api_trilist_end">mi_api_trilist_end</h5>
<pre>
    miBoolean mi_api_trilist_end(void)
</pre>
<p><span class="depr">Deprecated</span>
Completes the definition of a triangle list object.</p>

<ul class="nav">
<li><a href="index.html">home</a></li>
<li><a href="node188.html">&laquo;&nbsp;prev</a></li>
<li><a href="assembly_api.html">next&nbsp;&raquo;</a></li>
<li><a href="globalindex.html">index</a></li>
</ul>
<p><br />
<a href="copyright.html">Copyright</a> &copy; 1986-2010 by
<a href="http://www.mental.com">mental images GmbH</a></p>
</body>
</html>
