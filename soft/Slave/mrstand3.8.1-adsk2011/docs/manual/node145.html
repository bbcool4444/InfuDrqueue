<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Math Functions</title>
<meta http-equiv="content-type" content="text/html; charset=us-ascii" />
<meta name="author" content="mental images GmbH" />
<link href="mailto:office@mentalimages.com" rev="made" />
<link href="mental.css" rel="stylesheet" media="all" type="text/css" />
<link rel="shortcut icon" href="mentalicon.ico" type="image/x-icon" />
</head>
<body>
<ul class="nav">
<li><a href="index.html">home</a></li>
<li><a href="node144.html">&laquo;&nbsp;prev</a></li>
<li><a href="node146.html">next&nbsp;&raquo;</a></li>
<li><a href="globalindex.html">index</a></li>
</ul>
<a id="SECTION143"></a>

<ul class="nav tag">
<li><a href="#api:mi_vector_add">mi_vector_add</a></li>
<li><a href="#api:mi_vector_sub">mi_vector_sub</a></li>
<li><a href="#api:mi_vector_mul">mi_vector_mul</a></li>
<li><a href="#api:mi_vector_div">mi_vector_div</a></li>
<li><a href="#api:mi_vector_prod">mi_vector_prod</a></li>
<li><a href="#api:mi_vector_dot">mi_vector_dot</a></li>
<li><a href="#api:mi_vector_norm">mi_vector_norm</a></li>
<li><a href="#api:mi_vector_normalize">mi_vector_normalize</a></li>
<li><a href="#api:mi_vector_min">mi_vector_min</a></li>
<li><a href="#api:mi_vector_max">mi_vector_max</a></li>
<li><a href="#api:mi_vector_det">mi_vector_det</a></li>
<li><a href="#api:mi_vector_dist">mi_vector_dist</a></li>
<li><a href="#api:mi_matrix_ident">mi_matrix_ident</a></li>
<li><a href="#api:mi_matrix_isident">mi_matrix_isident</a></li>
<li><a href="#api:mi_matrix_invert">mi_matrix_invert</a></li>
<li><a href="#api:mi_matrix_prod">mi_matrix_prod</a></li>
<li><a href="#api:mi_matrix_rotate">mi_matrix_rotate</a></li>
<li><a href="#api:mi_matrix_rotate_axis">mi_matrix_rotate_axis</a></li>
<li><a href="#api:mi_matrix_solve">mi_matrix_solve</a></li>
<li><a href="#api:mi_matrix_rot_det">mi_matrix_rot_det</a></li>
<li><a href="#api:mi_point_transform">mi_point_transform</a></li>
<li><a href="#api:mi_vector_transform">mi_vector_transform</a></li>
<li><a href="#api:mi_vector_transform_T">mi_vector_transform_T</a></li>
<li><a href="#api:mi_point_to_world">mi_point_to_world</a></li>
<li><a href="#api:mi_point_to_camera">mi_point_to_camera</a></li>
<li><a href="#api:mi_point_to_object">mi_point_to_object</a></li>
<li><a href="#api:mi_point_to_light">mi_point_to_light</a></li>
<li><a href="#api:mi_point_to_raster">mi_point_to_raster</a></li>
<li><a href="#api:mi_point_from_world">mi_point_from_world</a></li>
<li><a href="#api:mi_point_from_camera">mi_point_from_camera</a></li>
<li><a href="#api:mi_point_from_object">mi_point_from_object</a></li>
<li><a href="#api:mi_point_from_light">mi_point_from_light</a></li>
<li><a href="#api:mi_vector_to_world">mi_vector_to_world</a></li>
<li><a href="#api:mi_vector_to_camera">mi_vector_to_camera</a></li>
<li><a href="#api:mi_vector_to_object">mi_vector_to_object</a></li>
<li><a href="#api:mi_vector_to_light">mi_vector_to_light</a></li>
<li><a href="#api:mi_vector_from_world">mi_vector_from_world</a></li>
<li><a href="#api:mi_vector_from_camera">mi_vector_from_camera</a></li>
<li><a href="#api:mi_vector_from_object">mi_vector_from_object</a></li>
<li><a href="#api:mi_vector_from_light">mi_vector_from_light</a></li>
<li><a href="#api:mi_normal_to_world">mi_normal_to_world</a></li>
<li><a href="#api:mi_normal_to_camera">mi_normal_to_camera</a></li>
<li><a href="#api:mi_normal_to_object">mi_normal_to_object</a></li>
<li><a href="#api:mi_normal_to_light">mi_normal_to_light</a></li>
<li><a href="#api:mi_normal_from_world">mi_normal_from_world</a></li>
<li><a href="#api:mi_normal_from_camera">mi_normal_from_camera</a></li>
<li><a href="#api:mi_normal_from_object">mi_normal_from_object</a></li>
<li><a href="#api:mi_normal_from_light">mi_normal_from_light</a></li>
</ul>

<h3>Math Functions</h3>
<p><a id="INDEX632"></a> Math functions include
common vector and matrix operations. More specific noise and
rendering functions can be found in the next two sections, Noise
Functions and Auxiliary Functions.</p>
<p><a id="INDEX633"></a><a id="INDEX634"></a></p>
<pre>
    void mi_vector_neg(
        miVector    *r)
</pre>
<p><i>r := &minus;r</i></p>
<p><a id="INDEX635"></a></p>
<h5 class="anchor" id="api:mi_vector_add">mi_vector_add</h5>
<pre>
    void mi_vector_add(
        miVector    *r,
        miVector    *a,
        miVector    *b)
</pre>
<p><i>r := a + b</i></p>
<p><a id="INDEX636"></a></p>
<h5 class="anchor" id="api:mi_vector_sub">mi_vector_sub</h5>
<pre>
    void mi_vector_sub(
        miVector    *r,
        miVector    *a,
        miVector    *b)
</pre>
<p><i>r := a &minus; b</i></p>
<p><a id="INDEX637"></a></p>
<h5 class="anchor" id="api:mi_vector_mul">mi_vector_mul</h5>
<pre>
    void mi_vector_mul(
        miVector    *r,
        miScalar    f)
</pre>
<p><i>r := r * f</i></p>
<p><a id="INDEX638"></a></p>
<h5 class="anchor" id="api:mi_vector_div">mi_vector_div</h5>
<pre>
    void mi_vector_div(
        miVector    *r,
        miScalar    f)
</pre>
<p><i>r := r &frasl; f</i> &nbsp;&nbsp; (If <i>f</i> is zero, leave
<i>r</i> unchanged.)</p>
<p><a id="INDEX639"></a></p>
<h5 class="anchor" id="api:mi_vector_prod">mi_vector_prod</h5>
<pre>
    void mi_vector_prod(
        miVector    *r,
        miVector    *a,
        miVector    *b)
</pre>
<p><i>r := a</i> x <i>b</i></p>
<p><a id="INDEX640"></a></p>
<h5 class="anchor" id="api:mi_vector_dot">mi_vector_dot</h5>
<pre>
    miScalar mi_vector_dot(
        miVector    *a,
        miVector    *b)
</pre>
<p><i>a * b</i></p>
<p><a id="INDEX641"></a></p>
<h5 class="anchor" id="api:mi_vector_norm">mi_vector_norm</h5>
<pre>
    miScalar mi_vector_norm(
        miVector    *a)
</pre>
<p>||<i>a</i>||</p>
<p><a id="INDEX642"></a></p>
<h5 class="anchor" id="api:mi_vector_normalize">mi_vector_normalize</h5>
<pre>
    void mi_vector_normalize(
        miVector    *r)
</pre>
<p><i>r := r &frasl; ||r||</i> &nbsp;&nbsp; (If <i>r</i> is a null
vector, leave <i>r</i> unchanged.)</p>
<p><a id="INDEX643"></a></p>
<h5 class="anchor" id="api:mi_vector_min">mi_vector_min</h5>
<pre>
    void mi_vector_min(
        miVector    *r,
        miVector    *a,
        miVector    *b)
</pre>
<p>Assign the minimum x, y, and z coordinates of <i>a</i> and
<i>b</i> to <i>r</i>.</p>
<a id="INDEX644"></a>
<h5 class="anchor" id="api:mi_vector_max">mi_vector_max</h5>
<pre>
    void mi_vector_max(
        miVector    *r,
        miVector    *a,
        miVector    *b)
</pre>
<p>Assign the minimum x, y, and z coordinates of <i>a</i> and
<i>b</i> to <i>r</i>.</p>
<a id="INDEX645"></a>
<h5 class="anchor" id="api:mi_vector_det">mi_vector_det</h5>
<pre>
    miScalar mi_vector_det(
        miVector    *a,
        miVector    *b,
        miVector    *c)
</pre>
<p>Return the determinant of the matrix formed by the three column
vectors <i>a</i>, <i>b</i>, and <i>c</i>.</p>
<a id="INDEX646"></a>
<h5 class="anchor" id="api:mi_vector_dist">mi_vector_dist</h5>
<pre>
    miScalar mi_vector_dist(
        miVector    *a,
        miVector    *b)
</pre>
<p><i>||a &minus; b||</i></p>
<a id="INDEX647"></a><a id="INDEX648"></a>
<pre>
    void mi_matrix_null(
        miMatrix     r)
</pre>
<p>Return a null matrix, with all sixteen components set to 0.</p>
<a id="INDEX649"></a>
<h5 class="anchor" id="api:mi_matrix_ident">mi_matrix_ident</h5>
<pre>
    void mi_matrix_ident(
        miMatrix     r)
</pre>
<p>Return an identity matrix, with the main diagonal components set
to 1, and all other components set to 0.</p>
<a id="INDEX650"></a>
<h5 class="anchor" id="api:mi_matrix_isident">mi_matrix_isident</h5>
<pre>
    miBoolean mi_matrix_isident(
        miMatrix const  a)
</pre>
<p>Return <tt>miTRUE</tt> if <i>a</i> is the identity matrix, and
<tt>miFALSE</tt> otherwise.</p>
<a id="INDEX651"></a><a id="INDEX652"></a>
<pre>
    void mi_matrix_copy(
        miMatrix     r,
        miMatrix     a)
</pre>
<p><i>r := a</i></p>
<a id="INDEX653"></a>
<h5 class="anchor" id="api:mi_matrix_invert">mi_matrix_invert</h5>
<pre>
    miBoolean mi_matrix_invert(
        miMatrix        r,
        miMatrix const  a)
</pre>
<p><i>r := a<sup>&minus;1</sup></i> &nbsp;&nbsp;(Returns <tt>miFALSE</tt>
if the matrix cannot be inverted.)</p>
<p><a id="INDEX654"></a></p>
<h5 class="anchor" id="api:mi_matrix_prod">mi_matrix_prod</h5>
<pre>
    void mi_matrix_prod(
        miMatrix        r,
        miMatrix const  a,
        miMatrix const  b)
</pre>
<p><i>r := a</i> x <i>b</i></p>
<p><a id="INDEX655"></a></p>
<h5 class="anchor" id="api:mi_matrix_rotate">mi_matrix_rotate</h5>
<pre>
    void mi_matrix_rotate(
        miMatrix        a,
        const miScalar  xrot,
        const miScalar  yrot,
        const miScalar  zrot)
</pre>
<p>Create a rotation matrix <i>a</i> rotating by <i>xrot</i>, then
<i>yrot</i>, then <i>zrot</i>, in radians.</p>
<p><a id="INDEX656"></a></p>
<h5 class="anchor" id="api:mi_matrix_rotate_axis">mi_matrix_rotate_axis</h5>
<pre>
    void mi_matrix_rotate_axis(
        miMatrix        a,
        miVector const *const v,
        miScalar const  r)
</pre>
<p>This function is similar to the previous, except that the
rotation is specified with an axis and an angle. The resulting
matrix will rotate a point <i>r</i> radians about the axis <i>v</i>
according to the right-hand rule. <i>v</i> must have unit length,
otherwise the result is undefined.</p>
<p><a id="INDEX657"></a></p>
<h5 class="anchor" id="api:mi_matrix_solve">mi_matrix_solve</h5>
<pre>
    void mi_matrix_solve(
        miScalar        *X,
        miMatrix const   A,
        miScalar const  *B,
        int              c)
</pre>
<p>Solve the system of linear equations <i>A * X = B</i> for
<i>X</i>. <i>A</i> is a <i>[4,4]</i> matrix, but <i>X</i> and
<i>B</i> are <i>[4,c]</i> (row major) matrices. For <i>c = 1</i>
they are simple vectors and the function solves <i>A * X = B</i>
for <i>X</i>. In the case <i>c=4</i>, <i>A</i> and <i>B</i> are
rectangular <i>[4,4]</i> matrices and the function computes the
matrix division <i>A &frasl; B</i>. Using this function is both faster
and more precise than explicitly computing
<i>A<sup>&minus;1</sup>B</i>.</p>
<p>All the following transformation functions may be called with
identical pointers <i>r</i> and <i>v</i>. The vector is transformed
in-place in this case. If the matrix <i>m</i> is a null pointer, no
transformation is done and <i>v</i> is copied to <i>r</i>. If the
result of a transformation is a point in
<a href="node85.html#INDEX310">homogeneous coordinates</a> with a <i>w</i>
component that is not equal to 1.0, the result vector's <i>x</i>,
<i>y</i>, and <i>z</i> components are divided by <i>w</i>. For
<b><a id="INDEX658"></a>point transformation</b>s,
a <i>w</i> component of 1.0 is implicitly appended to the <i>v</i>
vector at the vector-matrix multiplication. For
<a href="node145.html#INDEX681">vector transformation</a>s the <i>w</i>
component is implicitly zero. Note the distinction between object
and light transformations - both sets deal with
<a href="node101.html#INDEX369">object space</a>, but the former uses the
current object's object space and the latter uses the current
light's object space.</p>
<p><a id="INDEX659"></a></p>
<h5 class="anchor" id="api:mi_matrix_rot_det">mi_matrix_rot_det</h5>
<pre>
    float mi_matrix_rot_det(
        miMatrix const  a)
</pre>
<p>Return the determinant of the 3 x 3 rotation part of matrix
<i>a</i>.</p>
<p><a id="INDEX660"></a></p>
<h5 class="anchor" id="api:mi_point_transform">mi_point_transform</h5>
<pre>
    void mi_point_transform(
        miVector       *const r,
        miVector const *const v,
        miMatrix const  m)
</pre>
<p><i>r := v * M</i></p>
<p><a id="INDEX661"></a></p>
<h5 class="anchor" id="api:mi_vector_transform">mi_vector_transform</h5>
<pre>
    void mi_vector_transform(
        miVector       *const r,
        miVector const *const v,
        miMatrix const  m)
</pre>
<p><i>r := v * M</i> &nbsp;&nbsp; Only the upper left 3-by-3
submatrix is used since this is a vector transform. The translation
row in the matrix is ignored as <i>w</i> is implicitly assumed to
be 0.</p>
<p><a id="INDEX662"></a></p>
<h5 class="anchor" id="api:mi_vector_transform_T">mi_vector_transform_T</h5>
<pre>
    void mi_vector_transform_T(
        miVector       *const r,
        miVector const *const v,
        miMatrix const  m)
</pre>
<p><i>r := v * M</i><sup>T</sup> &nbsp;&nbsp; The transpose of the
upper left 3-by-3 submatrix is used for the vector transformation.
The <i>w</i> component of <i>v</i> is implicitly assumed to be 0.
This function is required for transformation of normals.</p>
<p><a id="INDEX663"></a></p>
<h5 class="anchor" id="api:mi_point_to_world">mi_point_to_world</h5>
<pre>
    void mi_point_to_world(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert internal point <i>v</i> in the state to
<a href="node101.html#INDEX368">world space</a>, <i>r</i>.</p>
<p><a id="INDEX664"></a></p>
<h5 class="anchor" id="api:mi_point_to_camera">mi_point_to_camera</h5>
<pre>
    void mi_point_to_camera(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert internal point <i>v</i> in the state to
<a href="node101.html#INDEX370">camera space</a>, <i>r</i>.</p>
<p><a id="INDEX665"></a></p>
<h5 class="anchor" id="api:mi_point_to_object">mi_point_to_object</h5>
<pre>
    void mi_point_to_object(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert internal point <i>v</i> to the
<a href="node101.html#INDEX369">object space</a> of the current object
(illuminated point), <i>r</i>.</p>
<p><a id="INDEX666"></a></p>
<h5 class="anchor" id="api:mi_point_to_light">mi_point_to_light</h5>
<pre>
    void mi_point_to_light(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert internal point <i>v</i> in the state to the
<a href="node101.html#INDEX369">object space</a> of the current light. This
function (and the other five light transformation functions
described below) are similar to the corresponding object
transformation functions except that they use
<tt>state&rarr;light_instance</tt> instead of
<tt>state&rarr;instance</tt> to locate the correct object space
transformation matrices.</p>
<p><a id="INDEX667"></a></p>
<h5 class="anchor" id="api:mi_point_to_raster">mi_point_to_raster</h5>
<pre>
    void mi_point_to_raster(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert internal point <i>v</i> in the state to 2D
<a href="node101.html#INDEX371">raster space</a>, <i>r</i>. Raster space
dimension is defined by the camera resolution.</p>
<p><a id="INDEX668"></a></p>
<h5 class="anchor" id="api:mi_point_from_world">mi_point_from_world</h5>
<pre>
    void mi_point_from_world(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert point <i>v</i> in <a href="node101.html#INDEX368">world
space</a> to <a href="node101.html#INDEX367">internal space</a>,
<i>r</i>.</p>
<p><a id="INDEX669"></a></p>
<h5 class="anchor" id="api:mi_point_from_camera">mi_point_from_camera</h5>
<pre>
    void mi_point_from_camera(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert point in <a href="node101.html#INDEX370">camera
space</a> <i>v</i> to <a href="node101.html#INDEX367">internal
space</a>, <i>r</i>.</p>
<p><a id="INDEX670"></a></p>
<h5 class="anchor" id="api:mi_point_from_object">mi_point_from_object</h5>
<pre>
    void mi_point_from_object(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert point <i>v</i> in the <a href="node101.html#INDEX369">object space</a>
of the current object
(illuminated point) to <a href="node101.html#INDEX367">internal
space</a>, <i>r</i>.</p>
<p><a id="INDEX671"></a></p>
<h5 class="anchor" id="api:mi_point_from_light">mi_point_from_light</h5>
<pre>
    void mi_point_from_light(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert point <i>v</i> in the <a href="node101.html#INDEX369">object space</a>
of the current light as
found in <tt>state&rarr;light_instance</tt> to
<a href="node101.html#INDEX367">internal space</a>, <i>r</i>.</p>
<p><a id="INDEX672"></a></p>
<h5 class="anchor" id="api:mi_vector_to_world">mi_vector_to_world</h5>
<pre>
    void mi_vector_to_world(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert internal vector <i>v</i> in the state to
<a href="node101.html#INDEX368">world space</a>, <i>r</i>. Vector
transformations work like <a href="node145.html#INDEX658">point
transformation</a>s, except that the translation row of the
transformation matrix is ignored. The resulting vector is not
renormalized. Vector transformations transform normals correctly
only if there is no scaling. For correct transformation of normals
use the normal transformations described below.</p>
<p><a id="INDEX673"></a></p>
<h5 class="anchor" id="api:mi_vector_to_camera">mi_vector_to_camera</h5>
<pre>
    void mi_vector_to_camera(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert internal vector <i>v</i> in the state to
<a href="node101.html#INDEX370">camera space</a>, <i>r</i>.</p>
<p><a id="INDEX674"></a></p>
<h5 class="anchor" id="api:mi_vector_to_object">mi_vector_to_object</h5>
<pre>
    void mi_vector_to_object(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert internal vector <i>v</i> to the
<a href="node101.html#INDEX369">object space</a> of the current object
(illuminated point), <i>r</i>.</p>
<p><a id="INDEX675"></a></p>
<h5 class="anchor" id="api:mi_vector_to_light">mi_vector_to_light</h5>
<pre>
    void mi_vector_to_light(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert internal vector <i>v</i> in the state to
<a href="node101.html#INDEX369">object space</a> of the current light as
found in <tt>state&rarr;light_instance</tt> , <i>r</i>.</p>
<p><a id="INDEX676"></a></p>
<h5 class="anchor" id="api:mi_vector_from_world">mi_vector_from_world</h5>
<pre>
    void mi_vector_from_world(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert vector <i>v</i> in <a href="node101.html#INDEX368">world
space</a> to <a href="node101.html#INDEX367">internal space</a>,
<i>r</i>.</p>
<p><a id="INDEX677"></a></p>
<h5 class="anchor" id="api:mi_vector_from_camera">mi_vector_from_camera</h5>
<pre>
    void mi_vector_from_camera(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert vector in <a href="node101.html#INDEX370">camera
space</a> <i>v</i> to <a href="node101.html#INDEX367">internal
space</a>, <i>r</i>.</p>
<p><a id="INDEX678"></a></p>
<h5 class="anchor" id="api:mi_vector_from_object">mi_vector_from_object</h5>
<pre>
    void mi_vector_from_object(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert vector <i>v</i> in the
<a href="node101.html#INDEX369">object space</a> of the current object
(illuminated point) to <a href="node101.html#INDEX367">internal
space</a>, <i>r</i>.</p>
<p><a id="INDEX679"></a></p>
<h5 class="anchor" id="api:mi_vector_from_light">mi_vector_from_light</h5>
<pre>
    void mi_vector_from_light(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert vector <i>v</i> in <a href="node101.html#INDEX369">object space</a>
of the current light as
found in <tt>state&rarr;light_instance</tt> to
<a href="node101.html#INDEX367">internal space</a>, <i>r</i>.</p>
<p><a id="INDEX680"></a></p>
<h5 class="anchor" id="api:mi_normal_to_world">mi_normal_to_world</h5>
<pre>
    void mi_normal_to_world(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert internal normal <i>v</i> in the state to
<a href="node101.html#INDEX368">world space</a>, <i>r</i>. Normal
transformations work like <b><a id="INDEX681"></a>vector transformation</b>s,
except that the
transpose of the inverse transformation matrix used. The resulting
vector is not renormalized. This ensures that if a vector and a
normal are orthogonal in one coordinate system they remain
orthogonal after they have been transformed to a different
coordinate system. This holds for arbitrary, not necessarily
orthogonal transformations. The vector transformations described
above transform normals correctly only if there is no scaling.</p>
<p><a id="INDEX682"></a></p>
<h5 class="anchor" id="api:mi_normal_to_camera">mi_normal_to_camera</h5>
<pre>
    void mi_normal_to_camera(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert internal normal <i>v</i> in the state to
<a href="node101.html#INDEX370">camera space</a>, <i>r</i>.</p>
<p><a id="INDEX683"></a></p>
<h5 class="anchor" id="api:mi_normal_to_object">mi_normal_to_object</h5>
<pre>
    void mi_normal_to_object(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert internal normal <i>v</i> to the
<a href="node101.html#INDEX369">object space</a> of the current object
(illuminated point), <i>r</i>.</p>
<p><a id="INDEX684"></a></p>
<h5 class="anchor" id="api:mi_normal_to_light">mi_normal_to_light</h5>
<pre>
    void mi_normal_to_light(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert internal normal <i>v</i> in the state to
<a href="node101.html#INDEX369">object space</a> of the current light as
found in <tt>state&rarr;light_instance</tt> , <i>r</i>.</p>
<p><a id="INDEX685"></a></p>
<h5 class="anchor" id="api:mi_normal_from_world">mi_normal_from_world</h5>
<pre>
    void mi_normal_from_world(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert normal <i>v</i> in <a href="node101.html#INDEX368">world
space</a> to <a href="node101.html#INDEX367">internal space</a>,
<i>r</i>.</p>
<p><a id="INDEX686"></a></p>
<h5 class="anchor" id="api:mi_normal_from_camera">mi_normal_from_camera</h5>
<pre>
    void mi_normal_from_camera(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert normal in <a href="node101.html#INDEX370">camera
space</a> <i>v</i> to <a href="node101.html#INDEX367">internal
space</a>, <i>r</i>.</p>
<p><a id="INDEX687"></a></p>
<h5 class="anchor" id="api:mi_normal_from_object">mi_normal_from_object</h5>
<pre>
    void mi_normal_from_object(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert normal <i>v</i> in the <a href="node101.html#INDEX369">object
space</a> of the current object
(illuminated point) to <a href="node101.html#INDEX367">internal
space</a>, <i>r</i>.</p>
<p><a id="INDEX688"></a></p>
<h5 class="anchor" id="api:mi_normal_from_light">mi_normal_from_light</h5>
<pre>
    void mi_normal_from_light(
        miState        *const state,
        miVector       *r,
        miVector       *const v)
</pre>
<p>Convert normal <i>v</i> in <a href="node101.html#INDEX369">object
space</a> of the current light as
found in <tt>state&rarr;light_instance</tt> to
<a href="node101.html#INDEX367">internal space</a>, <i>r</i>.</p>

<ul class="nav">
<li><a href="index.html">home</a></li>
<li><a href="node144.html">&laquo;&nbsp;prev</a></li>
<li><a href="node146.html">next&nbsp;&raquo;</a></li>
<li><a href="globalindex.html">index</a></li>
</ul>
<p><a href="copyright.html">Copyright</a> &copy; 1986-2010 by
<a href="http://www.mental.com">mental images GmbH</a></p>
</body>
</html>
