<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mental ray Interface: mi::shader_v3::Bsdf Class Reference</title>
<link href="mi_iface.css" rel="stylesheet" type="text/css">
</head>
<body>
<ul class="nav">
<li><a href="index.html">home</a></li>
<li><a href="shader_if_cpp.html">up</a></li>
<li><a href="globalindex.html">index</a></li>
</ul>

<!-- Generated by Doxygen 1.5.6 -->
  <div class="navpath"><a class="el" href="namespacemi.html">mi</a>::<a class="el" href="namespacemi_1_1shader__v3.html">shader_v3</a>::<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html">Bsdf</a>
  </div>
<div class="contents">
<h1>mi::shader_v3::Bsdf Class Reference</h1><!-- doxytag: class="mi::shader_v3::Bsdf" --><code>#include &lt;<a class="el" href="shader__bsdf_8h-source.html">shader_bsdf.h</a>&gt;</code>
<p>

<p>
<a href="classmi_1_1shader__v3_1_1Bsdf-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br>
&nbsp;&nbsp;<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf899743e3b8201d85e74974bcc40a5a6531">Invalid</a> =  0x00, 
<br>
&nbsp;&nbsp;<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf895b0f8c58be3d30217c92843344fe2dfb">Reflect_diffuse</a> =  0x01, 
<br>
&nbsp;&nbsp;<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf89329b286e838e3f8a2822fb80242cc669">Reflect_glossy</a> =  0x02, 
<br>
&nbsp;&nbsp;<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf899c2932b5b7fc523d46e5de326f4fa4f6">Reflect_specular</a> =  0x04, 
<br>
&nbsp;&nbsp;<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf896a4470879b5389bc4d44e6e055760ba4">Transmit_diffuse</a> =  0x10, 
<br>
&nbsp;&nbsp;<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf89f94ac7fa1241959b30597829a920bc2c">Transmit_glossy</a> =  0x20, 
<br>
&nbsp;&nbsp;<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf89cf83c78bd8399a60f2e472a76d42de6a">Transmit_specular</a> =  0x40, 
<br>
&nbsp;&nbsp;<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf89a91b70a99b45f9d7e3ee691c89131009">Reflect_regular</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf89624dd9e27a091509df197cfd96495f68">Transmit_regular</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf893e0d9e4d95b80455a9e8436556db1c1c">All_diffuse</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf89652af6b2f5cb90e26f1f36eb8d88a1fe">All_glossy</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf896ad825e37246ccaa241a3c2a5e329290">All_specular</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf8940a7f25792221fcf9dfed16c86c1053d">All_regular</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf897563fe67dadb65a0c1f7a07b0a27b0b5">All_reflect</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf895442d2ec3730445ae4c7a12bbc781ae9">All_transmit</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf89ba853b204d104a9b4f94d42894ec8ec7">All</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9165b7c378d99c4cae271e7f4b30a977"></a><!-- doxytag: member="mi::shader_v3::Bsdf::Transport" ref="9165b7c378d99c4cae271e7f4b30a977" args="" -->
typedef bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#9165b7c378d99c4cae271e7f4b30a977">Transport</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sampling/evaluation direction <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual miColor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#82b4ae258c69edc9273d13e364894441">eval</a> (const miVector &amp;ray, const miVector &amp;out, Type flags=All, <a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#9165b7c378d99c4cae271e7f4b30a977">Transport</a> dir=<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#01c21340f8c93e1795bb5c98500d3e05">From_eye</a>) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#b506227ceb8b3bd75fa2ae3db0e83014">sample</a> (const miVector &amp;ray, miVector *out, miColor *weight, double xi[3], Type flags=All, <a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#9165b7c378d99c4cae271e7f4b30a977">Transport</a> dir=<a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#01c21340f8c93e1795bb5c98500d3e05">From_eye</a>) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#1dc8016180f4bab5fd975938f4c7108d">all_components</a> (Type type) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2f1bb1445030a9e7dbfe680aca845a50">any_component</a> (Type type) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#7e4a996040c227557895ac1181f9e0f5">get_components</a> () const =0</td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="01c21340f8c93e1795bb5c98500d3e05"></a><!-- doxytag: member="mi::shader_v3::Bsdf::From_eye" ref="01c21340f8c93e1795bb5c98500d3e05" args="" -->
static const <a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#9165b7c378d99c4cae271e7f4b30a977">Transport</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#01c21340f8c93e1795bb5c98500d3e05">From_eye</a> = false</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">rendering from the camera <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d3f6b84853a7ec2c9b66ae24875c6c75"></a><!-- doxytag: member="mi::shader_v3::Bsdf::From_light" ref="d3f6b84853a7ec2c9b66ae24875c6c75" args="" -->
static const <a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#9165b7c378d99c4cae271e7f4b30a977">Transport</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#d3f6b84853a7ec2c9b66ae24875c6c75">From_light</a> = true</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">from the light, e.g. photons <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Simplified BSDF interface.<p>
The <code><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html">Bsdf</a></code> interface represents the concept of a Bidirectional Scattering Distribution Function. The BSDF describes the scattering characteristics of a point, i.e. reflection (the BRDF), and transmission (the BTDF).<p>
This interface allows shaders to interact with BSDFs. Note that it is <em>not</em> designed to be implemented by users. This interface is intended to serve the same purpose as the RC Direction Functions and Shading Models functions (see the manual), but in a generalized way.<p>
For example, a shader might use a <code><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html">Bsdf</a></code> in the following way: <div class="fragment"><pre class="fragment"> Access_bsdf bsdf(state);
 
 <span class="comment">// do light loop</span>
 <span class="keywordflow">for</span> (...) {
     iter-&gt;get_contribution(&amp;light);
     light *= iter-&gt;get_dot_nl();
     direct += light * bsdf-&gt;eval(view_dir,light_dir);
 }
</pre></div><p>
If diffuse and specular contributions are needed separately, the BSDF evaluation can be restricted by passing e.g. <code><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf895b0f8c58be3d30217c92843344fe2dfb" title="diffuse reflection">Bsdf::Reflect_diffuse</a></code> or <code><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf89652af6b2f5cb90e26f1f36eb8d88a1fe" title="glossy reflection and transmission">Bsdf::All_glossy</a></code> as the third parameter of the <code>eval</code> function. Note, however, that multiple separate evaluations of components are more expensive than a single evaluation of all components.<p>
Note that specular components cannot be evaluated, they have to be sampled. Thus, reflections of light sources in perfect mirrors can be achieved by code similar to <div class="fragment"><pre class="fragment"> <span class="keywordtype">double</span> xi[3];
 mi_sample(xi,0,state,3,0);
 <span class="keywordflow">if</span> (bsdf-&gt;sample(view_dir,&amp;refl_dir,&amp;mirror,xi,<a class="code" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf899c2932b5b7fc523d46e5de326f4fa4f6" title="specular reflection">Bsdf::Reflect_specular</a>) 
     &amp;&amp; mi_trace_reflection(&amp;hit,state,&amp;refl_dir)
        &amp;&amp; !state-&gt;child-&gt;pri) {        <span class="comment">// light source hit</span>
     light_hit = mirror * hit;
 }
</pre></div> <hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="2ae6c2dd6bd4064b6ceac74366a1cf89"></a><!-- doxytag: member="mi::shader_v3::Bsdf::@0" ref="2ae6c2dd6bd4064b6ceac74366a1cf89" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
scatter type.<p>
Type flags are bit patterns. Typical binary operations are valid e.g. for component combinations or sample result inspection. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="2ae6c2dd6bd4064b6ceac74366a1cf899743e3b8201d85e74974bcc40a5a6531"></a><!-- doxytag: member="Invalid" ref="2ae6c2dd6bd4064b6ceac74366a1cf899743e3b8201d85e74974bcc40a5a6531" args="" -->Invalid</em>&nbsp;</td><td>
unknown or absorption </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2ae6c2dd6bd4064b6ceac74366a1cf895b0f8c58be3d30217c92843344fe2dfb"></a><!-- doxytag: member="Reflect_diffuse" ref="2ae6c2dd6bd4064b6ceac74366a1cf895b0f8c58be3d30217c92843344fe2dfb" args="" -->Reflect_diffuse</em>&nbsp;</td><td>
diffuse reflection </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2ae6c2dd6bd4064b6ceac74366a1cf89329b286e838e3f8a2822fb80242cc669"></a><!-- doxytag: member="Reflect_glossy" ref="2ae6c2dd6bd4064b6ceac74366a1cf89329b286e838e3f8a2822fb80242cc669" args="" -->Reflect_glossy</em>&nbsp;</td><td>
glossy reflection </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2ae6c2dd6bd4064b6ceac74366a1cf899c2932b5b7fc523d46e5de326f4fa4f6"></a><!-- doxytag: member="Reflect_specular" ref="2ae6c2dd6bd4064b6ceac74366a1cf899c2932b5b7fc523d46e5de326f4fa4f6" args="" -->Reflect_specular</em>&nbsp;</td><td>
specular reflection </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2ae6c2dd6bd4064b6ceac74366a1cf896a4470879b5389bc4d44e6e055760ba4"></a><!-- doxytag: member="Transmit_diffuse" ref="2ae6c2dd6bd4064b6ceac74366a1cf896a4470879b5389bc4d44e6e055760ba4" args="" -->Transmit_diffuse</em>&nbsp;</td><td>
diffuse transmission </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2ae6c2dd6bd4064b6ceac74366a1cf89f94ac7fa1241959b30597829a920bc2c"></a><!-- doxytag: member="Transmit_glossy" ref="2ae6c2dd6bd4064b6ceac74366a1cf89f94ac7fa1241959b30597829a920bc2c" args="" -->Transmit_glossy</em>&nbsp;</td><td>
glossy transmission </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2ae6c2dd6bd4064b6ceac74366a1cf89cf83c78bd8399a60f2e472a76d42de6a"></a><!-- doxytag: member="Transmit_specular" ref="2ae6c2dd6bd4064b6ceac74366a1cf89cf83c78bd8399a60f2e472a76d42de6a" args="" -->Transmit_specular</em>&nbsp;</td><td>
specular transmission </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2ae6c2dd6bd4064b6ceac74366a1cf89a91b70a99b45f9d7e3ee691c89131009"></a><!-- doxytag: member="Reflect_regular" ref="2ae6c2dd6bd4064b6ceac74366a1cf89a91b70a99b45f9d7e3ee691c89131009" args="" -->Reflect_regular</em>&nbsp;</td><td>
non-specular reflection </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2ae6c2dd6bd4064b6ceac74366a1cf89624dd9e27a091509df197cfd96495f68"></a><!-- doxytag: member="Transmit_regular" ref="2ae6c2dd6bd4064b6ceac74366a1cf89624dd9e27a091509df197cfd96495f68" args="" -->Transmit_regular</em>&nbsp;</td><td>
non-specular transmission </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2ae6c2dd6bd4064b6ceac74366a1cf893e0d9e4d95b80455a9e8436556db1c1c"></a><!-- doxytag: member="All_diffuse" ref="2ae6c2dd6bd4064b6ceac74366a1cf893e0d9e4d95b80455a9e8436556db1c1c" args="" -->All_diffuse</em>&nbsp;</td><td>
diffuse reflection and transmission </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2ae6c2dd6bd4064b6ceac74366a1cf89652af6b2f5cb90e26f1f36eb8d88a1fe"></a><!-- doxytag: member="All_glossy" ref="2ae6c2dd6bd4064b6ceac74366a1cf89652af6b2f5cb90e26f1f36eb8d88a1fe" args="" -->All_glossy</em>&nbsp;</td><td>
glossy reflection and transmission </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2ae6c2dd6bd4064b6ceac74366a1cf896ad825e37246ccaa241a3c2a5e329290"></a><!-- doxytag: member="All_specular" ref="2ae6c2dd6bd4064b6ceac74366a1cf896ad825e37246ccaa241a3c2a5e329290" args="" -->All_specular</em>&nbsp;</td><td>
specular reflection and transmission </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2ae6c2dd6bd4064b6ceac74366a1cf8940a7f25792221fcf9dfed16c86c1053d"></a><!-- doxytag: member="All_regular" ref="2ae6c2dd6bd4064b6ceac74366a1cf8940a7f25792221fcf9dfed16c86c1053d" args="" -->All_regular</em>&nbsp;</td><td>
non-specular reflection and transmission </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2ae6c2dd6bd4064b6ceac74366a1cf897563fe67dadb65a0c1f7a07b0a27b0b5"></a><!-- doxytag: member="All_reflect" ref="2ae6c2dd6bd4064b6ceac74366a1cf897563fe67dadb65a0c1f7a07b0a27b0b5" args="" -->All_reflect</em>&nbsp;</td><td>
diffuse, glossy, and specular reflection </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2ae6c2dd6bd4064b6ceac74366a1cf895442d2ec3730445ae4c7a12bbc781ae9"></a><!-- doxytag: member="All_transmit" ref="2ae6c2dd6bd4064b6ceac74366a1cf895442d2ec3730445ae4c7a12bbc781ae9" args="" -->All_transmit</em>&nbsp;</td><td>
diffuse, glossy, and specular transmission </td></tr>
<tr><td valign="top"><em><a class="anchor" name="2ae6c2dd6bd4064b6ceac74366a1cf89ba853b204d104a9b4f94d42894ec8ec7"></a><!-- doxytag: member="All" ref="2ae6c2dd6bd4064b6ceac74366a1cf89ba853b204d104a9b4f94d42894ec8ec7" args="" -->All</em>&nbsp;</td><td>
all types </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="82b4ae258c69edc9273d13e364894441"></a><!-- doxytag: member="mi::shader_v3::Bsdf::eval" ref="82b4ae258c69edc9273d13e364894441" args="(const miVector &amp;ray, const miVector &amp;out, Type flags=All, Transport dir=From_eye) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual miColor mi::shader_v3::Bsdf::eval           </td>
          <td>(</td>
          <td class="paramtype">const miVector &amp;&nbsp;</td>
          <td class="paramname"> <em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const miVector &amp;&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>All</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#9165b7c378d99c4cae271e7f4b30a977">Transport</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em> = <code><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#01c21340f8c93e1795bb5c98500d3e05">From_eye</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evaluates the BSDF at the current point.<p>
When tracing rays from the eye towards the scene (the usual case), <code>dir</code> is <code>From_eye</code>, <code>ray</code> is the view direction and <code>out</code> is the light direction. All directions are in world space. The <code>ray</code> direction points towards the intersection, the <code>out</code> direction points away from it.<p>
Because specular components cannot be evaluated (they can only be sampled), this function only evaluates the diffuse and glossy parts. The contribution from specular components is black. Shaders must use <code>sample</code> to obtain a specular direction and contribution.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ray</em>&nbsp;</td><td>given direction </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>out</em>&nbsp;</td><td>sampled direction </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>allowed types </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dir</em>&nbsp;</td><td>trace direction </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the value of the BSDF at the current point and for the given pair of directions </dd></dl>

</div>
</div><p>
<a class="anchor" name="b506227ceb8b3bd75fa2ae3db0e83014"></a><!-- doxytag: member="mi::shader_v3::Bsdf::sample" ref="b506227ceb8b3bd75fa2ae3db0e83014" args="(const miVector &amp;ray, miVector *out, miColor *weight, double xi[3], Type flags=All, Transport dir=From_eye) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Type mi::shader_v3::Bsdf::sample           </td>
          <td>(</td>
          <td class="paramtype">const miVector &amp;&nbsp;</td>
          <td class="paramname"> <em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">miVector *&nbsp;</td>
          <td class="paramname"> <em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">miColor *&nbsp;</td>
          <td class="paramname"> <em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>xi</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>All</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#9165b7c378d99c4cae271e7f4b30a977">Transport</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em> = <code><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#01c21340f8c93e1795bb5c98500d3e05">From_eye</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Importance samples an outgoing direction using the quasirandom numbers supplied in <code>xi</code> and stores it in <code>out</code>.<p>
All directions are in world space. The <code>ray</code> direction points towards the intersection, the <code>out</code> direction points away from it.<p>
The importance sampling weight (i.e. the BSDF value for the sampled direction divided by the probability of sampling the direction) will be written to <code>weight</code>. Note that the <code>weight</code> result contains the probability density in projected solid angle measure. One implication of this is that the weight does not have to be multiplied by  <span class="math">cos &theta;</span>, where &theta;   is the angle between surface normal and light, when tracing secondary rays. This function returns the type of the component that was sampled. Note that, while this function may return <code><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2ae6c2dd6bd4064b6ceac74366a1cf899743e3b8201d85e74974bcc40a5a6531" title="unknown or absorption">Bsdf::Invalid</a></code> in some cases, it does <em>not</em> perform Russian roulette for absorption. If Russian roulette is needed, then  <span class="math">min { 1, |<tt>weight</tt>| }</span>   is a good candidate for the continuation probability. Usually, the maximum norm yields the best results.<p>
Suitable values for <code>xi</code> can be acquired e.g. by calling <code>mi_sample</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ray</em>&nbsp;</td><td>known direction </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>out</em>&nbsp;</td><td>sampled direction </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>weight</em>&nbsp;</td><td>sample weight </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>xi</em>&nbsp;</td><td>sample in [0,1)^3 </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>allowed types </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dir</em>&nbsp;</td><td>trace direction </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the sampled component type </dd></dl>

</div>
</div><p>
<a class="anchor" name="1dc8016180f4bab5fd975938f4c7108d"></a><!-- doxytag: member="mi::shader_v3::Bsdf::all_components" ref="1dc8016180f4bab5fd975938f4c7108d" args="(Type type) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mi::shader_v3::Bsdf::all_components           </td>
          <td>(</td>
          <td class="paramtype">Type&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the BSDF supports all of the given components.<p>
If <code>type</code> is a compound type, e.g <code>All_xxx</code>, this function checks if all of the given components are supported. For single types, this function's result is identical to that of <code><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2f1bb1445030a9e7dbfe680aca845a50">Bsdf::any_component</a></code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the scatter type to check </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if all of the given components are supported by the BSDF, <code>false</code> otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2f1bb1445030a9e7dbfe680aca845a50"></a><!-- doxytag: member="mi::shader_v3::Bsdf::any_component" ref="2f1bb1445030a9e7dbfe680aca845a50" args="(Type type) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mi::shader_v3::Bsdf::any_component           </td>
          <td>(</td>
          <td class="paramtype">Type&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks if the BSDF supports the given component.<p>
If <code>type</code> is a compound type, e.g <code>All_xxx</code>, this function checks if one or more of the given components are supported. For single types, this function's result is identical to that of <code><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#1dc8016180f4bab5fd975938f4c7108d">Bsdf::all_components</a></code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the scatter type to check </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>true</code> if any of the given components are supported by the BSDF, <code>false</code> otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7e4a996040c227557895ac1181f9e0f5"></a><!-- doxytag: member="mi::shader_v3::Bsdf::get_components" ref="7e4a996040c227557895ac1181f9e0f5" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Type mi::shader_v3::Bsdf::get_components           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accesses the components supported by this BSDF.<p>
This function returns a combination of <code>Type</code> flags. Its use is slightly less convenient than <code><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#1dc8016180f4bab5fd975938f4c7108d">Bsdf::all_components</a></code> or <code><a class="el" href="classmi_1_1shader__v3_1_1Bsdf.html#2f1bb1445030a9e7dbfe680aca845a50">Bsdf::any_component</a></code> because boolean operations have to be performed manually. However, it is slightly faster than calling these functions multiple times. Thus, use of this function is recommended over the aforementioned ones when several tests have to be performed. 
</div>
</div><p>
</div>

<ul class="nav">
<li><a href="index.html">home</a></li>
<li><a href="shader_if_cpp.html">up</a></li>
<li><a href="globalindex.html">index</a></li>
</ul>
<p><a href="copyright.html">Copyright</a> &copy; 1986-2010 by
<a href="http://www.mental.com">mental images GmbH</a><br></p>
</body>
</html>

