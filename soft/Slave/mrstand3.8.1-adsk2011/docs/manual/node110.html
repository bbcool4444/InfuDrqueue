<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Options</title>
<meta http-equiv="content-type" content="text/html; charset=us-ascii" />
<meta name="author" content="mental images GmbH" />
<link href="mailto:office@mentalimages.com" rev="made" />
<link href="mental.css" rel="stylesheet" media="all" type="text/css" />
<link rel="shortcut icon" href="mentalicon.ico" type="image/x-icon" />
</head>
<body>
<ul class="nav">
<li><a href="index.html">home</a></li>
<li><a href="node109.html">&laquo;&nbsp;prev</a></li>
<li><a href="node111.html">next&nbsp;&raquo;</a></li>
<li><a href="globalindex.html">index</a></li>
</ul>

<h3 id="SECTION108">Options</h3>

<a id="stateoptions"></a>
<p> <a id="INDEX412"></a> The option data structure pointed to by
<tt>state-&gt;options</tt> has the following format, split here
over three tables due to its size. The option structure may never
be written to by shaders.</p>

<p><a id="INDEX413"></a></p>
<div align="center">
<table class="table">
<tr>
<th><i>type</i></th>
<th><i>name</i></th>
<th><i>content</i></th>
<tr>
<td><tt>int</tt></td>
<td><tt>min_samples</tt></td>
<td>minimum sampling level</td>
<tr>
<td><tt>int</tt></td>
<td><tt>max_samples</tt></td>
<td>maximum sampling level</td>
<tr>
<td><tt>miColor</tt></td>
<td><tt>contrast</tt></td>
<td>sampling contrast</td>
<tr>
<td><tt>miColor</tt></td>
<td><tt>time_contrast</tt></td>
<td>temporal sampling contrast</td>
<tr>
<td><tt>miBoolean</tt></td>
<td><tt>samplelock</tt></td>
<td>noise animation locking on/off</td>
<tr>
<td><tt>char</tt></td>
<td><tt>render_space</tt></td>
<td>coordinate space: 'c' for camera space, 'o' for object
space</td>
<tr>
<td><tt>int</tt></td>
<td><tt>task_size</tt></td>
<td>rendered image rectangle size</td>
<tr>
<td><tt>miCBoolean</tt></td>
<td><tt>pixel_preview</tt></td>
<td>selective pixel sampling mode</td>
<tr>
<td><tt>miCBoolean</tt></td>
<td><tt>task_preview</tt></td>
<td>selective task sampling mode</td>
<tr>
<td><tt>miCBoolean</tt></td>
<td><tt>visible_lights</tt></td>
<td>have visible area lights in the scene</td>
<tr>
<td><tt>miBoolean</tt></td>
<td><tt>strips</tt></td>
<td>tessellation to strips and fans</td>
<tr>
<td><tt>miCBoolean</tt></td>
<td><tt>no_lens</tt></td>
<td>disable lens shaders</td>
<tr>
<td><tt>miCBoolean</tt></td>
<td><tt>no_volume</tt></td>
<td>disable volume shaders</td>
<tr>
<td><tt>miCBoolean</tt></td>
<td><tt>no_geometry</tt></td>
<td>disable geometry shaders</td>
<tr>
<td><tt>miCBoolean</tt></td>
<td><tt>no_displace</tt></td>
<td>disable displace shaders</td>
<tr>
<td><tt>miUint1</tt></td>
<td><tt>no_output</tt></td>
<td>disable output shaders</td>
<tr>
<td><tt>miCBoolean</tt></td>
<td><tt>no_merge</tt></td>
<td>disable edge merging</td>
<tr>
<td><tt>miCBoolean</tt></td>
<td><tt>no_hair</tt></td>
<td>disable hair rendering</td>
<tr>
<td><tt>miCBoolean</tt></td>
<td><tt>no_pass</tt></td>
<td>disable sample passes</td>
<tr>
<td><tt>miCBoolean</tt></td>
<td><tt>no_predisplace</tt></td>
<td>disable displacement shader pre-sampling</td>
<tr>
<td><tt>miTag</tt></td>
<td><tt>userdata</tt></td>
<td>optional user data blocks</td>
<tr>
<td><tt>miApprox</tt></td>
<td><tt>approx</tt></td>
<td>approximation override</td>
<tr>
<td><tt>miApprox</tt></td>
<td><tt>approx_displace</tt></td>
<td>displacement approximation override</td>
<tr>
<td><tt>miTag</tt></td>
<td><tt>contour_contrast</tt></td>
<td>contour contrast shader</td>
<tr>
<td><tt>miTag</tt></td>
<td><tt>contour_store</tt></td>
<td>contour store shader</td>
<tr>
<td><tt>miTag</tt></td>
<td><tt>inh_funcdecl</tt></td>
<td>inheritance/traversal declaration</td>
<tr>
<td><tt>miUint1</tt></td>
<td><tt>diagnostic_mode</tt></td>
<td><tt>miSCENE_DIAG_</tt> flag bitmap</td>
<tr>
<td><tt>float</tt></td>
<td><tt>diag_photon_density</tt></td>
<td>density for diagnostic photon mode</td>
<tr>
<td><tt>float</tt></td>
<td><tt>diag_grid_size</tt></td>
<td>grid size for diagnostic grid mode</td>
<tr>
<td><tt>miBoolean</tt></td>
<td><tt>desaturate</tt></td>
<td>fade to white, no clipping</td>
<tr>
<td><tt>miBoolean</tt></td>
<td><tt>dither</tt></td>
<td>enable frame buffer dithering</td>
<tr>
<td><tt>miBoolean</tt></td>
<td><tt>nopremult</tt></td>
<td>disable <a href="node76.html#INDEX211">premultiplication</a></li>
<tr>
<td><tt>int</tt></td>
<td><tt>colorclip</tt></td>
<td>color clipping modes</td>
<tr>
<td><tt>float</tt></td>
<td><tt>gamma</tt></td>
<td>frame buffer gamma value, 1 for none</td>
<tr>
<td><tt>miColor</tt></td>
<td><tt>luminance_weight</tt></td>
<td>weights to calculate luminance</td>
<tr>
<td><tt>int</tt></td>
<td><tt>no_images</tt></td>
<td>highest frame buffer index plus 1</td>
<!--
<tr>
<td><tt>miPointer</tt></td>
<td><tt>image [ ]</tt></td>
<td>frame buffers for output shaders</td>
<tr>
<td><tt>miImg_type</tt></td>
<td><tt>image_types [ ]</tt></td>
<td>image types of frame buffers</td>
<tr>
<td><tt>miUint4</tt></td>
<td><tt>write_image[ ]</tt></td>
<td>bit 0: sample, bit 1: write</td>
<tr>
<td><tt>miBoolean</tt></td>
<td><tt>interp_image[ ]</tt></td>
<td>interpolate frame buffer</td>
-->
<tr>
<td><tt>miTag</tt></td>
<td><tt>images_info</tt></td>
<td>frame buffer information</td>
<tr>
<td><tt>miTag</tt></td>
<td><tt>fb_dir</tt></td>
<td>frame buffer directory</td>
</table>
</div>

<p>Rendering algorithm options:</p>

<p><a id="INDEX414"></a></p>
<div align="center">
<table class="table">
<tr>
<th><i>type</i></th>
<th><i>name</i></th>
<th><i>content</i></th>
<tr>
<td><tt>miBoolean</tt></td>
<td><tt>trace</tt></td>
<td><a href="node102.html#INDEX390">ray tracing</a> turned on?</td>
<tr>
<td><tt>miBoolean</tt></td>
<td><tt>scanline</tt></td>
<td>scanline mode turned on?</td>
<tr>
<td><tt>miBoolean</tt></td>
<td><tt>motion</tt></td>
<td>motion blur turned on?</td>
<tr>
<td><tt>float</tt></td>
<td><tt>shutter_delay</tt></td>
<td>shutter open time for motion blur</td>
<tr>
<td><tt>float</tt></td>
<td><tt>shutter</tt></td>
<td>shutter close time for motion blur</td>
<tr>
<td><tt>miCBoolean</tt></td>
<td><tt>autovolume</tt></td>
<td>automatic volume management</td>
<tr>
<td><tt>char</tt></td>
<td><tt>filter</tt></td>
<td>nonlocal sampling filter: 'b' - box, 't' - triangle, 'g'
- Gauss, 'm' - Mitchell, or 'l' - Lanczos</td>
<tr>
<td><tt>float</tt></td>
<td><tt>filter_size_x</tt></td>
<td>filter size in x</td>
<tr>
<td><tt>float</tt></td>
<td><tt>filter_size_y</tt></td>
<td>filter size in y</td>
<tr>
<td><tt>int</tt></td>
<td><tt>reflection_depth</tt></td>
<td>max reflection trace depth</td>
<tr>
<td><tt>int</tt></td>
<td><tt>refraction_depth</tt></td>
<td>max refraction trace depth</td>
<tr>
<td><tt>int</tt></td>
<td><tt>trace_depth</tt></td>
<td>max combined trace depth</td>
<tr>
<td><tt>char</tt></td>
<td><tt>face</tt></td>
<td>'f' - front, 'b' - back, or 'a' - both faces</td>
<tr>
<td><tt>char</tt></td>
<td><tt>field</tt></td>
<td>'o' - odd or 'e' - even fields, 0 - frames</td>
<tr>
<td><tt>float</tt></td>
<td><tt>jitter</tt></td>
<td>sample jittering: 0 - off, 1 - on</td>
<tr>
<td><tt>char</tt></td>
<td><tt>shadow</tt></td>
<td>0 - off, 1 - normal, 's' - segmented, 'l' - sorted</td>
<tr>
<td><tt>char</tt></td>
<td><tt>use_shadow_maps</tt></td>
<td>use shadow maps for rendering</td>
<tr>
<td><tt>miCBoolean</tt></td>
<td><tt>rendering_shadow_maps</tt></td>
<td>currently working on a shadow map rectangle</td>
<tr>
<td><tt>char</tt></td>
<td><tt>recompute_shadow_maps</tt></td>
<td>'n' for reuse, 'y' for rebuild</td>
<tr>
<td><tt>miCBoolean</tt></td>
<td><tt>shadow_map_motion</tt></td>
<td>motion blurred shadowmaps</td>
<tr>
<td><tt>char</tt></td>
<td><tt>acceleration</tt></td>
<td><a href="node102.html#INDEX390">ray tracing</a> algorithm: 'b'
- BSP, 'n' - BSP2, 'g' - grid</td>
<tr>
<td><tt>short</tt></td>
<td><tt>grid_res[3]</tt></td>
<td>grid resolution in world space: X, Y, Z</td>
<tr>
<td><tt>short</tt></td>
<td><tt>grid_max_depth</tt></td>
<td>maximum grid nesting</td>
<tr>
<td><tt>short</tt></td>
<td><tt>grid_max_size</tt></td>
<td>maximum grid leaf size</td>
<tr>
<td><tt>float</tt></td>
<td><tt>grid_max_size</tt></td>
<td>grid resolution correction</td>
<tr>
<td><tt>int</tt></td>
<td><tt>space_max_size</tt></td>
<td>maximum BSP leaf size</td>
<tr>
<td><tt>int</tt></td>
<td><tt>space_max_depth</tt></td>
<td>maximum BSP nesting</td>
<tr>
<td><tt>int</tt></td>
<td><tt>space_max_mem</tt></td>
<td>maximum bsp memory in MB, 0 for unlimited</td>
</table>
</div>

<p>Global illumination options:</p>

<p><a id="INDEX415"></a></p>
<div align="center">
<table class="table">
<tr>
<th><i>type</i></th>
<th><i>name</i></th>
<th><i>content</i></th>
<tr>
<td><tt>int</tt></td>
<td><tt>photon_reflection_depth</tt></td>
<td>max photon reflection trace depth</td>
<tr>
<td><tt>int</tt></td>
<td><tt>photon_refraction_depth</tt></td>
<td>max photon refraction trace depth</td>
<tr>
<td><tt>int</tt></td>
<td><tt>photon_trace_depth</tt></td>
<td>max combined photon trace depth</td>
<tr>
<td><tt>miTag</tt></td>
<td><tt>photonmap_file</tt></td>
<td><a href="node48.html#INDEX96">photon map</a> file name</td>
<tr>
<td><tt>miTag</tt></td>
<td><tt>finalgather_file</tt></td>
<td>finalgather map file name</td>
<tr>
<td><tt>miBoolean</tt></td>
<td><tt>photonmap_rebuild</tt></td>
<td>rebuild photon map, don't reuse</td>
<tr>
<td><tt>miCBoolean</tt></td>
<td><tt>finalgather_rebuild</tt></td>
<td>rebuild final gather map</td>
<tr>
<td><tt>miBoolean</tt></td>
<td><tt>caustic</tt></td>
<td>caustics on/off</td>
<tr>
<td><tt>int</tt></td>
<td><tt>caustic_accuracy</tt></td>
<td>number of caustic photons in estimate</td>
<tr>
<td><tt>float</tt></td>
<td><tt>caustic_radius</tt></td>
<td>maximum distance for caustic photons in estimate</td>
<tr>
<td><tt>float</tt></td>
<td><tt>caustic_filter_const</tt></td>
<td>filter constant for caustics</td>
<tr>
<td><tt>char</tt></td>
<td><tt>caustic_filter</tt></td>
<td>caustic filter type: 'b' - box, 'c' - cone, 'g' - Gauss</td>
<tr>
<td><tt>miUint1</tt></td>
<td><tt>caustic_flag</tt></td>
<td>default caustic flag for objects</td>
<tr>
<td><tt>miBoolean</tt></td>
<td><tt>globillum</tt></td>
<td>global illumination on/off</td>
<tr>
<td><tt>int</tt></td>
<td><tt>globillum_accuracy</tt></td>
<td>number of globillum photons in estimate</td>
<tr>
<td><tt>float</tt></td>
<td><tt>globillum_radius</tt></td>
<td>maximum distance for globillum photons in estimate</td>
<tr>
<td><tt>miUint1</tt></td>
<td><tt>globillum_flag</tt></td>
<td>default globillum flag for objects</td>
<tr>
<td><tt>int</tt></td>
<td><tt>photonvol_accuracy</tt></td>
<td>number of volume photons in estimate</td>
<tr>
<td><tt>float</tt></td>
<td><tt>photonvol_radius</tt></td>
<td>maximum distance for volume photons in estimate</td>
<tr>
<td><tt>int</tt></td>
<td><tt>finalgather</tt></td>
<td>final gathering: 0 - off, 1 - on, or 'f' - fastlookup</td>
<tr>
<td><tt>int</tt></td>
<td><tt>finalgather_rays</tt></td>
<td>number of rays per final gather point</td>
<tr>
<td><tt>float</tt></td>
<td><tt>finalgather_maxradius</tt></td>
<td>maximum distance between final gather points</td>
<tr>
<td><tt>float</tt></td>
<td><tt>finalgather_minradius</tt></td>
<td>minimum distance between final gather points</td>
<tr>
<td><tt>miCBoolean</tt></td>
<td><tt>finalgather_view</tt></td>
<td>final gather radii are specified in raster pixels</td>
<tr>
<td><tt>miUint1</tt></td>
<td><tt>n_motion_vectors</tt></td>
<td>motion transformation path length</td>
</table>
</div>

<dl>
<dt><code>min_samples</code><dd>
The minimum oversampling level. 0 means one sample per pixel on
average (mental ray actually samples corners, not centers of
pixels). 1 means subdivide once, which results in four subpixels. 2
means each subpixel is subdivided again, resulting in 16 subpixels,
and so on. -1 means one sample per four pixels, etc.

<dt><code>max_samples</code><dd>
After initial subdivision controlled by <i>min_samples</i>,
pixels are further subdivided if the contrast demands it, up to the
level determined by <i>max_samples</i>.

<dt><code>contrast</code><dd>
If two neighboring samples are more different than the contrast,
the pixel is subdivided unless the <i>max_samples</i> limit has
been reached.

<dt><code>time_contrast</code><dd>
Approximately an inverse to the number of time oversampling
steps in motion blur rendering.

<dt><code>samplelock</code><dd>
If enabled, mental ray attempts to cast the same samples in each
frame, which means that the graininess due to low sampling stays in
place, instead of flickering. This is achieved by not initializing
sampling sequences with the <a href="node199.html#INDEX1061">frame
number</a>. This has an effect only where the image doesn't change
because otherwise oversampling will cast different samples.
note that <i>min_samples</i>, <i>max_samples</i>, <i>contrast</i>,
and <i>time_contrast</i> are not used by the rasterizer.

<dt><code>render_space</code><dd>
This is 'o' for <a href="node101.html#INDEX369">object space</a>
and 'c' for camera space. Camera space rendering is supported for
compatibility with mental ray 1.x, but not recommended for new
scenes.

<dt><code>task_size</code><dd>
The size of one image rectangle into which the image to render
is subdivided. A reasonable default is computed from the output
image size if no value has been given explicitly.

<dt><code>pixel_preview</code><dd>
This is enabled during interactive rendering, where mental ray
renders only those pixels that are affected by a user change,
usually by tuning a shader parameter.

<dt><code>task_preview</code><dd>
This is enabled if the application has entered a mode where only
certain image rectangles are rendered.

<dt><code>visible_lights</code><dd>
This is true if there are any lights marked "visible" in the
currently rendered scene.

<dt><code>strips</code><dd>
The tessellator will attempt to pack triangles into strips and
fans. This is not useful for rendering with mental ray, and in fact
incurs overhead due to strip and fan construction, but it can
greatly improve the performance of OpenGL viewers.

<dt><code>no_lens</code><br/>
<code>no_volume</code><br/>
<code>no_geometry</code><br/>
<code>no_displace</code><br/>
<code>no_output</code><br/>
<code>no_merge</code><br/>
<code>no_hair</code><br/>
<code>no_pass</code><br/>
<code>no_predisplace</code><dd>
These flags disable lens, volume, geometry, displace, and output
shader calls, respectively, or edge merging, hair and sample pass
rendering, and displacement pre-sampling. They are useful for
quick preview rendering. Shaders may still explicitly call the
disabled shaders, but mental ray won't.

<dt><code>userdata</code><dd>
User data blocks are independent named toplevel scene entities
that hold structured or unstructured data of any kind. Structured
data is declared much like shader parameters, while unstructured
data is a raw byte stream with a fixed size. User data is useful
for large amounts of shared scene data.

<dt><code>approx</code><dd>
May be set to any approximation method, which will override
approximations specified in objects. This is useful for quick
preview rendering where geometric precision does not matter. This
is disabled if the method is set to <tt>miAPPROX_STYLE_NONE</tt>.

<dt><code>approx_displace</code><dd>
This is the same as <i>approx</i>, but applies to displacement
approximations in objects.

<dt><code>contour_contrast</code><dd>
The <a href="node40.html#INDEX85">contour contrast shader</a>,
or 0.
<dt><code>contour_store</code><dd>
The <a href="node131.html#INDEX498">contour store shader</a>, or 0.

<dt><code>inh_funcdecl</code><dd>
The declaration of the <a href="node76.html#INDEX224">inheritance
function</a> or <a href="node76.html#INDEX225">traversal function</a>,
or 0.

<dt><code>diagnostic_mode</code><dd>
If nonzero, enables various diagnostic modes that put
false-color diagnostic data on top of the rendered image. The modes
are:
<dl>
<dt><tt>miSCENE_DIAG_SAMPLES</tt><dd>
shows where image samples were taken.
<dt><tt>miSCENE_DIAG_PHOTON_D</tt><dd> shows photon density.
<dt><tt>miSCENE_DIAG_PHOTON_I</tt><dd> shows photon
<a href="node48.html#INDEX97">irradiance</a>.
<dt><tt>miSCENE_DIAG_GRID_O</tt><dd> overlays object-space grid lines.
<dt><tt>miSCENE_DIAG_GRID_W</tt><dd> overlays world-space grid lines.
<dt><tt>miSCENE_DIAG_GRID_C</tt><dd> overlays camera-space grid lines.
<dt><tt>miSCENE_DIAG_BSP_D</tt><dd> shows the BSP tree depth.
<dt><tt>miSCENE_DIAG_BSP_L</tt><dd> shows the BSP leaf size.
<dt><tt>miSCENE_DIAG_FG</tt><dd> shows final gather points.
</dl>

<dt><code>diag_photon_density</code><dd>
Calibrates the colors for the photon diagnostic modes.

<dt><code>diag_grid_size</code><dd>
Determines the grid line distance in the grid diagnostic
modes.

<dt><code>desaturate</code><dd>
Enables fading colors to white, instead of clipping individual
components, when storing colors in 8-bit or 16-bit frame buffers.

<dt><code>dither</code><dd>
Enables dithering when storing colors in 8-bit or 16-bit frame buffers.

<dt><code>nopremult</code><dd>
Disables <a href="node76.html#INDEX211">premultiplication</a>,
and stores unpremultiplied colors in frame buffers.

<dt><code>colorclip</code><dd>
Selects the color clipping mode applied when storing colors in
8-bit or 16-bit frame buffers, to make sure that RGB do not exceed
alpha in <a href="node76.html#INDEX211">premultiplication</a> mode:
<dl>
<dt><tt>miIMG_COLORCLIP_RGB</tt><dd> preserves RGB and adjusts alpha if
necessary.
<dt><tt>miIMG_COLORCLIP_ALPHA</tt><dd> preserves alpha and adjusts RGB
if necessary.
<dt><tt>miIMG_COLORCLIP_RAW</tt><dd> disables color clipping.
</dl>
Color clipping is applied to the color averaged over the time if
motion blur is rendered.

<dt><code>gamma</code><dd>
The gamma value applied when storing colors in 8-bit or 16-bit
frame buffers. 1.0 disables <a href="node76.html#INDEX215">gamma
correction</a>.

<dt><code>luminance_weight</code><dd>
The weights applied to RGB by the
<i><a href="node150.html#INDEX747">mi_luminance</a></i> shader interface
function to compute a luminance value.

<dt><code>no_images</code><dd>
<span class="depr">Deprecated</span>
The number of the highest defined frame buffer, plus 1.

<!--
<p><i>image</i>[ ]</p>
<p>An array of pointers to <a href="node144.html#INDEX617">frame
buffer</a>s. It is available only in <a href="node126.html#INDEX492">output shader</a>s. The type is
<tt>miPointer</tt> to ensure network transparency, requiring access
with <tt>image[i].p</tt>; the real type is <tt>miImg_image *</tt>.
The array is indexed with the predefined indices, each
corresponding to one of the standard frame buffers that are enabled
with appropriate <a href="node77.html#INDEX0">output</a>
statements. If a frame buffer was not enabled, the corresponding
pointer is 0. The predefined indices are: <tt>miRC_IMAGE_RGBA</tt>
is the standard color image frame buffer. <tt>miRC_IMAGE_Z</tt>
contains object depths. <tt>miRC_IMAGE_N</tt> contains normal
vectors. <tt>miRC_IMAGE_M</tt> contains motion vectors.
<tt>miRC_IMAGE_TAG</tt> contains object labels.
<tt>miRC_IMAGE_COVERAGE</tt> contains coverage fractions of the
object that contributed most to this pixel. If enabled, the Z, N,
M, and TAG frame buffers contain values from that object.
<tt>miRC_IMAGE_PPREV</tt> contains shader bitmaps
used for pixel previewing (interactive rendering).
<tt>miRC_IMAGE_USER</tt> is the first user frame buffer. There is
not limitation on the number of frame buffers in mental ray.
All <a href="node144.html#INDEX617">frame buffer</a>s have the same
resolution as specified in the camera. The frame buffer pointers can
be passed to the buffer access functions, <i><a href="node144.html#INDEX619">mi_img_get_color</a></i>, <i><a href="node144.html#INDEX618">mi_img_put_color</a></i>, etc. For each
type of frame buffer, there are functions to retrieve and store a
pixel value that accept the frame buffer pointer as their first
argument. Motion vector data can be accessed with the normal-vector
access functions; the data format is identical.</p>
<p>In mental ray 3.4, the <i>images</i> field has been removed. See
<i><a href="node150.html#INDEX757">mi_output_image_open</a></i> and
<i><a href="node150.html#INDEX758">mi_output_image_close</a></i>.
In addition, the arrays <i>image_types</i>, <i>write_image</i> and
<i>interp_image</i> are combined in the <tt>miFb_info</tt>
structure. The database array of this structure is stored in
<i>images_info</i>.</p>
<p><i>image_types</i>[ ]</p>
<p>Contains the type of each defined <a href="node144.html#INDEX617">frame buffer</a>. Removed in mental ray
3.4.</p>
<p><i>write_image</i>[ ]</p>
<p>For each defined frame buffer, bit 0 is set if the frame buffer
is sampled, and bit 1 is set if the frame buffer is written.
Removed in mental ray 3.4.</p>
<p><i>interp_image</i>[ ]</p>
<p>For each defined frame buffer, the flag is set if the frame
buffer is interpolated ("+" was set in the scene) or aliased ("-"
was set in the scene). Removed in mental ray 3.4.</p>
-->

<dt><code>images_info</code><dd>
An array of type <tt>miFb_info</tt> specifying the frame buffers.

<p>Rendering algorithm options in the <i>state</i>&rarr;options
structure:</p>

<dt><code>trace</code><dd>
If this flag is <tt>miTRUE</tt>, secondary
<a href="node102.html#INDEX390">ray tracing</a> (reflection and refraction)
is enabled. If it is <tt>miFALSE</tt>, only eye and
<a href="node76.html#INDEX199">transparency ray</a>s are evaluated,
refraction rays degenerate to transparency rays, lens shaders
cannot modify the ray origin and direction, and no shadows are
computed regardless of the <tt>shadow</tt> flag.

<dt><code>scanline</code><dd>
If this flag is <tt>miTRUE</tt>, the scanline algorithm is
enabled for primary rays. If <tt>scanline</tt> is <tt>miFALSE</tt>,
primary rays are cast using pure <a href="node102.html#INDEX390">ray
tracing</a>, which may slow down the rendering process.

<dt><code>motion</code><dd>
If this flag is <tt>miTRUE</tt>, motion blurring is enabled; if
it is <tt>miFALSE</tt>, <a href="node32.html#INDEX60">motion
blur</a>ring is disabled even if motion vectors are present.

<dt><code>shutter</code><dd>
If <i>motion</i> is set to <tt>miTRUE</tt>, the shutter
determines the length of time the shutter is open, which controls
the length of the blur. 1.0 means that the blur is as long as the
<a href="node32.html#INDEX62">motion vector</a>s and
<a href="node90.html#INDEX343">motion transform</a>ations dictate. Values
greater than 1.0 are not recommended because motion paths are extrapolated
beyond the given motion data. This may cause unexpected results in the
case of multiple motion steps, for example.

<dt><code>shutter_delay</code><dd>
If <i>motion</i> is set to <tt>miTRUE</tt>, the
<a href="node76.html#INDEX195">shutter</a> delay determines the time the
shutter opens. It closes at the <i>shutter</i> time, which must be equal to
or greater than <tt>shutter_delay</tt>. A shutter range of 0...1 means that
the blur uses the entire range of the <a href="node32.html#INDEX62">motion
vector</a>s, <a href="node83.html#INDEX290">motion path</a>, or
<a href="node90.html#INDEX343">motion transform</a>ations.

<dt><code>autovolume</code><dd>
If set, mental ray will keep track of which volumes a point is
in. The shader can then use the shader interface functions
<i><a href="node150.html#INDEX766">mi_volume_num_shaders</a></i>,
<i><a href="node150.html#INDEX767">mi_volume_cur_shader</a></i>,
<i><a href="node150.html#INDEX773">mi_volume_user_color</a></i>,
and <i><a href="node150.html#INDEX768">mi_volume_tags</a></i>.

<dt><code>filter</code><dd>
Nonlocal filtering weighs samples according to their distance
from the pixel center. Possible values are <tt>'b'</tt> for box,
<tt>'t'</tt> for triangle, and <tt>'g'</tt> for gauss.

<dt><code>filter_size_x</code><dd>
Contains the filter width for collecting image samples into
frame buffer pixels.

<dt><code>filter_size_y</code><dd>
Contains the filter height.

<dt><code>reflection_depth</code><dd>
The maximal allowed number of recursive reflections. A
reflection ray will only by cast when this limit is not exceeded.
If set to 0, no secondary reflection rays will be cast. See
<tt>reflection_level</tt> above.

<dt><code>refraction_depth</code><dd>
The maximal allowed number of recursive refractions. A
refraction ray will only be cast if this number is not exceeded. If
set to 0, no secondary refraction or
<a href="node76.html#INDEX199">transparency ray</a>s will be cast. See
<tt>refraction_level</tt> above.

<dt><code>trace_depth</code><dd>
The maximal summed trace depth. mental ray will allow this many
segments of the ray tree when it is followed through the scene,
with any combination of reflections and refractions permitted by
the previous two values until the total trace depth is reached. A
ray will only be cast if this number is not exceeded.

<dt id="api:face"><code>face</code><dd>
<a id="INDEX416"></a>
This variable specifies whether front-facing, back-facing, or
all triangles are taken into account. All others are ignored,
resulting in speed improvements. This is also called <i>back face
culling</i>. The possible values are <tt>'f'</tt> (front), <tt>'b'</tt> (back),
and <tt>'a'</tt> (all/both).

<dt><code>field</code><dd>
Field rendering, if turned on, renders only the even or odd
scanlines of an image. Two successive renders are then combined to
a full frame, resulting in smoother animations. <tt>0</tt> turns
off field rendering, <tt>'e'</tt> renders only even scanlines (top
is odd), and <tt>'o'</tt> renders only odd scanlines.

<dt><code>jitter</code><dd>
If set to 1.0, jittering is enabled for samples smaller than a pixel.
If set to 0.0, jittering is disabled. Other values are not legal.

<dt><code>shadow</code><dd>
This ASCII character controls <a href="node76.html#INDEX197">shadow</a>
casting. If it is <tt>0</tt>, shadows are disabled (shadow off); if it
is <tt>1</tt>, normal shadows are computed in undefined order with
volume shaders applied to the <a href="node117.html#INDEX463">light ray</a>
(shadow on);
if it is <tt>'l'</tt>, shadow shaders are called in sorted order
from the light source towards the illumination point (shadow sort);
if it is <tt>'s'</tt>, shadows are computed by tracing the segments
between the illumination point, the occluding objects and the light
source and applying volume shaders to these segments (shadow segment).

<dt><code>use_shadow_maps</code><dd>
Enables <a href="node80.html#INDEX261">shadow map</a>s if set to
<tt>miTRUE</tt>.

<dt><code>rendering_shadow_maps</code><dd>
If set to <tt>miTRUE</tt>, mental ray is currently rendering a
piece of a shadow map. Shaders will never see <tt>miTRUE</tt>
because no shaders are called during shadow map rendering by mental ray.

<dt><code>recompute_shadow_maps</code><dd>
If set to <tt>'y'</tt>, shadow maps will be recomputed even if
shadow map files were found. If set to <tt>'n'</tt>, shadow map
files will be used if available. To use shadow map files, the
shadow-casting light sources must specify a shadow map file name.

<dt><code>shadow_map_motion</code><dd>
If set to <tt>miTRUE</tt>, shadow maps will contain object
motion blur, which will extend the shadows in the direction of motion.

<dt><code>acceleration</code><dd>
The <a href="node102.html#INDEX390">ray tracing</a> algorithm.
This is either <tt>'b'</tt> (a BSP algorithm), <tt>'n'</tt> (BSP2
algorithm), or <span class="depr">Deprecated</span> <tt>'g'</tt>
(former hierarchical uniform grid algorithm). Note, primary rays are
typically computed using the scanline/rasterizer algorithm if enabled.

<dt><code></dt>grid_res[]</code><dd>
<span class="depr">Deprecated</span>
Controls the number of grid voxels in world space, in each dimension,
if the acceleration algorithm is grid.

<dt><code>grid_max_depth</code><dd>
<span class="depr">Deprecated</span>
Controls the number of levels of the grid tree, formed if a grid
voxel of one level contains too much geometry and must be
subdivided by a subgrid on a lower level. It has an effect only if
the acceleration algorithm is grid.

<dt><code>grid_max_size</code><dd>
<span class="depr">Deprecated</span>
Controls the allowed complexity of a grid voxel before the voxel
must be subdivided. It has an effect only if the acceleration
algorithm is grid.

<dt><code>space_max_depth</code><dd>
Controls the number of levels of the BSP tree, formed if a BSP
voxel of one level contains too much geometry and must be
subdivided by a subvoxel on a lower level. It has an effect only if
the acceleration algorithm is BSP.

<dt><code>space_max_size</code><dd>
Controls the allowed complexity of a BSP voxel before the voxel
must be subdivided. It has an effect only if the acceleration
algorithm is BSP. If the <i>space_max_depth</i> limit was reached,
mental ray may exceed <i>space_max_size</i>.

<dt><code>space_max_mem</code><dd>
Limits the memory used by the BSP tree to the specified number
of megabytes. This is mostly an emergency brake because it may
result in an unbalanced BSP tree.

<p>Global illumination options in the <i>state</i>&rarr;options
structure:</p>

<dt><code>photon_reflection_depth</code><dd>
The maximal allowed number of recursive photon reflections.
Similar to <tt>reflection_depth</tt>. Default is 5.

<dt><code>photon_refraction_depth</code><dd>
The maximal allowed number of photon refractions. Similar to
<tt>refraction_depth</tt>. Default is 5.

<dt><code>photon_trace_depth</code><dd>
The maximal summed photon trace depth. The maximum number of
photon bounces is limited by this number. Default is 5.

<dt><code>photonmap_file</code><dd>
The name of the file where <a href="node48.html#INDEX96">photon
map</a>s will be loaded and stored. This is a tag; the actual
string can be accessed with <i><a href="node139.html#INDEX540">mi_db_access</a></i>.

<dt><code>finalgather_file</code><dd>
The name of the file where <a href="node52.html#INDEX98">final
gathering</a> point maps will be loaded and stored. Note that
unlike photon maps, final gather maps can be extended, and will
grow over time unless periodically deleted.

<dt><code>photonmap_rebuild</code><dd>
If set, the <a href="node48.html#INDEX96">photon map</a> file,
if specified, will not be loaded, and the photon map is rebuilt
from scratch. It will still be written if <i>photonmap_file</i> is
defined.

<dt><code>finalgather_rebuild</code><dd>
If set, the final gather map file, if specified, will not be
loaded, and the final gather map is rebuilt from scratch. It will
still be written if <i>finalgather_file</i> is defined.

<dt><code>caustic</code><dd>
Specifies whether <a href="node41.html#INDEX86">caustics</a> are
being simulated or not.

<dt><code>caustic_accuracy</code><dd>
The maximum number of photons to use when computing a caustic
<a href="node48.html#INDEX97">irradiance</a> estimate.

<dt><code>caustic_radius</code><dd>
The radius around the current point in which the caustic
<a href="node48.html#INDEX97">irradiance</a> estimate will look for
photons.

<dt><code>caustic_filter_const</code><dd>
The filter constant for caustic estimates within the caustic radius.

<dt><code>caustic_filter</code><dd>
The type of filter to apply to the photons within the caustic
radius: 'b' for box, 'c' for cone, or 'g' for Gaussian.

<dt><code>caustic_flag</code><dd>
If bits 0 or 1 is set, all instances in the
<a href="node83.html#INDEX286">scene DAG</a> will behave as if they had
bit 0 or 1, respectively, set as well. Bit 0 enables photon casting and
bit 1 enables photon reception. This is useful to make all objects
in the scene contribute to photon tracing, if the scene was built
without photon flags. Older scene creators may not know about these
instance flags and leave them undefined.

<dt><code>globillum</code><dd>
Specifies whether <a href="node48.html#INDEX95">global illumination</a>
is being simulated or not.

<dt><code>globillum_accuracy</code><dd>
The maximum number of photons to use when computing a global
illumination <a href="node48.html#INDEX97">irradiance</a> estimate.

<dt><code>globillum_radius</code><dd>
The radius around the current point in which the global illumination
<a href="node48.html#INDEX97">irradiance</a> estimate will look for
photons.

<dt><code>globillum_flag</code><dd>
The same as <i>caustic_flag</i>, except that it applies to
global illumination, not caustics.

<dt><code>photonvol_accuracy</code><dd>
The maximum number of photons to use when computing a volume global
illumination <a href="node48.html#INDEX97">irradiance</a> estimate.

<dt><code>photonvol_radius</code><dd>
The radius around the current point in which the volume global
illumination <a href="node48.html#INDEX97">irradiance</a> estimate
will look for photons.

<dt><code>finalgather</code><dd>
Specifies whether illumination is computed with
<a href="node52.html#INDEX98">final gathering</a>. Final gathering can be
combined with <a href="node48.html#INDEX95">global illumination</a>,
<a href="node41.html#INDEX86">caustics</a>, or
irradiance particles.

<dt><code>finalgather_rays</code><dd>
The number of rays cast for each final gather point. mental ray's
adaptive optimizer may decide to cast fewer rays than this number,
but will never exceed it.

<dt><code>finalgather_maxradius</code><dd>
The maximum distance between final gather points. If a final
gathering estimate is needed and no final gather point is within
this radius, a new final gather point is computed.

<dt><code>finalgather_minradius</code><dd>
The minimum distance between final gather points. Final gather
points will be avoided if they would be closer than this to another
final gather point.

<dt><code>finalgather_view</code><dd>
If set, this flag switches final gather radii to raster pixels
instead of world space units. This causes final gathering to be
view-dependent: distant objects will receive fewer final gather
points than close objects.

<dt><code>n_motion_vectors</code><dd>
Specifies the number of segments to be used for motion paths
that approximate transformation motion. The default is 1; the
maximum number is 15. Larger numbers allow to render motion paths
that are more smoothly curved at the expense of runtime.
</dl>

<ul class="nav">
<li><a href="index.html">home</a></li>
<li><a href="node109.html">&laquo;&nbsp;prev</a></li>
<li><a href="node111.html">next&nbsp;&raquo;</a></li>
<li><a href="globalindex.html">index</a></li>
</ul>
<p>
<a href="copyright.html">Copyright</a> &copy; 1986-2010 by
<a href="http://www.mental.com">mental images GmbH</a></p>
</body>
</html>
