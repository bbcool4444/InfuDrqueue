<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mental ray Interface: mi::shader_v3::Interface Struct Reference</title>
<link href="mi_iface.css" rel="stylesheet" type="text/css">
</head>
<body>
<ul class="nav">
<li><a href="index.html">home</a></li>
<li><a href="shader_if_cpp.html">up</a></li>
<li><a href="globalindex.html">index</a></li>
</ul>

<!-- Generated by Doxygen 1.5.6 -->
  <div class="navpath"><a class="el" href="namespacemi.html">mi</a>::<a class="el" href="namespacemi_1_1shader__v3.html">shader_v3</a>::<a class="el" href="structmi_1_1shader__v3_1_1Interface.html">Interface</a>
  </div>
<div class="contents">
<h1>mi::shader_v3::Interface Struct Reference</h1><!-- doxytag: class="mi::shader_v3::Interface" -->Top level C++ mental ray interface extensions.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="mi__shader__if_8h-source.html">mi_shader_if.h</a>&gt;</code>
<p>

<p>
<a href="structmi_1_1shader__v3_1_1Interface-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1Options.html">Options</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#4edb35278a19602c07f1f340b83e8b08">getOptions</a> (miTag string_options)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access to string options.  <a href="#4edb35278a19602c07f1f340b83e8b08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual miTag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#3747704ea411fb578507e9f8d51ac067">createFramebuffer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classmi_1_1shader__v3_1_1Framebuffer.html" title="Framebuffer class.">Framebuffer</a> factory function.  <a href="#3747704ea411fb578507e9f8d51ac067"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual miTag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#ecd5f7603a750d42f438e47dad022f83">copyFramebuffer</a> (miTag old_buffer_tag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a copy of the framebuffer collection.  <a href="#ecd5f7603a750d42f438e47dad022f83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1LightList.html">LightList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#a0d4e3c31bcf7dc601550efb0e09a074">createLightList</a> (miState *state, miTag *slist=0, int n=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal function to create a light list.  <a href="#a0d4e3c31bcf7dc601550efb0e09a074"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#5186e5aa1cd31c41f52b0f18d5497884">release</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release (delete) the instance of the interface.  <a href="#5186e5aa1cd31c41f52b0f18d5497884"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1LightList.html">LightList</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#789cb2addce1ab6a94b85a9a0c7a2b91">createLightList</a> (miState *state, const miVector &amp;axis, miScalar spread_cos, miTag *slist=0, int n=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used internally by <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> to create a light list.  <a href="#789cb2addce1ab6a94b85a9a0c7a2b91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1Edit__map__dbhandle.html">Edit_map_dbhandle</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#12fa7a4f4c3edb0dbc6b3fe7fe589b89">createMap</a> (const <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration__base.html">Map_declaration_base</a> *map_declaration=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creation of map.  <a href="#12fa7a4f4c3edb0dbc6b3fe7fe589b89"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1Access__map__dbhandle.html">Access_map_dbhandle</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#18f47ad6395e710e180f64137fc2c205">accessMap</a> (const miTag map_tag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read-only access to a map in the DB.  <a href="#18f47ad6395e710e180f64137fc2c205"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1Edit__map__dbhandle.html">Edit_map_dbhandle</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#632292062f34cd218df103e9988d5c65">editMap</a> (const miTag map_tag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read-write access to a map in the DB.  <a href="#632292062f34cd218df103e9988d5c65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1Access__map__dbhandle.html">Access_map_dbhandle</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#5b000a589e51a83f23912308860adac5">accessMap</a> (const char *filename, <a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read-only access to a map to be read from file.  <a href="#5b000a589e51a83f23912308860adac5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1Edit__map__dbhandle.html">Edit_map_dbhandle</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#4a42904371d37ff01a20ba17edb1acba">editMap</a> (const char *filename, <a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read-write access to a map to be read from file.  <a href="#4a42904371d37ff01a20ba17edb1acba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration__base.html">Map_declaration_base</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#5c45547e944314184118a4d1cf85ccc8">createMapDeclaration</a> (const miUint dimension)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creation of a map declaration.  <a href="#5c45547e944314184118a4d1cf85ccc8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration__base.html">Map_declaration_base</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#8920c38bc44a3c2b527175bd3bc56d59">copyMapDeclaration</a> (const <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration__base.html">Map_declaration_base</a> *other, <a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy of a map declaration.  <a href="#8920c38bc44a3c2b527175bd3bc56d59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration__base.html">Map_declaration_base</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#eaee4a56a7241a3c2903a3eec94096bd">copyMapDeclaration</a> (const <a class="el" href="classmi_1_1shader__v3_1_1Map__element__base.html">Map_element_base</a> *map_element, <a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy of the declaration of a map element.  <a href="#eaee4a56a7241a3c2903a3eec94096bd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration__base.html">Map_declaration_base</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#b776ba1facc3cb7cbf7d4214cbac4231">copyMapDeclaration</a> (const <a class="el" href="classmi_1_1shader__v3_1_1Map__base.html">Map_base</a> *map, <a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy of the declaration of a map.  <a href="#b776ba1facc3cb7cbf7d4214cbac4231"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__element__base.html">Map_element_base</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#c79addf5b782262ccf36ef082ec001ea">createMapElement</a> (const <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration__base.html">Map_declaration_base</a> *declaration=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creation of a map element.  <a href="#c79addf5b782262ccf36ef082ec001ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__element__base.html">Map_element_base</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#470011b8500182c9df5494f42f5c0467">copyMapElement</a> (const <a class="el" href="classmi_1_1shader__v3_1_1Map__element__base.html">Map_element_base</a> *other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy of a map element.  <a href="#470011b8500182c9df5494f42f5c0467"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__iterator__base.html">Map_iterator_base</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#88a855afe5d58d294b4d3ebc3719e471">createMapIterator</a> (const <a class="el" href="classmi_1_1shader__v3_1_1Map__base.html">Map_base</a> *map, <a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creation of a map iterator.  <a href="#88a855afe5d58d294b4d3ebc3719e471"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__iterator__base.html">Map_iterator_base</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#9e0efbdf393343fd040e0f3151ca6186">copyMapIterator</a> (const <a class="el" href="classmi_1_1shader__v3_1_1Map__iterator__base.html">Map_iterator_base</a> *other, <a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy of a map iterator.  <a href="#9e0efbdf393343fd040e0f3151ca6186"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__lookup__base.html">Map_lookup_base</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#7a72e15e6b733e4ad81e8bb6aaef0320">createMapLookup</a> (const <a class="el" href="classmi_1_1shader__v3_1_1Map__base.html">Map_base</a> *map, <a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creation of a map lookup.  <a href="#7a72e15e6b733e4ad81e8bb6aaef0320"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__lookup__base.html">Map_lookup_base</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#6a62e2803e79f52fb0c02018cc9b3f26">copyMapLookup</a> (const <a class="el" href="classmi_1_1shader__v3_1_1Map__lookup__base.html">Map_lookup_base</a> *other, <a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *status)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy of a map lookup.  <a href="#6a62e2803e79f52fb0c02018cc9b3f26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classmi_1_1shader__v3_1_1Subdivision34.html">Subdivision34</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#dbf1eee5bdb41e1757b6544beb8d6420">accessSubdivision34</a> (miTag tag)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provide access to (allocate) the <a class="el" href="classmi_1_1shader__v3_1_1Subdivision34.html" title="Subdivision34 class.">Subdivision34</a> class.  <a href="#dbf1eee5bdb41e1757b6544beb8d6420"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#c317d7399a6565fd2640b24d0a748a1d">releaseSubdivision34</a> (const <a class="el" href="classmi_1_1shader__v3_1_1Subdivision34.html">Subdivision34</a> *subdiv34)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release (delete) the <a class="el" href="classmi_1_1shader__v3_1_1Subdivision34.html" title="Subdivision34 class.">Subdivision34</a> class.  <a href="#c317d7399a6565fd2640b24d0a748a1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#9ee5229d97d719362963faca0848498e">lookup_filter_color_texture</a> (miColor *const color, miState *const state, const miTag tex, <a class="el" href="classmi_1_1shader__v3_1_1Mip__remap.html">Mip_remap</a> &amp;remap, miVector *coord)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Elliptical texture filtering.  <a href="#9ee5229d97d719362963faca0848498e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="structmi_1_1shader__v3_1_1Interface.html">Interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmi_1_1shader__v3_1_1Interface.html#bc08f119567f994bbe0db96b64a5af91">get</a> (int version=mi_ray_interface_version)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire an instance of the interface.  <a href="#bc08f119567f994bbe0db96b64a5af91"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Top level C++ mental ray interface extensions. 
<p>
This class is the top level access to the C++ shader interface extensions. All other C++ extensions like mi::shader::Options and mi::shader::LightIterator are accessible through this class.<p>
An instance of the <a class="el" href="structmi_1_1shader__v3_1_1Interface.html" title="Top level C++ mental ray interface extensions.">Interface</a> must be acquired by calling <a class="el" href="mi__shader__if_8h.html#c437703a9041a1930a4c50032f6669ad" title="Acquire an instance of the mental ray C++ shader interface extensions.">mi_get_shader_interface()</a> or the static method <a class="el" href="structmi_1_1shader__v3_1_1Interface.html#bc08f119567f994bbe0db96b64a5af91" title="Acquire an instance of the interface.">Interface::get()</a>. When the interface is no more needed, it must be released by calling <a class="el" href="structmi_1_1shader__v3_1_1Interface.html#5186e5aa1cd31c41f52b0f18d5497884" title="Release (delete) the instance of the interface.">Interface::release()</a>: <div class="fragment"><pre class="fragment"> mi::shader::Interface *iface = mi::shader::Interface::get();
 <span class="comment">// do something with it...</span>
 iface-&gt;release();
</pre></div><p>
The C++ interface extensions are implemented as virtual functions in this interface struct in order to avoid linking and symbol lookup problems. The interface is defined in the header file <a class="el" href="mi__shader__if_8h.html">mi_shader_if.h</a>. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="bc08f119567f994bbe0db96b64a5af91"></a><!-- doxytag: member="mi::shader_v3::Interface::get" ref="bc08f119567f994bbe0db96b64a5af91" args="(int version=mi_ray_interface_version)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmi_1_1shader__v3_1_1Interface.html">Interface</a>* mi::shader_v3::Interface::get           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em> = <code>mi_ray_interface_version</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Acquire an instance of the interface. 
<p>
This static method is equivalent to the function <a class="el" href="mi__shader__if_8h.html#c437703a9041a1930a4c50032f6669ad" title="Acquire an instance of the mental ray C++ shader interface extensions.">mi_get_shader_interface()</a>, see there fore more information. This static function can be used as follows: <div class="fragment"><pre class="fragment"> mi::shader::Interface *iface = mi::shader::Interface::get();
</pre></div> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>is the version number of the requested interface class, usually no version argument needs to be passed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The returned pointer points to an object in mental ray which contains the interface functions as virtual methods (hence it is possible to call the interface routines from a dynamically loaded library without resolving the routine in a symbol table). The caller may not attempt to modify or delete the returned object but should call the mi::shader::Interface::release() method when done. </dd></dl>

<p>References <a class="el" href="mi__shader__if_8h.html#c437703a9041a1930a4c50032f6669ad">mi_get_shader_interface()</a>.</p>

</div>
</div><p>
<a class="anchor" name="4edb35278a19602c07f1f340b83e8b08"></a><!-- doxytag: member="mi::shader_v3::Interface::getOptions" ref="4edb35278a19602c07f1f340b83e8b08" args="(miTag string_options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1Options.html">Options</a>* mi::shader_v3::Interface::getOptions           </td>
          <td>(</td>
          <td class="paramtype">miTag&nbsp;</td>
          <td class="paramname"> <em>string_options</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access to string options. 
<p>
This may later be extended to also access all other options from the miOptions structure. This function can be used as follows: <div class="fragment"><pre class="fragment"> Options *stringOptions = interface-&gt;getOptions(options-&gt;string_options);
</pre></div> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string_options</em>&nbsp;</td><td>is the tag of the string options, taken from the string_options field of the miOptions structure to be read or modified. It must be valid throughout the use of the <a class="el" href="classmi_1_1shader__v3_1_1Options.html" title="Access to string options.">Options</a> instance. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to an interface class. The <a class="el" href="classmi_1_1shader__v3_1_1Options.html#2de4e29a450105f2c7c5b789f82bcb8b" title="Release (delete) the interface.">Options::release()</a> method should be called when done. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3747704ea411fb578507e9f8d51ac067"></a><!-- doxytag: member="mi::shader_v3::Interface::createFramebuffer" ref="3747704ea411fb578507e9f8d51ac067" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual miTag mi::shader_v3::Interface::createFramebuffer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classmi_1_1shader__v3_1_1Framebuffer.html" title="Framebuffer class.">Framebuffer</a> factory function. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a database tag for an empty framebuffer collection. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ecd5f7603a750d42f438e47dad022f83"></a><!-- doxytag: member="mi::shader_v3::Interface::copyFramebuffer" ref="ecd5f7603a750d42f438e47dad022f83" args="(miTag old_buffer_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual miTag mi::shader_v3::Interface::copyFramebuffer           </td>
          <td>(</td>
          <td class="paramtype">miTag&nbsp;</td>
          <td class="paramname"> <em>old_buffer_tag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a copy of the framebuffer collection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>old_buffer_tag</em>&nbsp;</td><td>A database tag for the framebuffer to copy </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a database tag for a copy of framebuffer collection. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a0d4e3c31bcf7dc601550efb0e09a074"></a><!-- doxytag: member="mi::shader_v3::Interface::createLightList" ref="a0d4e3c31bcf7dc601550efb0e09a074" args="(miState *state, miTag *slist=0, int n=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1LightList.html">LightList</a>* mi::shader_v3::Interface::createLightList           </td>
          <td>(</td>
          <td class="paramtype">miState *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">miTag *&nbsp;</td>
          <td class="paramname"> <em>slist</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal function to create a light list. 
<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd></dd></dl>
This may be used to generate light iterators. This method is needed by the <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html#ac718a9cd15e60d735e17ab8467d7d80" title="the constructor for the LightIterator">LightIterator::LightIterator()</a> constructor. Usually there is no need to invoke this method directly. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>provided the method with the current rendering state. From the state the current instance light list may be deduced. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slist</em>&nbsp;</td><td>is an optional list of light tags. If provided, this list will be used instead of the default instance light list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>gives the number of light tags in the optional light list. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the method returns a pointer to a <a class="el" href="classmi_1_1shader__v3_1_1LightList.html" title="Light lists, used internally by LightIterator.">LightList</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5186e5aa1cd31c41f52b0f18d5497884"></a><!-- doxytag: member="mi::shader_v3::Interface::release" ref="5186e5aa1cd31c41f52b0f18d5497884" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mi::shader_v3::Interface::release           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release (delete) the instance of the interface. 
<p>
An interface acquired with <a class="el" href="mi__shader__if_8h.html#c437703a9041a1930a4c50032f6669ad" title="Acquire an instance of the mental ray C++ shader interface extensions.">mi_get_shader_interface()</a> or mi::shader::Interface::get() must be released with this call when done. The call may delete the object, and the interface may no longer be used afterwards. 
<p>Referenced by <a class="el" href="shader__framebuffer_8h-source.html#l00217">mi::shader_v3::Access_fb::~Access_fb()</a>, <a class="el" href="mi__shader__if_8h-source.html#l00701">mi::shader_v3::Access_interface::~Access_interface()</a>, <a class="el" href="shader__sds34_8h-source.html#l00156">mi::shader_v3::Access_subdivision34::~Access_subdivision34()</a>, and <a class="el" href="shader__framebuffer_8h-source.html#l00240">mi::shader_v3::Edit_fb::~Edit_fb()</a>.</p>

</div>
</div><p>
<a class="anchor" name="789cb2addce1ab6a94b85a9a0c7a2b91"></a><!-- doxytag: member="mi::shader_v3::Interface::createLightList" ref="789cb2addce1ab6a94b85a9a0c7a2b91" args="(miState *state, const miVector &amp;axis, miScalar spread_cos, miTag *slist=0, int n=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1LightList.html">LightList</a>* mi::shader_v3::Interface::createLightList           </td>
          <td>(</td>
          <td class="paramtype">miState *&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const miVector &amp;&nbsp;</td>
          <td class="paramname"> <em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">miScalar&nbsp;</td>
          <td class="paramname"> <em>spread_cos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">miTag *&nbsp;</td>
          <td class="paramname"> <em>slist</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used internally by <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html" title="Iterate over shader or instance light lists.">LightIterator</a> to create a light list. 
<p>
This may be used to generate light iterators. This method is needed by the <a class="el" href="classmi_1_1shader__v3_1_1LightIterator.html#ac718a9cd15e60d735e17ab8467d7d80" title="the constructor for the LightIterator">LightIterator::LightIterator()</a> constructor. Usually there is no need to invoke this method directly. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>provided the method with the current rendering state. From the state the current instance light list may be deduced. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>axis</em>&nbsp;</td><td>specifies the axis for the light cone. The value should be normalized. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spread_cos</em>&nbsp;</td><td>specifies the cosine of the angle to the light cone axis. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>slist</em>&nbsp;</td><td>is an optional list of light tags. If provided, this list will be used instead of the default instance light list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>gives the number of light tags in the optional light list. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the method returns a pointer to a <a class="el" href="classmi_1_1shader__v3_1_1LightList.html" title="Light lists, used internally by LightIterator.">LightList</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="12fa7a4f4c3edb0dbc6b3fe7fe589b89"></a><!-- doxytag: member="mi::shader_v3::Interface::createMap" ref="12fa7a4f4c3edb0dbc6b3fe7fe589b89" args="(const Map_declaration_base *map_declaration=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1Edit__map__dbhandle.html">Edit_map_dbhandle</a>* mi::shader_v3::Interface::createMap           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration__base.html">Map_declaration_base</a> *&nbsp;</td>
          <td class="paramname"> <em>map_declaration</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creation of map. 
<p>
This function is wrapped by the <a class="el" href="classmi_1_1shader__v3_1_1Edit__map.html" title="Smart pointer (read/write) to a map in the DB, to a map to be read from file, or...">Edit_map</a> class and should not be used directly. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map_declaration</em>&nbsp;</td><td>is the declaration (possibly NULL) of the new map </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the newly created map </dd></dl>

</div>
</div><p>
<a class="anchor" name="18f47ad6395e710e180f64137fc2c205"></a><!-- doxytag: member="mi::shader_v3::Interface::accessMap" ref="18f47ad6395e710e180f64137fc2c205" args="(const miTag map_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1Access__map__dbhandle.html">Access_map_dbhandle</a>* mi::shader_v3::Interface::accessMap           </td>
          <td>(</td>
          <td class="paramtype">const miTag&nbsp;</td>
          <td class="paramname"> <em>map_tag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read-only access to a map in the DB. 
<p>
This function is wrapped by the <a class="el" href="classmi_1_1shader__v3_1_1Access__map.html" title="Smart pointer (access-only) to a map in the DB or to a map to be read from file....">Access_map</a> class and should not be used directly <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map_tag</em>&nbsp;</td><td>database tag of the map </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the map </dd></dl>

</div>
</div><p>
<a class="anchor" name="632292062f34cd218df103e9988d5c65"></a><!-- doxytag: member="mi::shader_v3::Interface::editMap" ref="632292062f34cd218df103e9988d5c65" args="(const miTag map_tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1Edit__map__dbhandle.html">Edit_map_dbhandle</a>* mi::shader_v3::Interface::editMap           </td>
          <td>(</td>
          <td class="paramtype">const miTag&nbsp;</td>
          <td class="paramname"> <em>map_tag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read-write access to a map in the DB. 
<p>
This function is wrapped by the <a class="el" href="classmi_1_1shader__v3_1_1Edit__map.html" title="Smart pointer (read/write) to a map in the DB, to a map to be read from file, or...">Edit_map</a> class and should not be used directly <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map_tag</em>&nbsp;</td><td>database tag of the map </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the map </dd></dl>

</div>
</div><p>
<a class="anchor" name="5b000a589e51a83f23912308860adac5"></a><!-- doxytag: member="mi::shader_v3::Interface::accessMap" ref="5b000a589e51a83f23912308860adac5" args="(const char *filename, Map_status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1Access__map__dbhandle.html">Access_map_dbhandle</a>* mi::shader_v3::Interface::accessMap           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read-only access to a map to be read from file. 
<p>
This function is wrapped by the <a class="el" href="classmi_1_1shader__v3_1_1Access__map.html" title="Smart pointer (access-only) to a map in the DB or to a map to be read from file....">Access_map</a> class and should not be used directly <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>the file name of the map to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>a status code </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the map </dd></dl>

</div>
</div><p>
<a class="anchor" name="4a42904371d37ff01a20ba17edb1acba"></a><!-- doxytag: member="mi::shader_v3::Interface::editMap" ref="4a42904371d37ff01a20ba17edb1acba" args="(const char *filename, Map_status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1Edit__map__dbhandle.html">Edit_map_dbhandle</a>* mi::shader_v3::Interface::editMap           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read-write access to a map to be read from file. 
<p>
This function is wrapped by the <a class="el" href="classmi_1_1shader__v3_1_1Edit__map.html" title="Smart pointer (read/write) to a map in the DB, to a map to be read from file, or...">Edit_map</a> class and should not be used directly <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>the file name of the map to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>a status code </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the map </dd></dl>

</div>
</div><p>
<a class="anchor" name="5c45547e944314184118a4d1cf85ccc8"></a><!-- doxytag: member="mi::shader_v3::Interface::createMapDeclaration" ref="5c45547e944314184118a4d1cf85ccc8" args="(const miUint dimension)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration__base.html">Map_declaration_base</a>* mi::shader_v3::Interface::createMapDeclaration           </td>
          <td>(</td>
          <td class="paramtype">const miUint&nbsp;</td>
          <td class="paramname"> <em>dimension</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creation of a map declaration. 
<p>
This function is wrapped by the <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration.html" title="Smart pointer to a map declaration, which allows to retrieve a copy of the declaration...">Map_declaration</a> class and should not be used directly <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dimension</em>&nbsp;</td><td>is the dimension of the position </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the newly created map declaration </dd></dl>

</div>
</div><p>
<a class="anchor" name="8920c38bc44a3c2b527175bd3bc56d59"></a><!-- doxytag: member="mi::shader_v3::Interface::copyMapDeclaration" ref="8920c38bc44a3c2b527175bd3bc56d59" args="(const Map_declaration_base *other, Map_status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration__base.html">Map_declaration_base</a>* mi::shader_v3::Interface::copyMapDeclaration           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration__base.html">Map_declaration_base</a> *&nbsp;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy of a map declaration. 
<p>
This function is wrapped by the <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration.html" title="Smart pointer to a map declaration, which allows to retrieve a copy of the declaration...">Map_declaration</a> class and should not be used directly <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>is the handle of the declaration to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>is a status code </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the newly copied map declaration </dd></dl>

</div>
</div><p>
<a class="anchor" name="eaee4a56a7241a3c2903a3eec94096bd"></a><!-- doxytag: member="mi::shader_v3::Interface::copyMapDeclaration" ref="eaee4a56a7241a3c2903a3eec94096bd" args="(const Map_element_base *map_element, Map_status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration__base.html">Map_declaration_base</a>* mi::shader_v3::Interface::copyMapDeclaration           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1shader__v3_1_1Map__element__base.html">Map_element_base</a> *&nbsp;</td>
          <td class="paramname"> <em>map_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy of the declaration of a map element. 
<p>
This function is wrapped by the <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration.html" title="Smart pointer to a map declaration, which allows to retrieve a copy of the declaration...">Map_declaration</a> class and should not be used directly <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map_element</em>&nbsp;</td><td>is the map element to get a copy of the decl from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>is a status code </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the newly copied map declaration </dd></dl>

</div>
</div><p>
<a class="anchor" name="b776ba1facc3cb7cbf7d4214cbac4231"></a><!-- doxytag: member="mi::shader_v3::Interface::copyMapDeclaration" ref="b776ba1facc3cb7cbf7d4214cbac4231" args="(const Map_base *map, Map_status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration__base.html">Map_declaration_base</a>* mi::shader_v3::Interface::copyMapDeclaration           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1shader__v3_1_1Map__base.html">Map_base</a> *&nbsp;</td>
          <td class="paramname"> <em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy of the declaration of a map. 
<p>
This function is wrapped by the <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration.html" title="Smart pointer to a map declaration, which allows to retrieve a copy of the declaration...">Map_declaration</a> class and should not be used directly <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>is the map to get a copy of the declaration from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>is a status code </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the newly copied map declaration </dd></dl>

</div>
</div><p>
<a class="anchor" name="c79addf5b782262ccf36ef082ec001ea"></a><!-- doxytag: member="mi::shader_v3::Interface::createMapElement" ref="c79addf5b782262ccf36ef082ec001ea" args="(const Map_declaration_base *declaration=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__element__base.html">Map_element_base</a>* mi::shader_v3::Interface::createMapElement           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1shader__v3_1_1Map__declaration__base.html">Map_declaration_base</a> *&nbsp;</td>
          <td class="paramname"> <em>declaration</em> = <code>0</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creation of a map element. 
<p>
This function is wrapped by the <a class="el" href="classmi_1_1shader__v3_1_1Map__element.html" title="Smart pointer to a map element. It defines a dereference operator which provides...">Map_element</a> class and should not be used directly <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>declaration</em>&nbsp;</td><td>is the (possible) declaration to use </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the newly created map element </dd></dl>

</div>
</div><p>
<a class="anchor" name="470011b8500182c9df5494f42f5c0467"></a><!-- doxytag: member="mi::shader_v3::Interface::copyMapElement" ref="470011b8500182c9df5494f42f5c0467" args="(const Map_element_base *other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__element__base.html">Map_element_base</a>* mi::shader_v3::Interface::copyMapElement           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1shader__v3_1_1Map__element__base.html">Map_element_base</a> *&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy of a map element. 
<p>
This function is wrapped by the <a class="el" href="classmi_1_1shader__v3_1_1Map__element.html" title="Smart pointer to a map element. It defines a dereference operator which provides...">Map_element</a> class and should not be used directly <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>is the element to copy </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the newly copied map element </dd></dl>

</div>
</div><p>
<a class="anchor" name="88a855afe5d58d294b4d3ebc3719e471"></a><!-- doxytag: member="mi::shader_v3::Interface::createMapIterator" ref="88a855afe5d58d294b4d3ebc3719e471" args="(const Map_base *map, Map_status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__iterator__base.html">Map_iterator_base</a>* mi::shader_v3::Interface::createMapIterator           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1shader__v3_1_1Map__base.html">Map_base</a> *&nbsp;</td>
          <td class="paramname"> <em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creation of a map iterator. 
<p>
This function is wrapped by the Access_map_iterator/edit classes and should not be used directly <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>is the map to attach the iterator to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>is a status code </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the newly created map iterator </dd></dl>

</div>
</div><p>
<a class="anchor" name="9e0efbdf393343fd040e0f3151ca6186"></a><!-- doxytag: member="mi::shader_v3::Interface::copyMapIterator" ref="9e0efbdf393343fd040e0f3151ca6186" args="(const Map_iterator_base *other, Map_status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__iterator__base.html">Map_iterator_base</a>* mi::shader_v3::Interface::copyMapIterator           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1shader__v3_1_1Map__iterator__base.html">Map_iterator_base</a> *&nbsp;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy of a map iterator. 
<p>
This function is wrapped by the map_iterator_access/edit classes and should not be used directly <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>is the iterator to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>is a status code </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the newly copied map iterator </dd></dl>

</div>
</div><p>
<a class="anchor" name="7a72e15e6b733e4ad81e8bb6aaef0320"></a><!-- doxytag: member="mi::shader_v3::Interface::createMapLookup" ref="7a72e15e6b733e4ad81e8bb6aaef0320" args="(const Map_base *map, Map_status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__lookup__base.html">Map_lookup_base</a>* mi::shader_v3::Interface::createMapLookup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1shader__v3_1_1Map__base.html">Map_base</a> *&nbsp;</td>
          <td class="paramname"> <em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creation of a map lookup. 
<p>
This function is wrapped by the <a class="el" href="classmi_1_1shader__v3_1_1Map__lookup.html" title="Smart pointer to a map lookup. It defines a dereference operator which provides access...">Map_lookup</a> class and should not be used directly <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>map</em>&nbsp;</td><td>is the map to attach the lookup to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>is a status code </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the newly created map lookup </dd></dl>

</div>
</div><p>
<a class="anchor" name="6a62e2803e79f52fb0c02018cc9b3f26"></a><!-- doxytag: member="mi::shader_v3::Interface::copyMapLookup" ref="6a62e2803e79f52fb0c02018cc9b3f26" args="(const Map_lookup_base *other, Map_status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1Map__lookup__base.html">Map_lookup_base</a>* mi::shader_v3::Interface::copyMapLookup           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1shader__v3_1_1Map__lookup__base.html">Map_lookup_base</a> *&nbsp;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmi_1_1shader__v3_1_1Map__status.html">Map_status</a> *&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy of a map lookup. 
<p>
This function is wrapped by the <a class="el" href="classmi_1_1shader__v3_1_1Map__lookup.html" title="Smart pointer to a map lookup. It defines a dereference operator which provides access...">Map_lookup</a> class and should not be used directly <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>is the lookup to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>is a status code </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the newly created map lookup </dd></dl>

</div>
</div><p>
<a class="anchor" name="dbf1eee5bdb41e1757b6544beb8d6420"></a><!-- doxytag: member="mi::shader_v3::Interface::accessSubdivision34" ref="dbf1eee5bdb41e1757b6544beb8d6420" args="(miTag tag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1shader__v3_1_1Subdivision34.html">Subdivision34</a>* mi::shader_v3::Interface::accessSubdivision34           </td>
          <td>(</td>
          <td class="paramtype">miTag&nbsp;</td>
          <td class="paramname"> <em>tag</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provide access to (allocate) the <a class="el" href="classmi_1_1shader__v3_1_1Subdivision34.html" title="Subdivision34 class.">Subdivision34</a> class. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td>is the MI::SDS::Subdiv34 class tag </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c317d7399a6565fd2640b24d0a748a1d"></a><!-- doxytag: member="mi::shader_v3::Interface::releaseSubdivision34" ref="c317d7399a6565fd2640b24d0a748a1d" args="(const Subdivision34 *subdiv34)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mi::shader_v3::Interface::releaseSubdivision34           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1shader__v3_1_1Subdivision34.html">Subdivision34</a> *&nbsp;</td>
          <td class="paramname"> <em>subdiv34</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Release (delete) the <a class="el" href="classmi_1_1shader__v3_1_1Subdivision34.html" title="Subdivision34 class.">Subdivision34</a> class. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>subdiv34</em>&nbsp;</td><td>is the pointer returned by accessSubdivision34 </td></tr>
  </table>
</dl>

<p>Referenced by <a class="el" href="shader__sds34_8h-source.html#l00156">mi::shader_v3::Access_subdivision34::~Access_subdivision34()</a>.</p>

</div>
</div><p>
<a class="anchor" name="9ee5229d97d719362963faca0848498e"></a><!-- doxytag: member="mi::shader_v3::Interface::lookup_filter_color_texture" ref="9ee5229d97d719362963faca0848498e" args="(miColor *const color, miState *const state, const miTag tex, Mip_remap &amp;remap, miVector *coord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mi::shader_v3::Interface::lookup_filter_color_texture           </td>
          <td>(</td>
          <td class="paramtype">miColor *const &nbsp;</td>
          <td class="paramname"> <em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">miState *const &nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const miTag&nbsp;</td>
          <td class="paramname"> <em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmi_1_1shader__v3_1_1Mip__remap.html">Mip_remap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>remap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">miVector *&nbsp;</td>
          <td class="paramname"> <em>coord</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Elliptical texture filtering. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>result color </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>current rendering state </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tex</em>&nbsp;</td><td>tag of database element miSCENE_IMAGE (the texture) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>remap</em>&nbsp;</td><td>reference to derived class <a class="el" href="classmi_1_1shader__v3_1_1Mip__remap.html" title="Texture re-mapping interface.">Mip_remap</a> providing implementation of texture coordinate transformation and remapping </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coord</em>&nbsp;</td><td>2d texture coordinates (only x and y used). </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>returns true on success, false if for example the input texture does not have the type miSCENE_IMAGE. </dd></dl>

</div>
</div><p>
</div>

<ul class="nav">
<li><a href="index.html">home</a></li>
<li><a href="shader_if_cpp.html">up</a></li>
<li><a href="globalindex.html">index</a></li>
</ul>
<p><a href="copyright.html">Copyright</a> &copy; 1986-2010 by
<a href="http://www.mental.com">mental images GmbH</a><br></p>
</body>
</html>

